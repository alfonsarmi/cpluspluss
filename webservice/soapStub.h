/* soapStub.h
   Generated by gSOAP 2.8.54 for sopa.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#define SOAP_NAMESPACE_OF_ns1	"http://es.indra.transporte.iarioncs"
#define SOAP_NAMESPACE_OF_ns2	"http://afc.transporte.indra.es/configuration/types"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20854
# error "GSOAP VERSION 20854 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* sopa.h:1374 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType
#define SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType (401)
/* ns1:MTC_QuantityUnitsType */
enum ns1__MTC_USCOREQuantityUnitsType {
	ns1__MTC_USCOREQuantityUnitsType__TRIPS = 0,
	ns1__MTC_USCOREQuantityUnitsType__EUROCENT = 1
};
#endif

/* sopa.h:1390 */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUValueType
#define SOAP_TYPE_ns1__AlarmCCTIUValueType (403)
/* ns1:AlarmCCTIUValueType */
enum ns1__AlarmCCTIUValueType {
	ns1__AlarmCCTIUValueType__ACT = 0,
	ns1__AlarmCCTIUValueType__DES = 1
};
#endif

/* sopa.h:1406 */
#ifndef SOAP_TYPE_ns1__QuantityUnitsType
#define SOAP_TYPE_ns1__QuantityUnitsType (405)
/* ns1:QuantityUnitsType */
enum ns1__QuantityUnitsType {
	ns1__QuantityUnitsType__TRIPS = 0,
	ns1__QuantityUnitsType__EUROCENT = 1
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* sopa.h:133 */
class xsd__base64Binary;	/* sopa.h:136 */
class xsd__hexBinary;	/* sopa.h:143 */
class xsd__base64Binary_;	/* sopa.h:147 */
class xsd__boolean;	/* sopa.h:154 */
class xsd__date_;	/* sopa.h:164 */
class xsd__dateTime;	/* sopa.h:171 */
class xsd__double;	/* sopa.h:178 */
class xsd__float;	/* sopa.h:185 */
class xsd__hexBinary_;	/* sopa.h:192 */
class xsd__int;	/* sopa.h:199 */
class xsd__integer_;	/* sopa.h:209 */
class xsd__language_;	/* sopa.h:219 */
class xsd__long;	/* sopa.h:226 */
class xsd__positiveInteger_;	/* sopa.h:236 */
class xsd__string;	/* sopa.h:243 */
class xsd__unsignedInt;	/* sopa.h:250 */
class xsd__unsignedLong;	/* sopa.h:257 */
class xsd__unsignedShort;	/* sopa.h:264 */
class ns1__MTC_USCOREQuantityUnitsType_;	/* sopa.h:1381 */
class ns1__AlarmCCTIUValueType_;	/* sopa.h:1397 */
class ns1__QuantityUnitsType_;	/* sopa.h:1413 */
class ns1__getProtoVersionList;	/* sopa.h:278 */
class ns1__getProtoVersionListResponse;	/* sopa.h:281 */
class ns1__getVersionList;	/* sopa.h:284 */
class ns1__PatternServiceRequestType;	/* sopa.h:290 */
class ns1__EquipmentReferenceType;	/* sopa.h:293 */
class ns1__SlaveEquipmentListType;	/* sopa.h:296 */
class ns1__RecordRangeIdTypeList;	/* sopa.h:302 */
class ns1__RecordRangeIdType;	/* sopa.h:305 */
class ns1__RecordIdType;	/* sopa.h:308 */
class ns1__CustomRecordRequest;	/* sopa.h:311 */
class ns1__ParameterList;	/* sopa.h:314 */
class ns1__Parameter;	/* sopa.h:317 */
class ns1__TransactionMTCIdRangeListType;	/* sopa.h:323 */
class ns1__TransactionMTCIdRangeType;	/* sopa.h:326 */
class ns1__MTC_USCORETransactionIdType;	/* sopa.h:329 */
class ns1__ConfigElementCCTIUListType;	/* sopa.h:356 */
class ns1__ConfigElementCCTIUType;	/* sopa.h:359 */
class ns1__ValueType;	/* sopa.h:362 */
class ns1__CommandCCTIUType;	/* sopa.h:368 */
class ns1__CommandParamCCTIUListType;	/* sopa.h:371 */
class ns1__CommandParamCCTIUType;	/* sopa.h:374 */
class ns1__FileConfigVersionType;	/* sopa.h:392 */
class ns1__getVersionListResponse;	/* sopa.h:413 */
class ns1__PatternServiceResponseType;	/* sopa.h:419 */
class ns1__PackageConfigVersionListType;	/* sopa.h:422 */
class ns1__PackageConfigVersionType;	/* sopa.h:425 */
class ns1__FileConfigVersionListType;	/* sopa.h:428 */
class ns1__ResultWS;	/* sopa.h:434 */
class ns1__RecordListType;	/* sopa.h:437 */
class ns1__RecordType;	/* sopa.h:440 */
union _ns1__union_UnsignedRecordType;	/* sopa.h:2226 */
class ns1__UnsignedRecordType;	/* sopa.h:443 */
class ns1__BaseRecordType;	/* sopa.h:449 */
class ns1__stPackageListType;	/* sopa.h:452 */
class ns1__stPackageType;	/* sopa.h:455 */
class ns1__stConfigFileListType;	/* sopa.h:458 */
class ns1__stConfigFileType;	/* sopa.h:461 */
class ns1__stSWFileListType;	/* sopa.h:464 */
class ns1__stSWFileType;	/* sopa.h:467 */
class ns1__ConfigVersionTypeList;	/* sopa.h:470 */
class ns1__ConfigVersionType;	/* sopa.h:473 */
class ns1__LocationType;	/* sopa.h:476 */
class ns1__EquipmentLocation;	/* sopa.h:482 */
class ns1__OperationalLocationBase;	/* sopa.h:491 */
class ns1__Schedule;	/* sopa.h:497 */
class ns1__LocationStationType;	/* sopa.h:500 */
class ns1__LocationBoardType;	/* sopa.h:503 */
class ns1__OperationInfoType;	/* sopa.h:506 */
class ns1__shiftType;	/* sopa.h:512 */
class ns1__TitleCodeType;	/* sopa.h:518 */
class ns1__FareType;	/* sopa.h:521 */
class ns1__FareInfo;	/* sopa.h:524 */
class ns1__FareProduct;	/* sopa.h:527 */
class ns1__FareMedia;	/* sopa.h:530 */
class ns1__ValidationOpType;	/* sopa.h:533 */
class ns1__ValidationInfo;	/* sopa.h:536 */
class ns1__cardIdentificationType;	/* sopa.h:539 */
class ns1__CardDataInfoType;	/* sopa.h:542 */
class ns1__CardDataMagType;	/* sopa.h:545 */
class ns1__cardDataMagHeader;	/* sopa.h:548 */
class ns1__cardDataMagBody;	/* sopa.h:551 */
class ns1__valOpMagType;	/* sopa.h:554 */
class ns1__InvoiceReceiptType;	/* sopa.h:560 */
class ns1__ReceiptLine;	/* sopa.h:563 */
class ns1__AccountingOpType;	/* sopa.h:572 */
class ns1__AccountingOperationInfo;	/* sopa.h:575 */
class ns1__AccountingUnitListType;	/* sopa.h:578 */
class _ns1__AccountingUnitType_doc;	/* sopa.h:3126 */
class _ns1__AccountingUnitType_mda;	/* sopa.h:3149 */
class _ns1__AccountingUnitType_purse;	/* sopa.h:3174 */
class ns1__AccountingUnitType;	/* sopa.h:581 */
class ns1__taxAppliedList;	/* sopa.h:584 */
class ns1__taxAppliedType;	/* sopa.h:587 */
class ns1__AccountingUnit;	/* sopa.h:590 */
class ns1__IdentificationDocument;	/* sopa.h:593 */
class ns1__AccountingUnitInfo;	/* sopa.h:596 */
class ns1__AccountingFailureListType;	/* sopa.h:599 */
class ns1__AccountingFailureType;	/* sopa.h:602 */
class ns1__AccountingFailureInfo;	/* sopa.h:605 */
class ns1__PaymentModeListType;	/* sopa.h:608 */
class ns1__PaymentModeType;	/* sopa.h:611 */
class ns1__AwardListType;	/* sopa.h:614 */
class ns1__AwardType;	/* sopa.h:617 */
class ns1__CoinNoteInsertedListType;	/* sopa.h:620 */
class ns1__MoneyInsertedFlow;	/* sopa.h:623 */
class ns1__CoinNoteReturnedListType;	/* sopa.h:626 */
class ns1__MoneyReturnedFlow;	/* sopa.h:629 */
class ns1__AccountingReceiptType;	/* sopa.h:632 */
class ns1__dataReportListType;	/* sopa.h:644 */
class ns1__dataReportType;	/* sopa.h:647 */
class ns1__SlaveDataReportListType;	/* sopa.h:650 */
class ns1__SlaveDataReportType;	/* sopa.h:653 */
class ns1__missingDataListType;	/* sopa.h:659 */
class ns1__missingDataType;	/* sopa.h:662 */
class ns1__MediaOperationListType;	/* sopa.h:671 */
class ns1__MediaOperationType;	/* sopa.h:674 */
class ns1__OperationListType;	/* sopa.h:677 */
class ns1__OperationType;	/* sopa.h:680 */
class ns1__SamType;	/* sopa.h:716 */
class ns1__monetaryUnitListType;	/* sopa.h:725 */
class ns1__monetaryUnit;	/* sopa.h:728 */
class ns1__MediaStockListType;	/* sopa.h:746 */
class ns1__mediaStockType;	/* sopa.h:749 */
class ns1__Penalty;	/* sopa.h:767 */
class ns1__FareMediumType;	/* sopa.h:770 */
class ns1__PendingPaymentType;	/* sopa.h:773 */
class ns1__PendingPaymentBalanceType;	/* sopa.h:776 */
class ns1__PenaltyType;	/* sopa.h:782 */
class ns1__ActionListType;	/* sopa.h:800 */
class ns1__ActionType;	/* sopa.h:803 */
class ns1__ParkingValidationInfo;	/* sopa.h:842 */
class ns1__Vehicle;	/* sopa.h:845 */
class ns1__SignedRecordType;	/* sopa.h:851 */
class ns1__TransactionMTCRegTypeList;	/* sopa.h:857 */
class ns1__TransactionMTCRegType;	/* sopa.h:860 */
union _ns1__union_MTC_USCOREUnsignedTransactionRegType;	/* sopa.h:4281 */
class ns1__MTC_USCOREUnsignedTransactionRegType;	/* sopa.h:863 */
class ns1__MTC_USCOREBaseTransactionType;	/* sopa.h:869 */
class ns1__MTC_USCORELocationType;	/* sopa.h:872 */
class ns1__MTC_USCORENetworkLocationType;	/* sopa.h:875 */
class ns1__MTC_USCOREOnStationAccessPointType;	/* sopa.h:878 */
class ns1__MTC_USCOREOnBoardAccessPointType;	/* sopa.h:881 */
class ns1__MTC_USCOREOnStationSellPointType;	/* sopa.h:884 */
class ns1__MTC_USCOREOnBoardSellPointType;	/* sopa.h:887 */
class ns1__MTC_USCOREOtherPoint;	/* sopa.h:890 */
class ns1__MTC_USCOREConfigVersionTypeList;	/* sopa.h:893 */
class ns1__MTC_USCOREConfigVersionType;	/* sopa.h:896 */
class ns1__MTC_USCOREEquipmentInfoType;	/* sopa.h:899 */
class ns1__MTC_USCORELogValueType;	/* sopa.h:902 */
class ns1__MTC_USCOREApplicationInfoType;	/* sopa.h:911 */
class ns1__MTC_USCORERangeDateType;	/* sopa.h:914 */
class ns1__ActionIdType;	/* sopa.h:917 */
class ns1__MTC_USCOREProfileInfoType;	/* sopa.h:926 */
class ns1__ProductIdType;	/* sopa.h:938 */
class ns1__MTC_USCORETitleInfoType;	/* sopa.h:941 */
class ns1__MTC_USCORETitleLoadContainerInfoListType;	/* sopa.h:944 */
class ns1__MTC_USCORETitleLoadContainerInfoType;	/* sopa.h:947 */
class ns1__MTC_USCOREQuantityType;	/* sopa.h:950 */
class ns1__MTC_USCORETMobilitatCurveType;	/* sopa.h:959 */
class ns1__SignedTransactionMTCRegType;	/* sopa.h:971 */
class ns1__InfoFERecordMTCType;	/* sopa.h:977 */
class ns1__stateType;	/* sopa.h:983 */
class ns1__DeviceListType;	/* sopa.h:986 */
class ns1__DeviceType;	/* sopa.h:989 */
class ns1__MeasureListType;	/* sopa.h:992 */
class ns1__AlarmListType;	/* sopa.h:998 */
class ns1__AlarmType;	/* sopa.h:1001 */
class ns1__SlaveStateListType;	/* sopa.h:1007 */
class ns1__AlarmCCTIUListType;	/* sopa.h:1013 */
class ns1__AlarmCCTIUType;	/* sopa.h:1016 */
class ns1__StatusCCTIUListType;	/* sopa.h:1022 */
class ns1__StatusCCTIUType;	/* sopa.h:1025 */
class ns1__DiagnosticCCTIUListType;	/* sopa.h:1031 */
class ns1__DiagnosticCCTIUType;	/* sopa.h:1034 */
class ns1__VersionsCCTIUType;	/* sopa.h:1040 */
class ns1__VersionFW_USCOREHWListType;	/* sopa.h:1043 */
class ns1__VersionFW_USCOREHWType;	/* sopa.h:1046 */
class ns1__VersionCfgListType;	/* sopa.h:1049 */
class ns1__VersionCfgType;	/* sopa.h:1052 */
class ns1__VersionElementCfgListType;	/* sopa.h:1055 */
class ns1__VersionElementCfgType;	/* sopa.h:1058 */
class ns1__InfoFEMonitorCCTIUType;	/* sopa.h:1073 */
class ns1__SlavePresentationResponseListType;	/* sopa.h:1097 */
class ns1__SlavePresentationResponseType;	/* sopa.h:1100 */
class ns1__MonitoringTypeId;	/* sopa.h:1103 */
class ns1__confPackageListType;	/* sopa.h:1112 */
class ns1__packageType;	/* sopa.h:1115 */
class ns1__configFileListType;	/* sopa.h:1118 */
class ns1__configFileType;	/* sopa.h:1121 */
class ns1__MTC_USCORERangeDateTimeType;	/* sopa.h:1130 */
class ns1__ExtStateType;	/* sopa.h:1136 */
class ns1__MediaDispenserListType;	/* sopa.h:1139 */
class ns1__MediaDispenserType;	/* sopa.h:1142 */
class ns1__DispenserStockListType;	/* sopa.h:1145 */
class ns1__DispenserStockType;	/* sopa.h:1148 */
class ns1__ShiftList;	/* sopa.h:1151 */
class ns1__Shift;	/* sopa.h:1154 */
class ns1__samDeviceTypeList;	/* sopa.h:1157 */
class ns1__samDeviceType;	/* sopa.h:1160 */
class ns1__CashInfoList;	/* sopa.h:1163 */
class ns1__CashInfo;	/* sopa.h:1166 */
class ns1__TransactionMTCConfType;	/* sopa.h:1169 */
class ns1__TransactionMTCConfTypeList;	/* sopa.h:1172 */
class ns1__QuantityType;	/* sopa.h:1175 */
class ns1__TvmExtStateType;	/* sopa.h:1178 */
class ns1__BoxListType;	/* sopa.h:1181 */
class ns1__boxType;	/* sopa.h:1184 */
class ns1__SceqExtStateType;	/* sopa.h:1187 */
class _ns1__eqList_eq;	/* sopa.h:5957 */
class ns1__eqList;	/* sopa.h:1190 */
class ns1__versionListType;	/* sopa.h:1193 */
class ns1__versionType;	/* sopa.h:1196 */
class ns1__diagnosticListType;	/* sopa.h:1199 */
class ns1__diagnosticType;	/* sopa.h:1202 */
class ns1__AgExtStateType;	/* sopa.h:1205 */
class ns1__SceqExtStateTypeList;	/* sopa.h:1208 */
class ns1__PatternServiceConfirmationType;	/* sopa.h:1214 */
class ns1__RecordConfirmationListType;	/* sopa.h:1220 */
class ns1__RecordConfirmationType;	/* sopa.h:1223 */
class ns1__PatternServiceNotificationType;	/* sopa.h:1253 */
class ns1__StateConfigInstallationListType;	/* sopa.h:1283 */
class ns1__stateConfigInstallationType;	/* sopa.h:1286 */
class ns1__SrvRecordNotificationListType;	/* sopa.h:1325 */
class ns1__AccountingProductType;	/* sopa.h:1328 */
union _ns1__union_protocol;	/* sopa.h:6459 */
class _ns1__protocol;	/* sopa.h:1331 */
class ns2__ConfigurationDocument;	/* sopa.h:1334 */
class ns2__Header;	/* sopa.h:1337 */
class ns2__NameSetList;	/* sopa.h:1340 */
class ns2__NameSet;	/* sopa.h:1343 */
class ns2__DistanceMatrixElement;	/* sopa.h:1346 */
class ns2__DistanceList;	/* sopa.h:1349 */
class ns2__Distance;	/* sopa.h:1352 */
class ns1__SrvConfigurationInfoRequestType;	/* sopa.h:287 */
class ns1__SrvRecordRequestType;	/* sopa.h:299 */
class ns1__SrvMTC_USCORETransactionRequestType;	/* sopa.h:320 */
class ns1__SrvFE_USCOREMTC_USCORETransactionRequestType;	/* sopa.h:332 */
class ns1__SrvStateRequestType;	/* sopa.h:335 */
class ns1__SrvMTC_USCOREAlarmRequestType;	/* sopa.h:338 */
class ns1__SrvMTC_USCOREStatusRequestType;	/* sopa.h:341 */
class ns1__SrvMTC_USCOREDiagnosticRequestType;	/* sopa.h:344 */
class ns1__SrvMTC_USCOREVersionRequestType;	/* sopa.h:347 */
class ns1__SrvMTC_USCOREConfigElementRequestType;	/* sopa.h:350 */
class ns1__SrvMTC_USCOREConfigElementChangeRequestType;	/* sopa.h:353 */
class ns1__SrvMTC_USCORECommandExecRequestType;	/* sopa.h:365 */
class ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType;	/* sopa.h:377 */
class ns1__SrvFE_USCOREMTC_USCOREStatusRequestType;	/* sopa.h:380 */
class ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType;	/* sopa.h:383 */
class ns1__SrvFE_USCOREMTC_USCOREVersionRequestType;	/* sopa.h:386 */
class ns1__SrvConfigurationContentRequestType;	/* sopa.h:389 */
class ns1__srvPresentationBaseRequestType;	/* sopa.h:395 */
class ns1__srvConfigurationBaseRequestType;	/* sopa.h:401 */
class ns1__srvCommandBaseRequestType;	/* sopa.h:407 */
class ns1__SrvConfigurationInfoResponseType;	/* sopa.h:416 */
class ns1__SrvRecordResponseType;	/* sopa.h:431 */
class ns1__StartUpRecordType;	/* sopa.h:446 */
class ns1__FixedLocation;	/* sopa.h:479 */
class ns1__OnboardLocation;	/* sopa.h:485 */
class ns1__OperationalLocation;	/* sopa.h:488 */
class ns1__AVLocation;	/* sopa.h:494 */
class ns1__ValidationRecordType;	/* sopa.h:509 */
class ns1__FareProductType;	/* sopa.h:515 */
class ns1__PrintedInvoiceRecordType;	/* sopa.h:557 */
class ns1__ReceiptItem;	/* sopa.h:566 */
class ns1__AccountingOperationRecordType;	/* sopa.h:569 */
class ns1__IdentificationRecordType;	/* sopa.h:635 */
class ns1__StartOfSessionRecordType;	/* sopa.h:638 */
class ns1__EndOfSessionRecordType;	/* sopa.h:641 */
class ns1__OpEndOfSessionRecordType;	/* sopa.h:656 */
class ns1__BeginShiftRecordType;	/* sopa.h:665 */
class ns1__EndShiftRecordType;	/* sopa.h:668 */
class ns1__LockShiftRecordType;	/* sopa.h:683 */
class ns1__UnlockShiftRecordType;	/* sopa.h:686 */
class ns1__InternalFailureRecordType;	/* sopa.h:689 */
class ns1__InspectionRecordType;	/* sopa.h:692 */
class ns1__MediaUpdateStatusRecordType;	/* sopa.h:695 */
class ns1__CscPersonalizationRecordType;	/* sopa.h:698 */
class ns1__CscKeyUpdateRecordType;	/* sopa.h:701 */
class ns1__CscDeliveryRecordType;	/* sopa.h:704 */
class ns1__CscRefundRecordType;	/* sopa.h:707 */
class ns1__CscReplacementRecordType;	/* sopa.h:710 */
class ns1__IssueOperationRecordType;	/* sopa.h:713 */
class ns1__TicketExchangeRecordType;	/* sopa.h:719 */
class ns1__CashCountingAdjustRecordType;	/* sopa.h:722 */
class ns1__CashCountingRecordType;	/* sopa.h:731 */
class ns1__CashMaintenanceRecordType;	/* sopa.h:734 */
class ns1__CollectionRecordType;	/* sopa.h:737 */
class ns1__CoinsAndNotesCollectionRecordType;	/* sopa.h:740 */
class ns1__MediaStockUpdateRecordType;	/* sopa.h:743 */
class ns1__MediaStockAdjustRecordType;	/* sopa.h:752 */
class ns1__CoinNoteRefillRecordType;	/* sopa.h:755 */
class ns1__CoinNoteRefillAdjustmentRecordType;	/* sopa.h:758 */
class ns1__InternalCoinFlowRecordType;	/* sopa.h:761 */
class ns1__PenaltyRecordType;	/* sopa.h:764 */
class ns1__GateRejectionAnalysisRecordType;	/* sopa.h:779 */
class ns1__MaintenanceOperationRecordType;	/* sopa.h:785 */
class ns1__AdvancedPurchaseRecordType;	/* sopa.h:788 */
class ns1__OpenGatePsmRecordType;	/* sopa.h:791 */
class ns1__OpenWideAisleGateRecordType;	/* sopa.h:794 */
class ns1__ActionListRecordType;	/* sopa.h:797 */
class ns1__CommandReportRecordType;	/* sopa.h:806 */
class ns1__CsmBlockingRecordType;	/* sopa.h:809 */
class ns1__CsmUnblockingRecordType;	/* sopa.h:812 */
class ns1__CsmInitializationRecordType;	/* sopa.h:815 */
class ns1__LocationChangeRecordType;	/* sopa.h:818 */
class ns1__LoginFailureRecordType;	/* sopa.h:821 */
class ns1__MaintenanceAccessRecordType;	/* sopa.h:824 */
class ns1__StationModeChangeRecordType;	/* sopa.h:827 */
class ns1__StartTripRecordType;	/* sopa.h:830 */
class ns1__EndTripRecordType;	/* sopa.h:833 */
class ns1__IncidenceRecordType;	/* sopa.h:836 */
class ns1__ParkingValidationRecord;	/* sopa.h:839 */
class ns1__SamQuotaUpdateRecordType;	/* sopa.h:848 */
class ns1__SrvMTC_USCORETransactionResponseType;	/* sopa.h:854 */
class ns1__MTC_USCOREFabricationSusContentType;	/* sopa.h:866 */
class ns1__MTC_USCOREInitializationSusContentType;	/* sopa.h:905 */
class ns1__MTC_USCOREInstanceAppContentType;	/* sopa.h:908 */
class ns1__MTC_USCOREEditAppContentType;	/* sopa.h:920 */
class ns1__MTC_USCOREInstanceProfileContentType;	/* sopa.h:923 */
class ns1__MTC_USCOREEditProfileContentType;	/* sopa.h:929 */
class ns1__MTC_USCOREDeleteProfileContentType;	/* sopa.h:932 */
class ns1__MTC_USCOREInstanceTitleContentType;	/* sopa.h:935 */
class ns1__MTC_USCORERechargeTitleContentType;	/* sopa.h:953 */
class ns1__MTC_USCOREValidationTitleContentType;	/* sopa.h:956 */
class ns1__MTC_USCOREEditTitleContentType;	/* sopa.h:962 */
class ns1__MTC_USCORERestitutionTitleContentType;	/* sopa.h:965 */
class ns1__MTC_USCOREActionExecutedContentType;	/* sopa.h:968 */
class ns1__SrvFE_USCOREMTC_USCORETransactionResponseType;	/* sopa.h:974 */
class ns1__SrvStateResponseType;	/* sopa.h:980 */
class ns1__MeasureType;	/* sopa.h:995 */
class ns1__SlaveStateType;	/* sopa.h:1004 */
class ns1__SrvMTC_USCOREAlarmResponseType;	/* sopa.h:1010 */
class ns1__SrvMTC_USCOREStatusResponseType;	/* sopa.h:1019 */
class ns1__SrvMTC_USCOREDiagnosticResponseType;	/* sopa.h:1028 */
class ns1__SrvMTC_USCOREVersionResponseType;	/* sopa.h:1037 */
class ns1__SrvMTC_USCOREConfigElementResponseType;	/* sopa.h:1061 */
class ns1__SrvMTC_USCOREConfigElementChangeResponseType;	/* sopa.h:1064 */
class ns1__SrvMTC_USCORECommandExecResponseType;	/* sopa.h:1067 */
class ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType;	/* sopa.h:1070 */
class ns1__SrvFE_USCOREMTC_USCOREStatusResponseType;	/* sopa.h:1076 */
class ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType;	/* sopa.h:1079 */
class ns1__SrvFE_USCOREMTC_USCOREVersionResponseType;	/* sopa.h:1082 */
class ns1__SrvConfigurationContentResponseType;	/* sopa.h:1085 */
class ns1__versionList;	/* sopa.h:1088 */
class ns1__srvPresentationBaseResponseType;	/* sopa.h:1091 */
class ns1__srvConfigurationBaseResponseType;	/* sopa.h:1106 */
class ns1__srvCommandBaseResponseType;	/* sopa.h:1124 */
class ns1__MtvmExtStateType;	/* sopa.h:1133 */
class ns1__SrvMTC_USCORETransactionConfirmationType;	/* sopa.h:1211 */
class ns1__SrvRecordConfirmationType;	/* sopa.h:1217 */
class ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType;	/* sopa.h:1226 */
class ns1__SrvStateConfirmationType;	/* sopa.h:1229 */
class ns1__SrvAlarmConfirmationType;	/* sopa.h:1232 */
class ns1__SrvNewConfigurationConfirmationType;	/* sopa.h:1235 */
class ns1__SrvFileConfirmationType;	/* sopa.h:1238 */
class ns1__SrvOrderConfirmationType;	/* sopa.h:1241 */
class ns1__SrvTvmExtendedStateConfirmationType;	/* sopa.h:1244 */
class ns1__SrvMtvmExtendedStateConfirmationType;	/* sopa.h:1247 */
class ns1__SrvAgExtendedStateNotificationType;	/* sopa.h:1250 */
class ns1__SrvRecordNotificationType;	/* sopa.h:1256 */
class ns1__SrvMTC_USCORETransactionNotificationType;	/* sopa.h:1259 */
class ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType;	/* sopa.h:1262 */
class ns1__SrvStateNotificationType;	/* sopa.h:1265 */
class ns1__SrvAlarmNotificationType;	/* sopa.h:1268 */
class ns1__SrvConfigurationNotificationType;	/* sopa.h:1271 */
class ns1__SrvDiagnosticNotificationType;	/* sopa.h:1274 */
class ns1__SrvVersionNotificationType;	/* sopa.h:1277 */
class ns1__SrvStateConfigInstallationNotificationType;	/* sopa.h:1280 */
class ns1__SrvStateSceqnNotificationType;	/* sopa.h:1289 */
class ns1__SrvTvmExtendedStateNotificationType;	/* sopa.h:1292 */
class ns1__SrvExtendedStateNotificationType;	/* sopa.h:1295 */
class ns1__SrvMtvmExtendedStateNotificationType;	/* sopa.h:1298 */
class ns1__SrvMTC_USCOREAlarmNotificationType;	/* sopa.h:1301 */
class ns1__SrvMTC_USCOREStatusNotificationType;	/* sopa.h:1304 */
class ns1__SrvMTC_USCORECommandExecNotifyType;	/* sopa.h:1307 */
class ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType;	/* sopa.h:1310 */
class ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType;	/* sopa.h:1313 */
class ns1__SrvNewConfigurationNotificationType;	/* sopa.h:1316 */
class ns1__SrvFileNotificationType;	/* sopa.h:1319 */
class ns1__SrvOrderNotificationType;	/* sopa.h:1322 */
class ns1__srvPresentationV1RequestType;	/* sopa.h:398 */
class ns1__srvConfigurationV1RequestType;	/* sopa.h:404 */
class ns1__srvCommandV1RequestType;	/* sopa.h:410 */
class ns1__srvPresentationV1ResponseType;	/* sopa.h:1094 */
class ns1__srvConfigurationV1ResponseType;	/* sopa.h:1109 */
class ns1__srvCommandV1ResponseType;	/* sopa.h:1127 */
struct __ns1__getProtoVersionList;	/* sopa.h:12597 */
struct __ns1__getVersionList;	/* sopa.h:12664 */

/* sopa.h:133 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:136 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:143 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (13)
/* hexBinary XSD type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary); }
      public:
        /// Constructor with initializations
        xsd__hexBinary() : __ptr(), __size() { }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:147 */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (14)
/* Type xsd__base64Binary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__base64Binary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary_, default initialized and not managed by a soap context
        virtual xsd__base64Binary_ *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary_); }
      public:
        /// Constructor with initializations
        xsd__base64Binary_() : __item() { }
        virtual ~xsd__base64Binary_() { }
        /// Friend allocator used by soap_new_xsd__base64Binary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary_ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:154 */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (15)
/* Type xsd__boolean is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__boolean; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean, default initialized and not managed by a soap context
        virtual xsd__boolean *soap_alloc(void) const { return SOAP_NEW(xsd__boolean); }
      public:
        /// Constructor with initializations
        xsd__boolean() : __item() { }
        virtual ~xsd__boolean() { }
        /// Friend allocator used by soap_new_xsd__boolean(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean * SOAP_FMAC2 soap_instantiate_xsd__boolean(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:164 */
#ifndef SOAP_TYPE_xsd__date_
#define SOAP_TYPE_xsd__date_ (18)
/* Type xsd__date_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:date': */
class SOAP_CMAC xsd__date_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:date' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__date_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__date_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__date_, default initialized and not managed by a soap context
        virtual xsd__date_ *soap_alloc(void) const { return SOAP_NEW(xsd__date_); }
      public:
        /// Constructor with initializations
        xsd__date_() : __item() { }
        virtual ~xsd__date_() { }
        /// Friend allocator used by soap_new_xsd__date_(struct soap*, int)
        friend SOAP_FMAC1 xsd__date_ * SOAP_FMAC2 soap_instantiate_xsd__date_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:171 */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (19)
/* Type xsd__dateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__dateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime, default initialized and not managed by a soap context
        virtual xsd__dateTime *soap_alloc(void) const { return SOAP_NEW(xsd__dateTime); }
      public:
        /// Constructor with initializations
        xsd__dateTime() : __item() { }
        virtual ~xsd__dateTime() { }
        /// Friend allocator used by soap_new_xsd__dateTime(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime * SOAP_FMAC2 soap_instantiate_xsd__dateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:178 */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (21)
/* Type xsd__double is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:double': */
class SOAP_CMAC xsd__double : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__double; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double, default initialized and not managed by a soap context
        virtual xsd__double *soap_alloc(void) const { return SOAP_NEW(xsd__double); }
      public:
        /// Constructor with initializations
        xsd__double() : __item() { }
        virtual ~xsd__double() { }
        /// Friend allocator used by soap_new_xsd__double(struct soap*, int)
        friend SOAP_FMAC1 xsd__double * SOAP_FMAC2 soap_instantiate_xsd__double(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:185 */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (23)
/* Type xsd__float is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:float': */
class SOAP_CMAC xsd__float : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__float; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float, default initialized and not managed by a soap context
        virtual xsd__float *soap_alloc(void) const { return SOAP_NEW(xsd__float); }
      public:
        /// Constructor with initializations
        xsd__float() : __item() { }
        virtual ~xsd__float() { }
        /// Friend allocator used by soap_new_xsd__float(struct soap*, int)
        friend SOAP_FMAC1 xsd__float * SOAP_FMAC2 soap_instantiate_xsd__float(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:192 */
#ifndef SOAP_TYPE_xsd__hexBinary_
#define SOAP_TYPE_xsd__hexBinary_ (25)
/* Type xsd__hexBinary_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:hexBinary': */
class SOAP_CMAC xsd__hexBinary_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:hexBinary' wrapped by this struct
        xsd__hexBinary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__hexBinary_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary_, default initialized and not managed by a soap context
        virtual xsd__hexBinary_ *soap_alloc(void) const { return SOAP_NEW(xsd__hexBinary_); }
      public:
        /// Constructor with initializations
        xsd__hexBinary_() : __item() { }
        virtual ~xsd__hexBinary_() { }
        /// Friend allocator used by soap_new_xsd__hexBinary_(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary_ * SOAP_FMAC2 soap_instantiate_xsd__hexBinary_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:199 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (26)
/* Type xsd__int is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:int': */
class SOAP_CMAC xsd__int : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__int; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int, default initialized and not managed by a soap context
        virtual xsd__int *soap_alloc(void) const { return SOAP_NEW(xsd__int); }
      public:
        /// Constructor with initializations
        xsd__int() : __item() { }
        virtual ~xsd__int() { }
        /// Friend allocator used by soap_new_xsd__int(struct soap*, int)
        friend SOAP_FMAC1 xsd__int * SOAP_FMAC2 soap_instantiate_xsd__int(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:209 */
#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (28)
/* Type xsd__integer_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:integer': */
class SOAP_CMAC xsd__integer_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:integer' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__integer_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__integer_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__integer_, default initialized and not managed by a soap context
        virtual xsd__integer_ *soap_alloc(void) const { return SOAP_NEW(xsd__integer_); }
      public:
        /// Constructor with initializations
        xsd__integer_() : __item() { }
        virtual ~xsd__integer_() { }
        /// Friend allocator used by soap_new_xsd__integer_(struct soap*, int)
        friend SOAP_FMAC1 xsd__integer_ * SOAP_FMAC2 soap_instantiate_xsd__integer_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:219 */
#ifndef SOAP_TYPE_xsd__language_
#define SOAP_TYPE_xsd__language_ (30)
/* Type xsd__language_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:language': */
class SOAP_CMAC xsd__language_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:language' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__language_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__language_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__language_, default initialized and not managed by a soap context
        virtual xsd__language_ *soap_alloc(void) const { return SOAP_NEW(xsd__language_); }
      public:
        /// Constructor with initializations
        xsd__language_() : __item() { }
        virtual ~xsd__language_() { }
        /// Friend allocator used by soap_new_xsd__language_(struct soap*, int)
        friend SOAP_FMAC1 xsd__language_ * SOAP_FMAC2 soap_instantiate_xsd__language_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:226 */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (31)
/* Type xsd__long is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:long': */
class SOAP_CMAC xsd__long : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__long; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long, default initialized and not managed by a soap context
        virtual xsd__long *soap_alloc(void) const { return SOAP_NEW(xsd__long); }
      public:
        /// Constructor with initializations
        xsd__long() : __item() { }
        virtual ~xsd__long() { }
        /// Friend allocator used by soap_new_xsd__long(struct soap*, int)
        friend SOAP_FMAC1 xsd__long * SOAP_FMAC2 soap_instantiate_xsd__long(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:236 */
#ifndef SOAP_TYPE_xsd__positiveInteger_
#define SOAP_TYPE_xsd__positiveInteger_ (34)
/* Type xsd__positiveInteger_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:positiveInteger': */
class SOAP_CMAC xsd__positiveInteger_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:positiveInteger' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__positiveInteger_
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__positiveInteger_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__positiveInteger_, default initialized and not managed by a soap context
        virtual xsd__positiveInteger_ *soap_alloc(void) const { return SOAP_NEW(xsd__positiveInteger_); }
      public:
        /// Constructor with initializations
        xsd__positiveInteger_() : __item() { }
        virtual ~xsd__positiveInteger_() { }
        /// Friend allocator used by soap_new_xsd__positiveInteger_(struct soap*, int)
        friend SOAP_FMAC1 xsd__positiveInteger_ * SOAP_FMAC2 soap_instantiate_xsd__positiveInteger_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:243 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (35)
/* Type xsd__string is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:string': */
class SOAP_CMAC xsd__string : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__string; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string, default initialized and not managed by a soap context
        virtual xsd__string *soap_alloc(void) const { return SOAP_NEW(xsd__string); }
      public:
        /// Constructor with initializations
        xsd__string() : __item() { }
        virtual ~xsd__string() { }
        /// Friend allocator used by soap_new_xsd__string(struct soap*, int)
        friend SOAP_FMAC1 xsd__string * SOAP_FMAC2 soap_instantiate_xsd__string(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:250 */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (36)
/* Type xsd__unsignedInt is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt, default initialized and not managed by a soap context
        virtual xsd__unsignedInt *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedInt); }
      public:
        /// Constructor with initializations
        xsd__unsignedInt() : __item() { }
        virtual ~xsd__unsignedInt() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:257 */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (37)
/* Type xsd__unsignedLong is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong, default initialized and not managed by a soap context
        virtual xsd__unsignedLong *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedLong); }
      public:
        /// Constructor with initializations
        xsd__unsignedLong() : __item() { }
        virtual ~xsd__unsignedLong() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:264 */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (39)
/* Type xsd__unsignedShort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort
        virtual int soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort, default initialized and not managed by a soap context
        virtual xsd__unsignedShort *soap_alloc(void) const { return SOAP_NEW(xsd__unsignedShort); }
      public:
        /// Constructor with initializations
        xsd__unsignedShort() : __item() { }
        virtual ~xsd__unsignedShort() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1381 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType_
#define SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType_ (402)
/* Type ns1__MTC_USCOREQuantityUnitsType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:MTC_QuantityUnitsType': */
class SOAP_CMAC ns1__MTC_USCOREQuantityUnitsType_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns1:MTC_QuantityUnitsType' wrapped by this struct
        enum ns1__MTC_USCOREQuantityUnitsType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType_
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREQuantityUnitsType_, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREQuantityUnitsType_ *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREQuantityUnitsType_); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREQuantityUnitsType_() : __item() { }
        virtual ~ns1__MTC_USCOREQuantityUnitsType_() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREQuantityUnitsType_(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREQuantityUnitsType_ * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREQuantityUnitsType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1397 */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUValueType_
#define SOAP_TYPE_ns1__AlarmCCTIUValueType_ (404)
/* Type ns1__AlarmCCTIUValueType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:AlarmCCTIUValueType': */
class SOAP_CMAC ns1__AlarmCCTIUValueType_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns1:AlarmCCTIUValueType' wrapped by this struct
        enum ns1__AlarmCCTIUValueType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AlarmCCTIUValueType_
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AlarmCCTIUValueType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AlarmCCTIUValueType_, default initialized and not managed by a soap context
        virtual ns1__AlarmCCTIUValueType_ *soap_alloc(void) const { return SOAP_NEW(ns1__AlarmCCTIUValueType_); }
      public:
        /// Constructor with initializations
        ns1__AlarmCCTIUValueType_() : __item() { }
        virtual ~ns1__AlarmCCTIUValueType_() { }
        /// Friend allocator used by soap_new_ns1__AlarmCCTIUValueType_(struct soap*, int)
        friend SOAP_FMAC1 ns1__AlarmCCTIUValueType_ * SOAP_FMAC2 soap_instantiate_ns1__AlarmCCTIUValueType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1413 */
#ifndef SOAP_TYPE_ns1__QuantityUnitsType_
#define SOAP_TYPE_ns1__QuantityUnitsType_ (406)
/* Type ns1__QuantityUnitsType_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:QuantityUnitsType': */
class SOAP_CMAC ns1__QuantityUnitsType_ : public xsd__anyType {
      public:
        /// Simple content of XSD type 'ns1:QuantityUnitsType' wrapped by this struct
        enum ns1__QuantityUnitsType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QuantityUnitsType_
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__QuantityUnitsType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QuantityUnitsType_, default initialized and not managed by a soap context
        virtual ns1__QuantityUnitsType_ *soap_alloc(void) const { return SOAP_NEW(ns1__QuantityUnitsType_); }
      public:
        /// Constructor with initializations
        ns1__QuantityUnitsType_() : __item() { }
        virtual ~ns1__QuantityUnitsType_() { }
        /// Friend allocator used by soap_new_ns1__QuantityUnitsType_(struct soap*, int)
        friend SOAP_FMAC1 ns1__QuantityUnitsType_ * SOAP_FMAC2 soap_instantiate_ns1__QuantityUnitsType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:278 */
#ifndef SOAP_TYPE_ns1__getProtoVersionList
#define SOAP_TYPE_ns1__getProtoVersionList (42)
/* Type ns1__getProtoVersionList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getProtoVersionList': */
class SOAP_CMAC ns1__getProtoVersionList : public xsd__anyType {
      public:
        /// Required element 'request' of XSD type 'xsd:base64Binary'
        xsd__base64Binary request;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getProtoVersionList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getProtoVersionList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getProtoVersionList, default initialized and not managed by a soap context
        virtual ns1__getProtoVersionList *soap_alloc(void) const { return SOAP_NEW(ns1__getProtoVersionList); }
      public:
        /// Constructor with initializations
        ns1__getProtoVersionList() : request() { }
        virtual ~ns1__getProtoVersionList() { }
        /// Friend allocator used by soap_new_ns1__getProtoVersionList(struct soap*, int)
        friend SOAP_FMAC1 ns1__getProtoVersionList * SOAP_FMAC2 soap_instantiate_ns1__getProtoVersionList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:281 */
#ifndef SOAP_TYPE_ns1__getProtoVersionListResponse
#define SOAP_TYPE_ns1__getProtoVersionListResponse (43)
/* Type ns1__getProtoVersionListResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getProtoVersionListResponse': */
class SOAP_CMAC ns1__getProtoVersionListResponse : public xsd__anyType {
      public:
        /// Optional element 'applicationsResult' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *applicationsResult;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getProtoVersionListResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getProtoVersionListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getProtoVersionListResponse, default initialized and not managed by a soap context
        virtual ns1__getProtoVersionListResponse *soap_alloc(void) const { return SOAP_NEW(ns1__getProtoVersionListResponse); }
      public:
        /// Constructor with initializations
        ns1__getProtoVersionListResponse() : applicationsResult() { }
        virtual ~ns1__getProtoVersionListResponse() { }
        /// Friend allocator used by soap_new_ns1__getProtoVersionListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getProtoVersionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getProtoVersionListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:284 */
#ifndef SOAP_TYPE_ns1__getVersionList
#define SOAP_TYPE_ns1__getVersionList (44)
/* Type ns1__getVersionList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getVersionList': */
class SOAP_CMAC ns1__getVersionList : public xsd__anyType {
      public:
        /// Required element 'request' of XSD type 'ns1:SrvConfigurationInfoRequestType'
        ns1__SrvConfigurationInfoRequestType *request;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getVersionList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getVersionList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getVersionList, default initialized and not managed by a soap context
        virtual ns1__getVersionList *soap_alloc(void) const { return SOAP_NEW(ns1__getVersionList); }
      public:
        /// Constructor with initializations
        ns1__getVersionList() : request() { }
        virtual ~ns1__getVersionList() { }
        /// Friend allocator used by soap_new_ns1__getVersionList(struct soap*, int)
        friend SOAP_FMAC1 ns1__getVersionList * SOAP_FMAC2 soap_instantiate_ns1__getVersionList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:290 */
#ifndef SOAP_TYPE_ns1__PatternServiceRequestType
#define SOAP_TYPE_ns1__PatternServiceRequestType (46)
/* Type ns1__PatternServiceRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PatternServiceRequestType': */
class SOAP_CMAC ns1__PatternServiceRequestType : public xsd__anyType {
      public:
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// Required element 'requestFrom' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *requestFrom;
        /// Optional element 'requestTo' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *requestTo;
        /// Optional element 'reqSlaveList' of XSD type 'ns1:SlaveEquipmentListType'
        ns1__SlaveEquipmentListType *reqSlaveList;
        /// Required element 'idMessage' of XSD type 'xsd:unsignedInt'
        unsigned int idMessage;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PatternServiceRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PatternServiceRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PatternServiceRequestType, default initialized and not managed by a soap context
        virtual ns1__PatternServiceRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__PatternServiceRequestType); }
      public:
        /// Constructor with initializations
        ns1__PatternServiceRequestType() : dateTime(), requestFrom(), requestTo(), reqSlaveList(), idMessage() { }
        virtual ~ns1__PatternServiceRequestType() { }
        /// Friend allocator used by soap_new_ns1__PatternServiceRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PatternServiceRequestType * SOAP_FMAC2 soap_instantiate_ns1__PatternServiceRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:293 */
#ifndef SOAP_TYPE_ns1__EquipmentReferenceType
#define SOAP_TYPE_ns1__EquipmentReferenceType (47)
/* Type ns1__EquipmentReferenceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:EquipmentReferenceType': */
class SOAP_CMAC ns1__EquipmentReferenceType : public xsd__anyType {
      public:
        /// required attribute 'eId' of XSD type 'xsd:unsignedInt'
        unsigned int eId;
        /// required attribute 'eCchs' of XSD type 'xsd:unsignedInt'
        unsigned int eCchs;
        /// required attribute 'etId' of XSD type 'xsd:unsignedInt'
        unsigned int etId;
        /// required attribute 'emId' of XSD type 'xsd:unsignedInt'
        unsigned int emId;
        /// required attribute 'ag' of XSD type 'xsd:unsignedInt'
        unsigned int ag;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EquipmentReferenceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EquipmentReferenceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EquipmentReferenceType, default initialized and not managed by a soap context
        virtual ns1__EquipmentReferenceType *soap_alloc(void) const { return SOAP_NEW(ns1__EquipmentReferenceType); }
      public:
        /// Constructor with initializations
        ns1__EquipmentReferenceType() : eId(), eCchs(), etId(), emId(), ag() { }
        virtual ~ns1__EquipmentReferenceType() { }
        /// Friend allocator used by soap_new_ns1__EquipmentReferenceType(struct soap*, int)
        friend SOAP_FMAC1 ns1__EquipmentReferenceType * SOAP_FMAC2 soap_instantiate_ns1__EquipmentReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:296 */
#ifndef SOAP_TYPE_ns1__SlaveEquipmentListType
#define SOAP_TYPE_ns1__SlaveEquipmentListType (48)
/* Type ns1__SlaveEquipmentListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlaveEquipmentListType': */
class SOAP_CMAC ns1__SlaveEquipmentListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'slave' of XSD type 'ns1:EquipmentReferenceType' stored in dynamic array slave of length __sizeslave
        int __sizeslave;
        ns1__EquipmentReferenceType **slave;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlaveEquipmentListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlaveEquipmentListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlaveEquipmentListType, default initialized and not managed by a soap context
        virtual ns1__SlaveEquipmentListType *soap_alloc(void) const { return SOAP_NEW(ns1__SlaveEquipmentListType); }
      public:
        /// Constructor with initializations
        ns1__SlaveEquipmentListType() : __sizeslave(), slave(), length() { }
        virtual ~ns1__SlaveEquipmentListType() { }
        /// Friend allocator used by soap_new_ns1__SlaveEquipmentListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlaveEquipmentListType * SOAP_FMAC2 soap_instantiate_ns1__SlaveEquipmentListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:302 */
#ifndef SOAP_TYPE_ns1__RecordRangeIdTypeList
#define SOAP_TYPE_ns1__RecordRangeIdTypeList (50)
/* Type ns1__RecordRangeIdTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RecordRangeIdTypeList': */
class SOAP_CMAC ns1__RecordRangeIdTypeList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'rng' of XSD type 'ns1:RecordRangeIdType' stored in dynamic array rng of length __sizerng
        int __sizerng;
        ns1__RecordRangeIdType **rng;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordRangeIdTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordRangeIdTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordRangeIdTypeList, default initialized and not managed by a soap context
        virtual ns1__RecordRangeIdTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__RecordRangeIdTypeList); }
      public:
        /// Constructor with initializations
        ns1__RecordRangeIdTypeList() : __sizerng(), rng() { }
        virtual ~ns1__RecordRangeIdTypeList() { }
        /// Friend allocator used by soap_new_ns1__RecordRangeIdTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordRangeIdTypeList * SOAP_FMAC2 soap_instantiate_ns1__RecordRangeIdTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:305 */
#ifndef SOAP_TYPE_ns1__RecordRangeIdType
#define SOAP_TYPE_ns1__RecordRangeIdType (51)
/* Type ns1__RecordRangeIdType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RecordRangeIdType': */
class SOAP_CMAC ns1__RecordRangeIdType : public xsd__anyType {
      public:
        /// Required element 's' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *s;
        /// Required element 'e' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *e;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordRangeIdType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordRangeIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordRangeIdType, default initialized and not managed by a soap context
        virtual ns1__RecordRangeIdType *soap_alloc(void) const { return SOAP_NEW(ns1__RecordRangeIdType); }
      public:
        /// Constructor with initializations
        ns1__RecordRangeIdType() : s(), e() { }
        virtual ~ns1__RecordRangeIdType() { }
        /// Friend allocator used by soap_new_ns1__RecordRangeIdType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordRangeIdType * SOAP_FMAC2 soap_instantiate_ns1__RecordRangeIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:308 */
#ifndef SOAP_TYPE_ns1__RecordIdType
#define SOAP_TYPE_ns1__RecordIdType (52)
/* Type ns1__RecordIdType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:RecordIdType': */
class SOAP_CMAC ns1__RecordIdType : public xsd__anyType {
      public:
        /// required attribute 'eId' of XSD type 'xsd:unsignedInt'
        unsigned int eId;
        /// required attribute 'uSeq' of XSD type 'xsd:unsignedInt'
        unsigned int uSeq;
        /// required attribute 'date' of XSD type 'xsd:dateTime'
        time_t date;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordIdType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordIdType, default initialized and not managed by a soap context
        virtual ns1__RecordIdType *soap_alloc(void) const { return SOAP_NEW(ns1__RecordIdType); }
      public:
        /// Constructor with initializations
        ns1__RecordIdType() : eId(), uSeq(), date() { }
        virtual ~ns1__RecordIdType() { }
        /// Friend allocator used by soap_new_ns1__RecordIdType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordIdType * SOAP_FMAC2 soap_instantiate_ns1__RecordIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:311 */
#ifndef SOAP_TYPE_ns1__CustomRecordRequest
#define SOAP_TYPE_ns1__CustomRecordRequest (53)
/* Type ns1__CustomRecordRequest is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CustomRecordRequest': */
class SOAP_CMAC ns1__CustomRecordRequest : public xsd__anyType {
      public:
        /// Required element 'paramList' of XSD type 'ns1:ParameterList'
        ns1__ParameterList *paramList;
        /// required attribute 'recordTypeId' of XSD type 'xsd:unsignedInt'
        unsigned int recordTypeId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CustomRecordRequest
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CustomRecordRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CustomRecordRequest, default initialized and not managed by a soap context
        virtual ns1__CustomRecordRequest *soap_alloc(void) const { return SOAP_NEW(ns1__CustomRecordRequest); }
      public:
        /// Constructor with initializations
        ns1__CustomRecordRequest() : paramList(), recordTypeId() { }
        virtual ~ns1__CustomRecordRequest() { }
        /// Friend allocator used by soap_new_ns1__CustomRecordRequest(struct soap*, int)
        friend SOAP_FMAC1 ns1__CustomRecordRequest * SOAP_FMAC2 soap_instantiate_ns1__CustomRecordRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:314 */
#ifndef SOAP_TYPE_ns1__ParameterList
#define SOAP_TYPE_ns1__ParameterList (54)
/* Type ns1__ParameterList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ParameterList': */
class SOAP_CMAC ns1__ParameterList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'param' of XSD type 'ns1:Parameter' stored in dynamic array param of length __sizeparam
        int __sizeparam;
        ns1__Parameter **param;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ParameterList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ParameterList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ParameterList, default initialized and not managed by a soap context
        virtual ns1__ParameterList *soap_alloc(void) const { return SOAP_NEW(ns1__ParameterList); }
      public:
        /// Constructor with initializations
        ns1__ParameterList() : __sizeparam(), param() { }
        virtual ~ns1__ParameterList() { }
        /// Friend allocator used by soap_new_ns1__ParameterList(struct soap*, int)
        friend SOAP_FMAC1 ns1__ParameterList * SOAP_FMAC2 soap_instantiate_ns1__ParameterList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:317 */
#ifndef SOAP_TYPE_ns1__Parameter
#define SOAP_TYPE_ns1__Parameter (55)
/* Type ns1__Parameter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:Parameter': */
class SOAP_CMAC ns1__Parameter : public xsd__anyType {
      public:
        /// required attribute 'name' of XSD type 'xsd:string'
        char *name;
        /// required attribute 'value' of XSD type 'xsd:string'
        char *value;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Parameter
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Parameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Parameter, default initialized and not managed by a soap context
        virtual ns1__Parameter *soap_alloc(void) const { return SOAP_NEW(ns1__Parameter); }
      public:
        /// Constructor with initializations
        ns1__Parameter() : name(), value() { }
        virtual ~ns1__Parameter() { }
        /// Friend allocator used by soap_new_ns1__Parameter(struct soap*, int)
        friend SOAP_FMAC1 ns1__Parameter * SOAP_FMAC2 soap_instantiate_ns1__Parameter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:323 */
#ifndef SOAP_TYPE_ns1__TransactionMTCIdRangeListType
#define SOAP_TYPE_ns1__TransactionMTCIdRangeListType (57)
/* Type ns1__TransactionMTCIdRangeListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionMTCIdRangeListType': */
class SOAP_CMAC ns1__TransactionMTCIdRangeListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'rng' of XSD type 'ns1:TransactionMTCIdRangeType' stored in dynamic array rng of length __sizerng
        int __sizerng;
        ns1__TransactionMTCIdRangeType **rng;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionMTCIdRangeListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionMTCIdRangeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionMTCIdRangeListType, default initialized and not managed by a soap context
        virtual ns1__TransactionMTCIdRangeListType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionMTCIdRangeListType); }
      public:
        /// Constructor with initializations
        ns1__TransactionMTCIdRangeListType() : __sizerng(), rng() { }
        virtual ~ns1__TransactionMTCIdRangeListType() { }
        /// Friend allocator used by soap_new_ns1__TransactionMTCIdRangeListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionMTCIdRangeListType * SOAP_FMAC2 soap_instantiate_ns1__TransactionMTCIdRangeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:326 */
#ifndef SOAP_TYPE_ns1__TransactionMTCIdRangeType
#define SOAP_TYPE_ns1__TransactionMTCIdRangeType (58)
/* Type ns1__TransactionMTCIdRangeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionMTCIdRangeType': */
class SOAP_CMAC ns1__TransactionMTCIdRangeType : public xsd__anyType {
      public:
        /// Required element 's' of XSD type 'ns1:MTC_TransactionIdType'
        ns1__MTC_USCORETransactionIdType *s;
        /// Required element 'e' of XSD type 'ns1:MTC_TransactionIdType'
        ns1__MTC_USCORETransactionIdType *e;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionMTCIdRangeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionMTCIdRangeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionMTCIdRangeType, default initialized and not managed by a soap context
        virtual ns1__TransactionMTCIdRangeType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionMTCIdRangeType); }
      public:
        /// Constructor with initializations
        ns1__TransactionMTCIdRangeType() : s(), e() { }
        virtual ~ns1__TransactionMTCIdRangeType() { }
        /// Friend allocator used by soap_new_ns1__TransactionMTCIdRangeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionMTCIdRangeType * SOAP_FMAC2 soap_instantiate_ns1__TransactionMTCIdRangeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:329 */
#ifndef SOAP_TYPE_ns1__MTC_USCORETransactionIdType
#define SOAP_TYPE_ns1__MTC_USCORETransactionIdType (59)
/* Type ns1__MTC_USCORETransactionIdType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_TransactionIdType': */
class SOAP_CMAC ns1__MTC_USCORETransactionIdType : public xsd__anyType {
      public:
        /// Required element 'secElemId' of XSD type 'xsd:unsignedInt'
        unsigned int secElemId;
        /// Required element 'sequence' of XSD type 'xsd:unsignedInt'
        unsigned int sequence;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORETransactionIdType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORETransactionIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORETransactionIdType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORETransactionIdType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORETransactionIdType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORETransactionIdType() : secElemId(), sequence() { }
        virtual ~ns1__MTC_USCORETransactionIdType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORETransactionIdType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORETransactionIdType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORETransactionIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:356 */
#ifndef SOAP_TYPE_ns1__ConfigElementCCTIUListType
#define SOAP_TYPE_ns1__ConfigElementCCTIUListType (68)
/* Type ns1__ConfigElementCCTIUListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ConfigElementCCTIUListType': */
class SOAP_CMAC ns1__ConfigElementCCTIUListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:ConfigElementCCTIUType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__ConfigElementCCTIUType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ConfigElementCCTIUListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ConfigElementCCTIUListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ConfigElementCCTIUListType, default initialized and not managed by a soap context
        virtual ns1__ConfigElementCCTIUListType *soap_alloc(void) const { return SOAP_NEW(ns1__ConfigElementCCTIUListType); }
      public:
        /// Constructor with initializations
        ns1__ConfigElementCCTIUListType() : __sizeitems(), items() { }
        virtual ~ns1__ConfigElementCCTIUListType() { }
        /// Friend allocator used by soap_new_ns1__ConfigElementCCTIUListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ConfigElementCCTIUListType * SOAP_FMAC2 soap_instantiate_ns1__ConfigElementCCTIUListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:359 */
#ifndef SOAP_TYPE_ns1__ConfigElementCCTIUType
#define SOAP_TYPE_ns1__ConfigElementCCTIUType (69)
/* Type ns1__ConfigElementCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ConfigElementCCTIUType': */
class SOAP_CMAC ns1__ConfigElementCCTIUType : public xsd__anyType {
      public:
        /// Required element 'value' of XSD type 'ns1:ValueType'
        ns1__ValueType *value;
        /// optional attribute 'item' of XSD type 'xsd:unsignedInt'
        unsigned int *item;
        /// optional attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int *code;
        /// optional attribute 'readOnly' of XSD type 'xsd:boolean'
        bool *readOnly;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ConfigElementCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ConfigElementCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ConfigElementCCTIUType, default initialized and not managed by a soap context
        virtual ns1__ConfigElementCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__ConfigElementCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__ConfigElementCCTIUType() : value(), item(), code(), readOnly() { }
        virtual ~ns1__ConfigElementCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__ConfigElementCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ConfigElementCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__ConfigElementCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:362 */
#ifndef SOAP_TYPE_ns1__ValueType
#define SOAP_TYPE_ns1__ValueType (70)
/* Type ns1__ValueType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ValueType': */
class SOAP_CMAC ns1__ValueType : public xsd__anyType {
      public:
        /// Optional element 'u32' of XSD type 'xsd:unsignedShort'
        unsigned short *u32;
        /// Optional element 's32' of XSD type 'xsd:unsignedShort'
        unsigned short *s32;
        /// Optional element 'u64' of XSD type 'xsd:long'
        LONG64 *u64;
        /// Optional element 's64' of XSD type 'xsd:long'
        LONG64 *s64;
        /// Optional element 'str' of XSD type 'xsd:string'
        char *str;
        /// Optional element 'bol' of XSD type 'xsd:boolean'
        bool *bol;
        /// Optional element 'f32' of XSD type 'xsd:float'
        float *f32;
        /// Optional element 'f64' of XSD type 'xsd:double'
        double *f64;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ValueType, default initialized and not managed by a soap context
        virtual ns1__ValueType *soap_alloc(void) const { return SOAP_NEW(ns1__ValueType); }
      public:
        /// Constructor with initializations
        ns1__ValueType() : u32(), s32(), u64(), s64(), str(), bol(), f32(), f64() { }
        virtual ~ns1__ValueType() { }
        /// Friend allocator used by soap_new_ns1__ValueType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ValueType * SOAP_FMAC2 soap_instantiate_ns1__ValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:368 */
#ifndef SOAP_TYPE_ns1__CommandCCTIUType
#define SOAP_TYPE_ns1__CommandCCTIUType (72)
/* Type ns1__CommandCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CommandCCTIUType': */
class SOAP_CMAC ns1__CommandCCTIUType : public xsd__anyType {
      public:
        /// Required element 'dateTimeExec' of XSD type 'xsd:dateTime'
        time_t dateTimeExec;
        /// Required element 'dateTimeExpired' of XSD type 'xsd:dateTime'
        time_t dateTimeExpired;
        /// Optional element 'paramList' of XSD type 'ns1:CommandParamCCTIUListType'
        ns1__CommandParamCCTIUListType *paramList;
        /// optional attribute 'item' of XSD type 'xsd:unsignedInt'
        unsigned int *item;
        /// optional attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int *code;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CommandCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CommandCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CommandCCTIUType, default initialized and not managed by a soap context
        virtual ns1__CommandCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__CommandCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__CommandCCTIUType() : dateTimeExec(), dateTimeExpired(), paramList(), item(), code() { }
        virtual ~ns1__CommandCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__CommandCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CommandCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__CommandCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:371 */
#ifndef SOAP_TYPE_ns1__CommandParamCCTIUListType
#define SOAP_TYPE_ns1__CommandParamCCTIUListType (73)
/* Type ns1__CommandParamCCTIUListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CommandParamCCTIUListType': */
class SOAP_CMAC ns1__CommandParamCCTIUListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:CommandParamCCTIUType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__CommandParamCCTIUType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CommandParamCCTIUListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CommandParamCCTIUListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CommandParamCCTIUListType, default initialized and not managed by a soap context
        virtual ns1__CommandParamCCTIUListType *soap_alloc(void) const { return SOAP_NEW(ns1__CommandParamCCTIUListType); }
      public:
        /// Constructor with initializations
        ns1__CommandParamCCTIUListType() : __sizeitems(), items() { }
        virtual ~ns1__CommandParamCCTIUListType() { }
        /// Friend allocator used by soap_new_ns1__CommandParamCCTIUListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CommandParamCCTIUListType * SOAP_FMAC2 soap_instantiate_ns1__CommandParamCCTIUListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:374 */
#ifndef SOAP_TYPE_ns1__CommandParamCCTIUType
#define SOAP_TYPE_ns1__CommandParamCCTIUType (74)
/* Type ns1__CommandParamCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CommandParamCCTIUType': */
class SOAP_CMAC ns1__CommandParamCCTIUType : public xsd__anyType {
      public:
        /// Required element 'code' of XSD type 'xsd:unsignedInt'
        unsigned int code;
        /// Required element 'value' of XSD type 'ns1:ValueType'
        ns1__ValueType *value;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CommandParamCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CommandParamCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CommandParamCCTIUType, default initialized and not managed by a soap context
        virtual ns1__CommandParamCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__CommandParamCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__CommandParamCCTIUType() : code(), value() { }
        virtual ~ns1__CommandParamCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__CommandParamCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CommandParamCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__CommandParamCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:392 */
#ifndef SOAP_TYPE_ns1__FileConfigVersionType
#define SOAP_TYPE_ns1__FileConfigVersionType (80)
/* Type ns1__FileConfigVersionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:FileConfigVersionType': */
class SOAP_CMAC ns1__FileConfigVersionType : public xsd__anyType {
      public:
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
        /// optional attribute 'version' of XSD type 'xsd:unsignedInt'
        unsigned int *version;
        /// optional attribute 'incVersion' of XSD type 'xsd:unsignedInt'
        unsigned int *incVersion;
        /// optional attribute 'name' of XSD type 'xsd:string'
        char *name;
        /// optional attribute 'uri' of XSD type 'xsd:string'
        char *uri;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FileConfigVersionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FileConfigVersionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FileConfigVersionType, default initialized and not managed by a soap context
        virtual ns1__FileConfigVersionType *soap_alloc(void) const { return SOAP_NEW(ns1__FileConfigVersionType); }
      public:
        /// Constructor with initializations
        ns1__FileConfigVersionType() : id(), version(), incVersion(), name(), uri() { }
        virtual ~ns1__FileConfigVersionType() { }
        /// Friend allocator used by soap_new_ns1__FileConfigVersionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__FileConfigVersionType * SOAP_FMAC2 soap_instantiate_ns1__FileConfigVersionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:413 */
#ifndef SOAP_TYPE_ns1__getVersionListResponse
#define SOAP_TYPE_ns1__getVersionListResponse (87)
/* Type ns1__getVersionListResponse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:getVersionListResponse': */
class SOAP_CMAC ns1__getVersionListResponse : public xsd__anyType {
      public:
        /// Optional element 'applicationsResult' of XSD type 'ns1:SrvConfigurationInfoResponseType'
        ns1__SrvConfigurationInfoResponseType *applicationsResult;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getVersionListResponse
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__getVersionListResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getVersionListResponse, default initialized and not managed by a soap context
        virtual ns1__getVersionListResponse *soap_alloc(void) const { return SOAP_NEW(ns1__getVersionListResponse); }
      public:
        /// Constructor with initializations
        ns1__getVersionListResponse() : applicationsResult() { }
        virtual ~ns1__getVersionListResponse() { }
        /// Friend allocator used by soap_new_ns1__getVersionListResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getVersionListResponse * SOAP_FMAC2 soap_instantiate_ns1__getVersionListResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:419 */
#ifndef SOAP_TYPE_ns1__PatternServiceResponseType
#define SOAP_TYPE_ns1__PatternServiceResponseType (89)
/* Type ns1__PatternServiceResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PatternServiceResponseType': */
class SOAP_CMAC ns1__PatternServiceResponseType : public xsd__anyType {
      public:
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// Required element 'responseFrom' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *responseFrom;
        /// Optional element 'responseTo' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *responseTo;
        /// Optional element 'respSlaveList' of XSD type 'ns1:SlaveEquipmentListType'
        ns1__SlaveEquipmentListType *respSlaveList;
        /// Required element 'idMessageRequest' of XSD type 'xsd:unsignedInt'
        unsigned int idMessageRequest;
        /// Required element 'admited' of XSD type 'xsd:boolean'
        bool admited;
        /// Optional element 'rejectionCode' of XSD type 'xsd:unsignedInt'
        unsigned int *rejectionCode;
        /// Optional element 'rejectionDesc' of XSD type 'xsd:string'
        char *rejectionDesc;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PatternServiceResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PatternServiceResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PatternServiceResponseType, default initialized and not managed by a soap context
        virtual ns1__PatternServiceResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__PatternServiceResponseType); }
      public:
        /// Constructor with initializations
        ns1__PatternServiceResponseType() : dateTime(), responseFrom(), responseTo(), respSlaveList(), idMessageRequest(), admited(), rejectionCode(), rejectionDesc() { }
        virtual ~ns1__PatternServiceResponseType() { }
        /// Friend allocator used by soap_new_ns1__PatternServiceResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PatternServiceResponseType * SOAP_FMAC2 soap_instantiate_ns1__PatternServiceResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:422 */
#ifndef SOAP_TYPE_ns1__PackageConfigVersionListType
#define SOAP_TYPE_ns1__PackageConfigVersionListType (90)
/* Type ns1__PackageConfigVersionListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PackageConfigVersionListType': */
class SOAP_CMAC ns1__PackageConfigVersionListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'pkg' of XSD type 'ns1:PackageConfigVersionType' stored in dynamic array pkg of length __sizepkg
        int __sizepkg;
        ns1__PackageConfigVersionType **pkg;
        /// required attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PackageConfigVersionListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PackageConfigVersionListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PackageConfigVersionListType, default initialized and not managed by a soap context
        virtual ns1__PackageConfigVersionListType *soap_alloc(void) const { return SOAP_NEW(ns1__PackageConfigVersionListType); }
      public:
        /// Constructor with initializations
        ns1__PackageConfigVersionListType() : __sizepkg(), pkg(), length() { }
        virtual ~ns1__PackageConfigVersionListType() { }
        /// Friend allocator used by soap_new_ns1__PackageConfigVersionListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PackageConfigVersionListType * SOAP_FMAC2 soap_instantiate_ns1__PackageConfigVersionListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:425 */
#ifndef SOAP_TYPE_ns1__PackageConfigVersionType
#define SOAP_TYPE_ns1__PackageConfigVersionType (91)
/* Type ns1__PackageConfigVersionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PackageConfigVersionType': */
class SOAP_CMAC ns1__PackageConfigVersionType : public xsd__anyType {
      public:
        /// Optional element 'fileList' of XSD type 'ns1:FileConfigVersionListType'
        ns1__FileConfigVersionListType *fileList;
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
        /// optional attribute 'agency' of XSD type 'xsd:unsignedInt'
        unsigned int *agency;
        /// optional attribute 'version' of XSD type 'xsd:unsignedInt'
        unsigned int *version;
        /// optional attribute 'incVersion' of XSD type 'xsd:unsignedInt'
        unsigned int *incVersion;
        /// optional attribute 'name' of XSD type 'xsd:string'
        char *name;
        /// optional attribute 'uri' of XSD type 'xsd:string'
        char *uri;
        /// optional attribute 'activation' of XSD type 'xsd:dateTime'
        time_t *activation;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PackageConfigVersionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PackageConfigVersionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PackageConfigVersionType, default initialized and not managed by a soap context
        virtual ns1__PackageConfigVersionType *soap_alloc(void) const { return SOAP_NEW(ns1__PackageConfigVersionType); }
      public:
        /// Constructor with initializations
        ns1__PackageConfigVersionType() : fileList(), id(), agency(), version(), incVersion(), name(), uri(), activation() { }
        virtual ~ns1__PackageConfigVersionType() { }
        /// Friend allocator used by soap_new_ns1__PackageConfigVersionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PackageConfigVersionType * SOAP_FMAC2 soap_instantiate_ns1__PackageConfigVersionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:428 */
#ifndef SOAP_TYPE_ns1__FileConfigVersionListType
#define SOAP_TYPE_ns1__FileConfigVersionListType (92)
/* Type ns1__FileConfigVersionListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FileConfigVersionListType': */
class SOAP_CMAC ns1__FileConfigVersionListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'file' of XSD type 'ns1:FileConfigVersionType' stored in dynamic array file of length __sizefile
        int __sizefile;
        ns1__FileConfigVersionType **file;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FileConfigVersionListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FileConfigVersionListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FileConfigVersionListType, default initialized and not managed by a soap context
        virtual ns1__FileConfigVersionListType *soap_alloc(void) const { return SOAP_NEW(ns1__FileConfigVersionListType); }
      public:
        /// Constructor with initializations
        ns1__FileConfigVersionListType() : __sizefile(), file() { }
        virtual ~ns1__FileConfigVersionListType() { }
        /// Friend allocator used by soap_new_ns1__FileConfigVersionListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__FileConfigVersionListType * SOAP_FMAC2 soap_instantiate_ns1__FileConfigVersionListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:434 */
#ifndef SOAP_TYPE_ns1__ResultWS
#define SOAP_TYPE_ns1__ResultWS (94)
/* Type ns1__ResultWS is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ResultWS': */
class SOAP_CMAC ns1__ResultWS : public xsd__anyType {
      public:
        /// required attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int code;
        /// optional attribute 'desc' of XSD type 'xsd:string'
        char *desc;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ResultWS
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ResultWS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ResultWS, default initialized and not managed by a soap context
        virtual ns1__ResultWS *soap_alloc(void) const { return SOAP_NEW(ns1__ResultWS); }
      public:
        /// Constructor with initializations
        ns1__ResultWS() : code(), desc() { }
        virtual ~ns1__ResultWS() { }
        /// Friend allocator used by soap_new_ns1__ResultWS(struct soap*, int)
        friend SOAP_FMAC1 ns1__ResultWS * SOAP_FMAC2 soap_instantiate_ns1__ResultWS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:437 */
#ifndef SOAP_TYPE_ns1__RecordListType
#define SOAP_TYPE_ns1__RecordListType (95)
/* Type ns1__RecordListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RecordListType': */
class SOAP_CMAC ns1__RecordListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:RecordType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__RecordType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordListType, default initialized and not managed by a soap context
        virtual ns1__RecordListType *soap_alloc(void) const { return SOAP_NEW(ns1__RecordListType); }
      public:
        /// Constructor with initializations
        ns1__RecordListType() : __sizeitems(), items() { }
        virtual ~ns1__RecordListType() { }
        /// Friend allocator used by soap_new_ns1__RecordListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordListType * SOAP_FMAC2 soap_instantiate_ns1__RecordListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:440 */
#ifndef SOAP_TYPE_ns1__RecordType
#define SOAP_TYPE_ns1__RecordType (96)
/* Type ns1__RecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RecordType': */
class SOAP_CMAC ns1__RecordType : public xsd__anyType {
      public:
        /// Optional element 'unsignedReg' of XSD type 'ns1:UnsignedRecordType'
        ns1__UnsignedRecordType *unsignedReg;
        /// Optional element 'signedReg' of XSD type 'ns1:SignedRecordType'
        ns1__SignedRecordType *signedReg;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordType, default initialized and not managed by a soap context
        virtual ns1__RecordType *soap_alloc(void) const { return SOAP_NEW(ns1__RecordType); }
      public:
        /// Constructor with initializations
        ns1__RecordType() : unsignedReg(), signedReg() { }
        virtual ~ns1__RecordType() { }
        /// Friend allocator used by soap_new_ns1__RecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordType * SOAP_FMAC2 soap_instantiate_ns1__RecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:2226 */
#ifndef SOAP_TYPE__ns1__union_UnsignedRecordType
#define SOAP_TYPE__ns1__union_UnsignedRecordType (496)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_UnsignedRecordType
{
        #define SOAP_UNION__ns1__union_UnsignedRecordType_suOp	(1)	/**< union variant selector value for member suOp */
        ns1__StartUpRecordType *suOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_sosOp	(2)	/**< union variant selector value for member sosOp */
        ns1__StartOfSessionRecordType *sosOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_eosOp	(3)	/**< union variant selector value for member eosOp */
        ns1__EndOfSessionRecordType *eosOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cbOp	(4)	/**< union variant selector value for member cbOp */
        ns1__CsmBlockingRecordType *cbOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cuOp	(5)	/**< union variant selector value for member cuOp */
        ns1__CsmUnblockingRecordType *cuOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_alOp	(6)	/**< union variant selector value for member alOp */
        ns1__ActionListRecordType *alOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_lcOp	(7)	/**< union variant selector value for member lcOp */
        ns1__LocationChangeRecordType *lcOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_OpeosOp	(8)	/**< union variant selector value for member OpeosOp */
        ns1__OpEndOfSessionRecordType *OpeosOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_iOp	(9)	/**< union variant selector value for member iOp */
        ns1__IdentificationRecordType *iOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_lfOp	(10)	/**< union variant selector value for member lfOp */
        ns1__LoginFailureRecordType *lfOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_maOp	(11)	/**< union variant selector value for member maOp */
        ns1__MaintenanceAccessRecordType *maOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_bsOp	(12)	/**< union variant selector value for member bsOp */
        ns1__BeginShiftRecordType *bsOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_esOp	(13)	/**< union variant selector value for member esOp */
        ns1__EndShiftRecordType *esOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_lsOp	(14)	/**< union variant selector value for member lsOp */
        ns1__LockShiftRecordType *lsOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_usOp	(15)	/**< union variant selector value for member usOp */
        ns1__UnlockShiftRecordType *usOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_crOp	(16)	/**< union variant selector value for member crOp */
        ns1__CommandReportRecordType *crOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_smcOp	(17)	/**< union variant selector value for member smcOp */
        ns1__StationModeChangeRecordType *smcOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_ogpOp	(18)	/**< union variant selector value for member ogpOp */
        ns1__OpenGatePsmRecordType *ogpOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_owagOp	(19)	/**< union variant selector value for member owagOp */
        ns1__OpenWideAisleGateRecordType *owagOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_aoOp	(20)	/**< union variant selector value for member aoOp */
        ns1__AccountingOperationRecordType *aoOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_moOp	(21)	/**< union variant selector value for member moOp */
        ns1__MaintenanceOperationRecordType *moOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_apOp	(22)	/**< union variant selector value for member apOp */
        ns1__AdvancedPurchaseRecordType *apOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_valOp	(23)	/**< union variant selector value for member valOp */
        ns1__ValidationRecordType *valOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_pnltyOp	(24)	/**< union variant selector value for member pnltyOp */
        ns1__PenaltyRecordType *pnltyOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_graOp	(25)	/**< union variant selector value for member graOp */
        ns1__GateRejectionAnalysisRecordType *graOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_collectOp	(26)	/**< union variant selector value for member collectOp */
        ns1__CollectionRecordType *collectOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cnRefOp	(27)	/**< union variant selector value for member cnRefOp */
        ns1__CoinNoteRefillRecordType *cnRefOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_icfOp	(28)	/**< union variant selector value for member icfOp */
        ns1__InternalCoinFlowRecordType *icfOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cnraOp	(29)	/**< union variant selector value for member cnraOp */
        ns1__CoinNoteRefillAdjustmentRecordType *cnraOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cmOp	(30)	/**< union variant selector value for member cmOp */
        ns1__CashMaintenanceRecordType *cmOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cncOp	(31)	/**< union variant selector value for member cncOp */
        ns1__CoinsAndNotesCollectionRecordType *cncOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_msuOp	(32)	/**< union variant selector value for member msuOp */
        ns1__MediaStockUpdateRecordType *msuOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_msaOp	(33)	/**< union variant selector value for member msaOp */
        ns1__MediaStockAdjustRecordType *msaOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_ccOp	(34)	/**< union variant selector value for member ccOp */
        ns1__CashCountingRecordType *ccOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_ccaOp	(35)	/**< union variant selector value for member ccaOp */
        ns1__CashCountingAdjustRecordType *ccaOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cscRepOp	(36)	/**< union variant selector value for member cscRepOp */
        ns1__CscReplacementRecordType *cscRepOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cscRefOp	(37)	/**< union variant selector value for member cscRefOp */
        ns1__CscRefundRecordType *cscRefOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_teOp	(38)	/**< union variant selector value for member teOp */
        ns1__TicketExchangeRecordType *teOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_ioOp	(39)	/**< union variant selector value for member ioOp */
        ns1__IssueOperationRecordType *ioOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cscDelOp	(40)	/**< union variant selector value for member cscDelOp */
        ns1__CscDeliveryRecordType *cscDelOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cscKUpdOp	(41)	/**< union variant selector value for member cscKUpdOp */
        ns1__CscKeyUpdateRecordType *cscKUpdOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_csmiOp	(42)	/**< union variant selector value for member csmiOp */
        ns1__CsmInitializationRecordType *csmiOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_cscPerOp	(43)	/**< union variant selector value for member cscPerOp */
        ns1__CscPersonalizationRecordType *cscPerOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_mupdsOp	(44)	/**< union variant selector value for member mupdsOp */
        ns1__MediaUpdateStatusRecordType *mupdsOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_inspectOp	(45)	/**< union variant selector value for member inspectOp */
        ns1__InspectionRecordType *inspectOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_iFailOp	(46)	/**< union variant selector value for member iFailOp */
        ns1__InternalFailureRecordType *iFailOp;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_startTrip	(47)	/**< union variant selector value for member startTrip */
        ns1__StartTripRecordType *startTrip;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_endTrip	(48)	/**< union variant selector value for member endTrip */
        ns1__EndTripRecordType *endTrip;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_prinvoice	(49)	/**< union variant selector value for member prinvoice */
        ns1__PrintedInvoiceRecordType *prinvoice;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_incidence	(50)	/**< union variant selector value for member incidence */
        ns1__IncidenceRecordType *incidence;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_parkingVal	(51)	/**< union variant selector value for member parkingVal */
        ns1__ParkingValidationRecord *parkingVal;
        #define SOAP_UNION__ns1__union_UnsignedRecordType_samQuotaUpdate	(52)	/**< union variant selector value for member samQuotaUpdate */
        ns1__SamQuotaUpdateRecordType *samQuotaUpdate;
};
#endif

/* sopa.h:443 */
#ifndef SOAP_TYPE_ns1__UnsignedRecordType
#define SOAP_TYPE_ns1__UnsignedRecordType (97)
/* Type ns1__UnsignedRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UnsignedRecordType': */
class SOAP_CMAC ns1__UnsignedRecordType : public xsd__anyType {
      public:
        /// Union with union _ns1__union_UnsignedRecordType variant selector __union_UnsignedRecordType set to one of: SOAP_UNION__ns1__union_UnsignedRecordType_suOp SOAP_UNION__ns1__union_UnsignedRecordType_sosOp SOAP_UNION__ns1__union_UnsignedRecordType_eosOp SOAP_UNION__ns1__union_UnsignedRecordType_cbOp SOAP_UNION__ns1__union_UnsignedRecordType_cuOp SOAP_UNION__ns1__union_UnsignedRecordType_alOp SOAP_UNION__ns1__union_UnsignedRecordType_lcOp SOAP_UNION__ns1__union_UnsignedRecordType_OpeosOp SOAP_UNION__ns1__union_UnsignedRecordType_iOp SOAP_UNION__ns1__union_UnsignedRecordType_lfOp SOAP_UNION__ns1__union_UnsignedRecordType_maOp SOAP_UNION__ns1__union_UnsignedRecordType_bsOp SOAP_UNION__ns1__union_UnsignedRecordType_esOp SOAP_UNION__ns1__union_UnsignedRecordType_lsOp SOAP_UNION__ns1__union_UnsignedRecordType_usOp SOAP_UNION__ns1__union_UnsignedRecordType_crOp SOAP_UNION__ns1__union_UnsignedRecordType_smcOp SOAP_UNION__ns1__union_UnsignedRecordType_ogpOp SOAP_UNION__ns1__union_UnsignedRecordType_owagOp SOAP_UNION__ns1__union_UnsignedRecordType_aoOp SOAP_UNION__ns1__union_UnsignedRecordType_moOp SOAP_UNION__ns1__union_UnsignedRecordType_apOp SOAP_UNION__ns1__union_UnsignedRecordType_valOp SOAP_UNION__ns1__union_UnsignedRecordType_pnltyOp SOAP_UNION__ns1__union_UnsignedRecordType_graOp SOAP_UNION__ns1__union_UnsignedRecordType_collectOp SOAP_UNION__ns1__union_UnsignedRecordType_cnRefOp SOAP_UNION__ns1__union_UnsignedRecordType_icfOp SOAP_UNION__ns1__union_UnsignedRecordType_cnraOp SOAP_UNION__ns1__union_UnsignedRecordType_cmOp SOAP_UNION__ns1__union_UnsignedRecordType_cncOp SOAP_UNION__ns1__union_UnsignedRecordType_msuOp SOAP_UNION__ns1__union_UnsignedRecordType_msaOp SOAP_UNION__ns1__union_UnsignedRecordType_ccOp SOAP_UNION__ns1__union_UnsignedRecordType_ccaOp SOAP_UNION__ns1__union_UnsignedRecordType_cscRepOp SOAP_UNION__ns1__union_UnsignedRecordType_cscRefOp SOAP_UNION__ns1__union_UnsignedRecordType_teOp SOAP_UNION__ns1__union_UnsignedRecordType_ioOp SOAP_UNION__ns1__union_UnsignedRecordType_cscDelOp SOAP_UNION__ns1__union_UnsignedRecordType_cscKUpdOp SOAP_UNION__ns1__union_UnsignedRecordType_csmiOp SOAP_UNION__ns1__union_UnsignedRecordType_cscPerOp SOAP_UNION__ns1__union_UnsignedRecordType_mupdsOp SOAP_UNION__ns1__union_UnsignedRecordType_inspectOp SOAP_UNION__ns1__union_UnsignedRecordType_iFailOp SOAP_UNION__ns1__union_UnsignedRecordType_startTrip SOAP_UNION__ns1__union_UnsignedRecordType_endTrip SOAP_UNION__ns1__union_UnsignedRecordType_prinvoice SOAP_UNION__ns1__union_UnsignedRecordType_incidence SOAP_UNION__ns1__union_UnsignedRecordType_parkingVal SOAP_UNION__ns1__union_UnsignedRecordType_samQuotaUpdate
        int __union_UnsignedRecordType;
        union _ns1__union_UnsignedRecordType union_UnsignedRecordType;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UnsignedRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UnsignedRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UnsignedRecordType, default initialized and not managed by a soap context
        virtual ns1__UnsignedRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__UnsignedRecordType); }
      public:
        /// Constructor with initializations
        ns1__UnsignedRecordType() : __union_UnsignedRecordType() { }
        virtual ~ns1__UnsignedRecordType() { }
        /// Friend allocator used by soap_new_ns1__UnsignedRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UnsignedRecordType * SOAP_FMAC2 soap_instantiate_ns1__UnsignedRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:449 */
#ifndef SOAP_TYPE_ns1__BaseRecordType
#define SOAP_TYPE_ns1__BaseRecordType (99)
/* Type ns1__BaseRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BaseRecordType': */
class SOAP_CMAC ns1__BaseRecordType : public xsd__anyType {
      public:
        /// Optional element 'cv' of XSD type 'ns1:ConfigVersionTypeList'
        ns1__ConfigVersionTypeList *cv;
        /// Required element 'eqSe' of XSD type 'xsd:unsignedInt'
        unsigned int eqSe;
        /// Optional element 'day' of XSD type 'xsd:date'
        char *day;
        /// Required element 'id' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *id;
        /// Required element 'loc' of XSD type 'ns1:LocationType'
        ns1__LocationType *loc;
        /// Optional element 'opId' of XSD type 'xsd:unsignedInt'
        unsigned int *opId;
        /// Optional element 'opInfo' of XSD type 'ns1:OperationInfoType'
        ns1__OperationInfoType *opInfo;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BaseRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BaseRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BaseRecordType, default initialized and not managed by a soap context
        virtual ns1__BaseRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__BaseRecordType); }
      public:
        /// Constructor with initializations
        ns1__BaseRecordType() : cv(), eqSe(), day(), id(), loc(), opId(), opInfo() { }
        virtual ~ns1__BaseRecordType() { }
        /// Friend allocator used by soap_new_ns1__BaseRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BaseRecordType * SOAP_FMAC2 soap_instantiate_ns1__BaseRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:452 */
#ifndef SOAP_TYPE_ns1__stPackageListType
#define SOAP_TYPE_ns1__stPackageListType (100)
/* Type ns1__stPackageListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:stPackageListType': */
class SOAP_CMAC ns1__stPackageListType : public xsd__anyType {
      public:
        /// Sequence of elements 'pkg' of XSD type 'ns1:stPackageType' stored in dynamic array pkg of length __sizepkg
        int __sizepkg;
        ns1__stPackageType **pkg;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stPackageListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stPackageListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stPackageListType, default initialized and not managed by a soap context
        virtual ns1__stPackageListType *soap_alloc(void) const { return SOAP_NEW(ns1__stPackageListType); }
      public:
        /// Constructor with initializations
        ns1__stPackageListType() : __sizepkg(), pkg() { }
        virtual ~ns1__stPackageListType() { }
        /// Friend allocator used by soap_new_ns1__stPackageListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stPackageListType * SOAP_FMAC2 soap_instantiate_ns1__stPackageListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:455 */
#ifndef SOAP_TYPE_ns1__stPackageType
#define SOAP_TYPE_ns1__stPackageType (101)
/* Type ns1__stPackageType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:stPackageType': */
class SOAP_CMAC ns1__stPackageType : public xsd__anyType {
      public:
        /// Optional element 'confFiles' of XSD type 'ns1:stConfigFileListType'
        ns1__stConfigFileListType *confFiles;
        /// Optional element 'swFiles' of XSD type 'ns1:stSWFileListType'
        ns1__stSWFileListType *swFiles;
        /// required attribute 'pkgId' of XSD type 'xsd:long'
        LONG64 pkgId;
        /// required attribute 'v' of XSD type 'xsd:long'
        LONG64 v;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stPackageType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stPackageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stPackageType, default initialized and not managed by a soap context
        virtual ns1__stPackageType *soap_alloc(void) const { return SOAP_NEW(ns1__stPackageType); }
      public:
        /// Constructor with initializations
        ns1__stPackageType() : confFiles(), swFiles(), pkgId(), v() { }
        virtual ~ns1__stPackageType() { }
        /// Friend allocator used by soap_new_ns1__stPackageType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stPackageType * SOAP_FMAC2 soap_instantiate_ns1__stPackageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:458 */
#ifndef SOAP_TYPE_ns1__stConfigFileListType
#define SOAP_TYPE_ns1__stConfigFileListType (102)
/* Type ns1__stConfigFileListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:stConfigFileListType': */
class SOAP_CMAC ns1__stConfigFileListType : public xsd__anyType {
      public:
        /// Sequence of elements 'cF' of XSD type 'ns1:stConfigFileType' stored in dynamic array cF of length __sizecF
        int __sizecF;
        ns1__stConfigFileType **cF;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stConfigFileListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stConfigFileListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stConfigFileListType, default initialized and not managed by a soap context
        virtual ns1__stConfigFileListType *soap_alloc(void) const { return SOAP_NEW(ns1__stConfigFileListType); }
      public:
        /// Constructor with initializations
        ns1__stConfigFileListType() : __sizecF(), cF() { }
        virtual ~ns1__stConfigFileListType() { }
        /// Friend allocator used by soap_new_ns1__stConfigFileListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stConfigFileListType * SOAP_FMAC2 soap_instantiate_ns1__stConfigFileListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:461 */
#ifndef SOAP_TYPE_ns1__stConfigFileType
#define SOAP_TYPE_ns1__stConfigFileType (103)
/* Type ns1__stConfigFileType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:stConfigFileType': */
class SOAP_CMAC ns1__stConfigFileType : public xsd__anyType {
      public:
        /// required attribute 'fieldId' of XSD type 'xsd:long'
        LONG64 fieldId;
        /// required attribute 'v' of XSD type 'xsd:long'
        LONG64 v;
        /// required attribute 'incV' of XSD type 'xsd:long'
        LONG64 incV;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stConfigFileType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stConfigFileType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stConfigFileType, default initialized and not managed by a soap context
        virtual ns1__stConfigFileType *soap_alloc(void) const { return SOAP_NEW(ns1__stConfigFileType); }
      public:
        /// Constructor with initializations
        ns1__stConfigFileType() : fieldId(), v(), incV() { }
        virtual ~ns1__stConfigFileType() { }
        /// Friend allocator used by soap_new_ns1__stConfigFileType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stConfigFileType * SOAP_FMAC2 soap_instantiate_ns1__stConfigFileType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:464 */
#ifndef SOAP_TYPE_ns1__stSWFileListType
#define SOAP_TYPE_ns1__stSWFileListType (104)
/* Type ns1__stSWFileListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:stSWFileListType': */
class SOAP_CMAC ns1__stSWFileListType : public xsd__anyType {
      public:
        /// Sequence of elements 'swF' of XSD type 'ns1:stSWFileType' stored in dynamic array swF of length __sizeswF
        int __sizeswF;
        ns1__stSWFileType **swF;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stSWFileListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stSWFileListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stSWFileListType, default initialized and not managed by a soap context
        virtual ns1__stSWFileListType *soap_alloc(void) const { return SOAP_NEW(ns1__stSWFileListType); }
      public:
        /// Constructor with initializations
        ns1__stSWFileListType() : __sizeswF(), swF() { }
        virtual ~ns1__stSWFileListType() { }
        /// Friend allocator used by soap_new_ns1__stSWFileListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stSWFileListType * SOAP_FMAC2 soap_instantiate_ns1__stSWFileListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:467 */
#ifndef SOAP_TYPE_ns1__stSWFileType
#define SOAP_TYPE_ns1__stSWFileType (105)
/* Type ns1__stSWFileType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:stSWFileType': */
class SOAP_CMAC ns1__stSWFileType : public xsd__anyType {
      public:
        /// required attribute 'fieldId' of XSD type 'xsd:long'
        LONG64 fieldId;
        /// required attribute 'v' of XSD type 'xsd:string'
        char *v;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stSWFileType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stSWFileType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stSWFileType, default initialized and not managed by a soap context
        virtual ns1__stSWFileType *soap_alloc(void) const { return SOAP_NEW(ns1__stSWFileType); }
      public:
        /// Constructor with initializations
        ns1__stSWFileType() : fieldId(), v() { }
        virtual ~ns1__stSWFileType() { }
        /// Friend allocator used by soap_new_ns1__stSWFileType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stSWFileType * SOAP_FMAC2 soap_instantiate_ns1__stSWFileType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:470 */
#ifndef SOAP_TYPE_ns1__ConfigVersionTypeList
#define SOAP_TYPE_ns1__ConfigVersionTypeList (106)
/* Type ns1__ConfigVersionTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ConfigVersionTypeList': */
class SOAP_CMAC ns1__ConfigVersionTypeList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'cv' of XSD type 'ns1:ConfigVersionType' stored in dynamic array cv of length __sizecv
        int __sizecv;
        ns1__ConfigVersionType **cv;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ConfigVersionTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ConfigVersionTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ConfigVersionTypeList, default initialized and not managed by a soap context
        virtual ns1__ConfigVersionTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__ConfigVersionTypeList); }
      public:
        /// Constructor with initializations
        ns1__ConfigVersionTypeList() : __sizecv(), cv() { }
        virtual ~ns1__ConfigVersionTypeList() { }
        /// Friend allocator used by soap_new_ns1__ConfigVersionTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__ConfigVersionTypeList * SOAP_FMAC2 soap_instantiate_ns1__ConfigVersionTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:473 */
#ifndef SOAP_TYPE_ns1__ConfigVersionType
#define SOAP_TYPE_ns1__ConfigVersionType (107)
/* Type ns1__ConfigVersionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ConfigVersionType': */
class SOAP_CMAC ns1__ConfigVersionType : public xsd__anyType {
      public:
        /// required attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int id;
        /// required attribute 'v' of XSD type 'xsd:unsignedInt'
        unsigned int v;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ConfigVersionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ConfigVersionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ConfigVersionType, default initialized and not managed by a soap context
        virtual ns1__ConfigVersionType *soap_alloc(void) const { return SOAP_NEW(ns1__ConfigVersionType); }
      public:
        /// Constructor with initializations
        ns1__ConfigVersionType() : id(), v() { }
        virtual ~ns1__ConfigVersionType() { }
        /// Friend allocator used by soap_new_ns1__ConfigVersionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ConfigVersionType * SOAP_FMAC2 soap_instantiate_ns1__ConfigVersionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:476 */
#ifndef SOAP_TYPE_ns1__LocationType
#define SOAP_TYPE_ns1__LocationType (108)
/* Type ns1__LocationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:LocationType': */
class SOAP_CMAC ns1__LocationType : public xsd__anyType {
      public:
        /// Optional element 'fxLoc' of XSD type 'ns1:FixedLocation'
        ns1__FixedLocation *fxLoc;
        /// Optional element 'obLoc' of XSD type 'ns1:OnboardLocation'
        ns1__OnboardLocation *obLoc;
        /// Optional element 'opLoc' of XSD type 'ns1:OperationalLocation'
        ns1__OperationalLocation *opLoc;
        /// Optional element 'avLoc' of XSD type 'ns1:AVLocation'
        ns1__AVLocation *avLoc;
        /// Optional element 'st' of XSD type 'ns1:LocationStationType'
        ns1__LocationStationType *st;
        /// Optional element 'bo' of XSD type 'ns1:LocationBoardType'
        ns1__LocationBoardType *bo;
        /// required attribute 'id' of XSD type 'xsd:long'
        LONG64 id;
        /// required attribute 'srv' of XSD type 'xsd:unsignedInt'
        unsigned int srv;
        /// required attribute 'pos' of XSD type 'xsd:unsignedInt'
        unsigned int pos;
        /// optional attribute 'refId' of XSD type 'xsd:string'
        char *refId;
        /// required attribute 'li' of XSD type 'xsd:unsignedInt'
        unsigned int li;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LocationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LocationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LocationType, default initialized and not managed by a soap context
        virtual ns1__LocationType *soap_alloc(void) const { return SOAP_NEW(ns1__LocationType); }
      public:
        /// Constructor with initializations
        ns1__LocationType() : fxLoc(), obLoc(), opLoc(), avLoc(), st(), bo(), id(), srv(), pos(), refId(), li() { }
        virtual ~ns1__LocationType() { }
        /// Friend allocator used by soap_new_ns1__LocationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LocationType * SOAP_FMAC2 soap_instantiate_ns1__LocationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:482 */
#ifndef SOAP_TYPE_ns1__EquipmentLocation
#define SOAP_TYPE_ns1__EquipmentLocation (110)
/* Type ns1__EquipmentLocation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:EquipmentLocation': */
class SOAP_CMAC ns1__EquipmentLocation : public xsd__anyType {
      public:
        /// Required element 'ref' of XSD type 'xsd:string'
        char *ref;
        /// Required element 'eqt' of XSD type 'xsd:unsignedInt'
        unsigned int eqt;
        /// Required element 'agn' of XSD type 'xsd:unsignedInt'
        unsigned int agn;
        /// required attribute 'id' of XSD type 'xsd:long'
        LONG64 id;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EquipmentLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EquipmentLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EquipmentLocation, default initialized and not managed by a soap context
        virtual ns1__EquipmentLocation *soap_alloc(void) const { return SOAP_NEW(ns1__EquipmentLocation); }
      public:
        /// Constructor with initializations
        ns1__EquipmentLocation() : ref(), eqt(), agn(), id() { }
        virtual ~ns1__EquipmentLocation() { }
        /// Friend allocator used by soap_new_ns1__EquipmentLocation(struct soap*, int)
        friend SOAP_FMAC1 ns1__EquipmentLocation * SOAP_FMAC2 soap_instantiate_ns1__EquipmentLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:491 */
#ifndef SOAP_TYPE_ns1__OperationalLocationBase
#define SOAP_TYPE_ns1__OperationalLocationBase (113)
/* Type ns1__OperationalLocationBase is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OperationalLocationBase': */
class SOAP_CMAC ns1__OperationalLocationBase : public xsd__anyType {
      public:
        /// Optional element 'tripNum' of XSD type 'xsd:unsignedInt'
        unsigned int *tripNum;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OperationalLocationBase
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OperationalLocationBase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OperationalLocationBase, default initialized and not managed by a soap context
        virtual ns1__OperationalLocationBase *soap_alloc(void) const { return SOAP_NEW(ns1__OperationalLocationBase); }
      public:
        /// Constructor with initializations
        ns1__OperationalLocationBase() : tripNum() { }
        virtual ~ns1__OperationalLocationBase() { }
        /// Friend allocator used by soap_new_ns1__OperationalLocationBase(struct soap*, int)
        friend SOAP_FMAC1 ns1__OperationalLocationBase * SOAP_FMAC2 soap_instantiate_ns1__OperationalLocationBase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:497 */
#ifndef SOAP_TYPE_ns1__Schedule
#define SOAP_TYPE_ns1__Schedule (115)
/* Type ns1__Schedule is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:Schedule': */
class SOAP_CMAC ns1__Schedule : public xsd__anyType {
      public:
        /// Required element 'block' of XSD type 'xsd:unsignedInt'
        unsigned int block;
        /// Required element 'run' of XSD type 'xsd:unsignedInt'
        unsigned int run;
        /// Required element 'trip' of XSD type 'xsd:unsignedInt'
        unsigned int trip;
        /// Optional element 'duty' of XSD type 'xsd:unsignedInt'
        unsigned int *duty;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Schedule
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Schedule; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Schedule, default initialized and not managed by a soap context
        virtual ns1__Schedule *soap_alloc(void) const { return SOAP_NEW(ns1__Schedule); }
      public:
        /// Constructor with initializations
        ns1__Schedule() : block(), run(), trip(), duty() { }
        virtual ~ns1__Schedule() { }
        /// Friend allocator used by soap_new_ns1__Schedule(struct soap*, int)
        friend SOAP_FMAC1 ns1__Schedule * SOAP_FMAC2 soap_instantiate_ns1__Schedule(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:500 */
#ifndef SOAP_TYPE_ns1__LocationStationType
#define SOAP_TYPE_ns1__LocationStationType (116)
/* Type ns1__LocationStationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:LocationStationType': */
class SOAP_CMAC ns1__LocationStationType : public xsd__anyType {
      public:
        /// required attribute 'st' of XSD type 'xsd:unsignedInt'
        unsigned int st;
        /// required attribute 'areaId' of XSD type 'xsd:unsignedInt'
        unsigned int areaId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LocationStationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LocationStationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LocationStationType, default initialized and not managed by a soap context
        virtual ns1__LocationStationType *soap_alloc(void) const { return SOAP_NEW(ns1__LocationStationType); }
      public:
        /// Constructor with initializations
        ns1__LocationStationType() : st(), areaId() { }
        virtual ~ns1__LocationStationType() { }
        /// Friend allocator used by soap_new_ns1__LocationStationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LocationStationType * SOAP_FMAC2 soap_instantiate_ns1__LocationStationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:503 */
#ifndef SOAP_TYPE_ns1__LocationBoardType
#define SOAP_TYPE_ns1__LocationBoardType (117)
/* Type ns1__LocationBoardType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:LocationBoardType': */
class SOAP_CMAC ns1__LocationBoardType : public xsd__anyType {
      public:
        /// required attribute 'ro' of XSD type 'xsd:unsignedInt'
        unsigned int ro;
        /// optional attribute 'dT' of XSD type 'xsd:unsignedInt'
        unsigned int *dT;
        /// required attribute 'stop' of XSD type 'xsd:unsignedInt'
        unsigned int stop;
        /// required attribute 'veh' of XSD type 'xsd:unsignedInt'
        unsigned int veh;
        /// optional attribute 'blkNum' of XSD type 'xsd:unsignedInt'
        unsigned int *blkNum;
        /// optional attribute 'runNum' of XSD type 'xsd:unsignedInt'
        unsigned int *runNum;
        /// optional attribute 'tripNum' of XSD type 'xsd:unsignedInt'
        unsigned int *tripNum;
        /// optional attribute 'dttyNum' of XSD type 'xsd:unsignedInt'
        unsigned int *dttyNum;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LocationBoardType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LocationBoardType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LocationBoardType, default initialized and not managed by a soap context
        virtual ns1__LocationBoardType *soap_alloc(void) const { return SOAP_NEW(ns1__LocationBoardType); }
      public:
        /// Constructor with initializations
        ns1__LocationBoardType() : ro(), dT(), stop(), veh(), blkNum(), runNum(), tripNum(), dttyNum() { }
        virtual ~ns1__LocationBoardType() { }
        /// Friend allocator used by soap_new_ns1__LocationBoardType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LocationBoardType * SOAP_FMAC2 soap_instantiate_ns1__LocationBoardType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:506 */
#ifndef SOAP_TYPE_ns1__OperationInfoType
#define SOAP_TYPE_ns1__OperationInfoType (118)
/* Type ns1__OperationInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OperationInfoType': */
class SOAP_CMAC ns1__OperationInfoType : public xsd__anyType {
      public:
        /// Required element 'opDate' of XSD type 'xsd:dateTime'
        time_t opDate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OperationInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OperationInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OperationInfoType, default initialized and not managed by a soap context
        virtual ns1__OperationInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__OperationInfoType); }
      public:
        /// Constructor with initializations
        ns1__OperationInfoType() : opDate() { }
        virtual ~ns1__OperationInfoType() { }
        /// Friend allocator used by soap_new_ns1__OperationInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OperationInfoType * SOAP_FMAC2 soap_instantiate_ns1__OperationInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:512 */
#ifndef SOAP_TYPE_ns1__shiftType
#define SOAP_TYPE_ns1__shiftType (120)
/* Type ns1__shiftType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:shiftType': */
class SOAP_CMAC ns1__shiftType : public xsd__anyType {
      public:
        /// required attribute 'shN' of XSD type 'xsd:long'
        LONG64 shN;
        /// required attribute 'userId' of XSD type 'xsd:long'
        LONG64 userId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__shiftType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__shiftType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__shiftType, default initialized and not managed by a soap context
        virtual ns1__shiftType *soap_alloc(void) const { return SOAP_NEW(ns1__shiftType); }
      public:
        /// Constructor with initializations
        ns1__shiftType() : shN(), userId() { }
        virtual ~ns1__shiftType() { }
        /// Friend allocator used by soap_new_ns1__shiftType(struct soap*, int)
        friend SOAP_FMAC1 ns1__shiftType * SOAP_FMAC2 soap_instantiate_ns1__shiftType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:518 */
#ifndef SOAP_TYPE_ns1__TitleCodeType
#define SOAP_TYPE_ns1__TitleCodeType (122)
/* Type ns1__TitleCodeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:TitleCodeType': */
class SOAP_CMAC ns1__TitleCodeType : public xsd__anyType {
      public:
        /// required attribute 'ag' of XSD type 'xsd:unsignedInt'
        unsigned int ag;
        /// required attribute 'pCod' of XSD type 'xsd:unsignedInt'
        unsigned int pCod;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TitleCodeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TitleCodeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TitleCodeType, default initialized and not managed by a soap context
        virtual ns1__TitleCodeType *soap_alloc(void) const { return SOAP_NEW(ns1__TitleCodeType); }
      public:
        /// Constructor with initializations
        ns1__TitleCodeType() : ag(), pCod() { }
        virtual ~ns1__TitleCodeType() { }
        /// Friend allocator used by soap_new_ns1__TitleCodeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TitleCodeType * SOAP_FMAC2 soap_instantiate_ns1__TitleCodeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:521 */
#ifndef SOAP_TYPE_ns1__FareType
#define SOAP_TYPE_ns1__FareType (123)
/* Type ns1__FareType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:FareType': */
class SOAP_CMAC ns1__FareType : public xsd__anyType {
      public:
        /// required attribute 'stMod' of XSD type 'xsd:long'
        LONG64 stMod;
        /// required attribute 'mt' of XSD type 'xsd:unsignedInt'
        unsigned int mt;
        /// required attribute 'pf' of XSD type 'xsd:unsignedInt'
        unsigned int pf;
        /// required attribute 'dAm' of XSD type 'xsd:int'
        int dAm;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FareType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FareType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FareType, default initialized and not managed by a soap context
        virtual ns1__FareType *soap_alloc(void) const { return SOAP_NEW(ns1__FareType); }
      public:
        /// Constructor with initializations
        ns1__FareType() : stMod(), mt(), pf(), dAm() { }
        virtual ~ns1__FareType() { }
        /// Friend allocator used by soap_new_ns1__FareType(struct soap*, int)
        friend SOAP_FMAC1 ns1__FareType * SOAP_FMAC2 soap_instantiate_ns1__FareType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:524 */
#ifndef SOAP_TYPE_ns1__FareInfo
#define SOAP_TYPE_ns1__FareInfo (124)
/* Type ns1__FareInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FareInfo': */
class SOAP_CMAC ns1__FareInfo : public xsd__anyType {
      public:
        /// Sequence of elements 'prod' of XSD type 'ns1:FareProduct' stored in dynamic array prod of length __sizeprod
        int __sizeprod;
        ns1__FareProduct **prod;
        /// Optional element 'fareType' of XSD type 'xsd:unsignedInt'
        unsigned int *fareType;
        /// Optional element 'prof' of XSD type 'xsd:unsignedInt'
        unsigned int *prof;
        /// Optional element 'media' of XSD type 'ns1:FareMedia'
        ns1__FareMedia *media;
        /// Optional element 'dayType' of XSD type 'xsd:unsignedInt'
        unsigned int *dayType;
        /// Optional element 'perType' of XSD type 'xsd:unsignedInt'
        unsigned int *perType;
        /// Optional element 'class' of XSD type 'xsd:unsignedInt'
        unsigned int *class_;
        /// Optional element 'vehType' of XSD type 'xsd:unsignedInt'
        unsigned int *vehType;
        /// Optional element 'prvServ' of XSD type 'xsd:unsignedInt'
        unsigned int *prvServ;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FareInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FareInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FareInfo, default initialized and not managed by a soap context
        virtual ns1__FareInfo *soap_alloc(void) const { return SOAP_NEW(ns1__FareInfo); }
      public:
        /// Constructor with initializations
        ns1__FareInfo() : __sizeprod(), prod(), fareType(), prof(), media(), dayType(), perType(), class_(), vehType(), prvServ() { }
        virtual ~ns1__FareInfo() { }
        /// Friend allocator used by soap_new_ns1__FareInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__FareInfo * SOAP_FMAC2 soap_instantiate_ns1__FareInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:527 */
#ifndef SOAP_TYPE_ns1__FareProduct
#define SOAP_TYPE_ns1__FareProduct (125)
/* Type ns1__FareProduct is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FareProduct': */
class SOAP_CMAC ns1__FareProduct : public xsd__anyType {
      public:
        /// Optional element 'uid' of XSD type 'xsd:long'
        LONG64 *uid;
        /// Optional element 'units' of XSD type 'xsd:int'
        int *units;
        /// Optional element 'remain_units' of XSD type 'xsd:int'
        int *remain_USCOREunits;
        /// Optional element 'exp' of XSD type 'xsd:dateTime'
        time_t *exp;
        /// Optional element 'act' of XSD type 'xsd:dateTime'
        time_t *act;
        /// Optional element 'purchaseNum' of XSD type 'xsd:string'
        char *purchaseNum;
        /// required attribute 'cod' of XSD type 'xsd:unsignedInt'
        unsigned int cod;
        /// required attribute 'agn' of XSD type 'xsd:unsignedInt'
        unsigned int agn;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FareProduct
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FareProduct; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FareProduct, default initialized and not managed by a soap context
        virtual ns1__FareProduct *soap_alloc(void) const { return SOAP_NEW(ns1__FareProduct); }
      public:
        /// Constructor with initializations
        ns1__FareProduct() : uid(), units(), remain_USCOREunits(), exp(), act(), purchaseNum(), cod(), agn(), type() { }
        virtual ~ns1__FareProduct() { }
        /// Friend allocator used by soap_new_ns1__FareProduct(struct soap*, int)
        friend SOAP_FMAC1 ns1__FareProduct * SOAP_FMAC2 soap_instantiate_ns1__FareProduct(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:530 */
#ifndef SOAP_TYPE_ns1__FareMedia
#define SOAP_TYPE_ns1__FareMedia (126)
/* Type ns1__FareMedia is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FareMedia': */
class SOAP_CMAC ns1__FareMedia : public xsd__anyType {
      public:
        /// Optional element 'units' of XSD type 'xsd:unsignedInt'
        unsigned int *units;
        /// Optional element 'exp' of XSD type 'xsd:dateTime'
        time_t *exp;
        /// required attribute 'cod' of XSD type 'xsd:unsignedInt'
        unsigned int cod;
        /// required attribute 'agn' of XSD type 'xsd:unsignedInt'
        unsigned int agn;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FareMedia
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FareMedia; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FareMedia, default initialized and not managed by a soap context
        virtual ns1__FareMedia *soap_alloc(void) const { return SOAP_NEW(ns1__FareMedia); }
      public:
        /// Constructor with initializations
        ns1__FareMedia() : units(), exp(), cod(), agn(), type() { }
        virtual ~ns1__FareMedia() { }
        /// Friend allocator used by soap_new_ns1__FareMedia(struct soap*, int)
        friend SOAP_FMAC1 ns1__FareMedia * SOAP_FMAC2 soap_instantiate_ns1__FareMedia(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:533 */
#ifndef SOAP_TYPE_ns1__ValidationOpType
#define SOAP_TYPE_ns1__ValidationOpType (127)
/* Type ns1__ValidationOpType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ValidationOpType': */
class SOAP_CMAC ns1__ValidationOpType : public xsd__anyType {
      public:
        /// required attribute 'vT' of XSD type 'xsd:long'
        LONG64 vT;
        /// required attribute 'r' of XSD type 'xsd:long'
        LONG64 r;
        /// required attribute 'iT' of XSD type 'xsd:long'
        LONG64 iT;
        /// required attribute 'oSt' of XSD type 'xsd:long'
        LONG64 oSt;
        /// required attribute 'oEq' of XSD type 'xsd:long'
        LONG64 oEq;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ValidationOpType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ValidationOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ValidationOpType, default initialized and not managed by a soap context
        virtual ns1__ValidationOpType *soap_alloc(void) const { return SOAP_NEW(ns1__ValidationOpType); }
      public:
        /// Constructor with initializations
        ns1__ValidationOpType() : vT(), r(), iT(), oSt(), oEq() { }
        virtual ~ns1__ValidationOpType() { }
        /// Friend allocator used by soap_new_ns1__ValidationOpType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ValidationOpType * SOAP_FMAC2 soap_instantiate_ns1__ValidationOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:536 */
#ifndef SOAP_TYPE_ns1__ValidationInfo
#define SOAP_TYPE_ns1__ValidationInfo (128)
/* Type ns1__ValidationInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ValidationInfo': */
class SOAP_CMAC ns1__ValidationInfo : public xsd__anyType {
      public:
        /// Required element 'type' of XSD type 'xsd:unsignedInt'
        unsigned int type;
        /// Required element 'rslt' of XSD type 'xsd:unsignedInt'
        unsigned int rslt;
        /// Optional element 'oSt' of XSD type 'xsd:long'
        LONG64 *oSt;
        /// Optional element 'oEq' of XSD type 'xsd:long'
        LONG64 *oEq;
        /// Optional element 'dSt' of XSD type 'xsd:long'
        LONG64 *dSt;
        /// optional attribute 'test' of XSD type 'xsd:boolean'
        bool *test;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ValidationInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ValidationInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ValidationInfo, default initialized and not managed by a soap context
        virtual ns1__ValidationInfo *soap_alloc(void) const { return SOAP_NEW(ns1__ValidationInfo); }
      public:
        /// Constructor with initializations
        ns1__ValidationInfo() : type(), rslt(), oSt(), oEq(), dSt(), test() { }
        virtual ~ns1__ValidationInfo() { }
        /// Friend allocator used by soap_new_ns1__ValidationInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__ValidationInfo * SOAP_FMAC2 soap_instantiate_ns1__ValidationInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:539 */
#ifndef SOAP_TYPE_ns1__cardIdentificationType
#define SOAP_TYPE_ns1__cardIdentificationType (129)
/* Type ns1__cardIdentificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:cardIdentificationType': */
class SOAP_CMAC ns1__cardIdentificationType : public xsd__anyType {
      public:
        /// optional attribute 'swSerialNumber' of XSD type 'xsd:long'
        LONG64 *swSerialNumber;
        /// optional attribute 'hwSerialNumber' of XSD type 'xsd:long'
        LONG64 *hwSerialNumber;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__cardIdentificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__cardIdentificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__cardIdentificationType, default initialized and not managed by a soap context
        virtual ns1__cardIdentificationType *soap_alloc(void) const { return SOAP_NEW(ns1__cardIdentificationType); }
      public:
        /// Constructor with initializations
        ns1__cardIdentificationType() : swSerialNumber(), hwSerialNumber(), type() { }
        virtual ~ns1__cardIdentificationType() { }
        /// Friend allocator used by soap_new_ns1__cardIdentificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__cardIdentificationType * SOAP_FMAC2 soap_instantiate_ns1__cardIdentificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:542 */
#ifndef SOAP_TYPE_ns1__CardDataInfoType
#define SOAP_TYPE_ns1__CardDataInfoType (130)
/* Type ns1__CardDataInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CardDataInfoType': */
class SOAP_CMAC ns1__CardDataInfoType : public xsd__anyType {
      public:
        /// Optional element 'sequenceNumber' of XSD type 'xsd:unsignedInt'
        unsigned int *sequenceNumber;
        /// Optional element 'remainingValue' of XSD type 'xsd:int'
        int *remainingValue;
        /// Optional element 'transactionValue' of XSD type 'xsd:int'
        int *transactionValue;
        /// optional attribute 'hexHwSerialNumber' of XSD type 'xsd:hexBinary'
        xsd__hexBinary *hexHwSerialNumber;
        /// optional attribute 'swSerialNumber' of XSD type 'xsd:long'
        LONG64 *swSerialNumber;
        /// optional attribute 'hwSerialNumber' of XSD type 'xsd:long'
        LONG64 *hwSerialNumber;
        /// optional attribute 'logSerialNumber' of XSD type 'xsd:string'
        char *logSerialNumber;
        /// optional attribute 'mediumTypeId' of XSD type 'xsd:long'
        LONG64 *mediumTypeId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CardDataInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CardDataInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CardDataInfoType, default initialized and not managed by a soap context
        virtual ns1__CardDataInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__CardDataInfoType); }
      public:
        /// Constructor with initializations
        ns1__CardDataInfoType() : sequenceNumber(), remainingValue(), transactionValue(), hexHwSerialNumber(), swSerialNumber(), hwSerialNumber(), logSerialNumber(), mediumTypeId() { }
        virtual ~ns1__CardDataInfoType() { }
        /// Friend allocator used by soap_new_ns1__CardDataInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CardDataInfoType * SOAP_FMAC2 soap_instantiate_ns1__CardDataInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:545 */
#ifndef SOAP_TYPE_ns1__CardDataMagType
#define SOAP_TYPE_ns1__CardDataMagType (131)
/* Type ns1__CardDataMagType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CardDataMagType': */
class SOAP_CMAC ns1__CardDataMagType : public xsd__anyType {
      public:
        /// Required element 'header' of XSD type 'ns1:cardDataMagHeader'
        ns1__cardDataMagHeader *header;
        /// Required element 'body' of XSD type 'ns1:cardDataMagBody'
        ns1__cardDataMagBody *body;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CardDataMagType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CardDataMagType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CardDataMagType, default initialized and not managed by a soap context
        virtual ns1__CardDataMagType *soap_alloc(void) const { return SOAP_NEW(ns1__CardDataMagType); }
      public:
        /// Constructor with initializations
        ns1__CardDataMagType() : header(), body() { }
        virtual ~ns1__CardDataMagType() { }
        /// Friend allocator used by soap_new_ns1__CardDataMagType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CardDataMagType * SOAP_FMAC2 soap_instantiate_ns1__CardDataMagType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:548 */
#ifndef SOAP_TYPE_ns1__cardDataMagHeader
#define SOAP_TYPE_ns1__cardDataMagHeader (132)
/* Type ns1__cardDataMagHeader is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:cardDataMagHeader': */
class SOAP_CMAC ns1__cardDataMagHeader : public xsd__anyType {
      public:
        /// Required element 'version' of XSD type 'xsd:int'
        int version;
        /// Required element 'mediaTypeId' of XSD type 'xsd:int'
        int mediaTypeId;
        /// Required element 'operation' of XSD type 'xsd:int'
        int operation;
        /// Required element 'operationDate' of XSD type 'xsd:dateTime'
        time_t operationDate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__cardDataMagHeader
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__cardDataMagHeader; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__cardDataMagHeader, default initialized and not managed by a soap context
        virtual ns1__cardDataMagHeader *soap_alloc(void) const { return SOAP_NEW(ns1__cardDataMagHeader); }
      public:
        /// Constructor with initializations
        ns1__cardDataMagHeader() : version(), mediaTypeId(), operation(), operationDate() { }
        virtual ~ns1__cardDataMagHeader() { }
        /// Friend allocator used by soap_new_ns1__cardDataMagHeader(struct soap*, int)
        friend SOAP_FMAC1 ns1__cardDataMagHeader * SOAP_FMAC2 soap_instantiate_ns1__cardDataMagHeader(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:551 */
#ifndef SOAP_TYPE_ns1__cardDataMagBody
#define SOAP_TYPE_ns1__cardDataMagBody (133)
/* Type ns1__cardDataMagBody is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:cardDataMagBody': */
class SOAP_CMAC ns1__cardDataMagBody : public xsd__anyType {
      public:
        /// Optional element 'valOp' of XSD type 'ns1:valOpMagType'
        ns1__valOpMagType *valOp;
      public:
        /// Return unique type id SOAP_TYPE_ns1__cardDataMagBody
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__cardDataMagBody; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__cardDataMagBody, default initialized and not managed by a soap context
        virtual ns1__cardDataMagBody *soap_alloc(void) const { return SOAP_NEW(ns1__cardDataMagBody); }
      public:
        /// Constructor with initializations
        ns1__cardDataMagBody() : valOp() { }
        virtual ~ns1__cardDataMagBody() { }
        /// Friend allocator used by soap_new_ns1__cardDataMagBody(struct soap*, int)
        friend SOAP_FMAC1 ns1__cardDataMagBody * SOAP_FMAC2 soap_instantiate_ns1__cardDataMagBody(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:554 */
#ifndef SOAP_TYPE_ns1__valOpMagType
#define SOAP_TYPE_ns1__valOpMagType (134)
/* Type ns1__valOpMagType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:valOpMagType': */
class SOAP_CMAC ns1__valOpMagType : public xsd__anyType {
      public:
        /// Required element 'validationType' of XSD type 'xsd:long'
        LONG64 validationType;
        /// Required element 'product' of XSD type 'xsd:long'
        LONG64 product;
        /// Required element 'profile' of XSD type 'xsd:long'
        LONG64 profile;
        /// Required element 'stopOr' of XSD type 'xsd:long'
        LONG64 stopOr;
        /// Required element 'stopD' of XSD type 'xsd:long'
        LONG64 stopD;
        /// Required element 'deductedAmount' of XSD type 'xsd:long'
        LONG64 deductedAmount;
        /// Required element 'transferLine' of XSD type 'xsd:long'
        LONG64 transferLine;
        /// Required element 'transferNum' of XSD type 'xsd:long'
        LONG64 transferNum;
        /// Optional element 'transferDiscount' of XSD type 'xsd:long'
        LONG64 *transferDiscount;
        /// Optional element 'employee' of XSD type 'xsd:long'
        LONG64 *employee;
      public:
        /// Return unique type id SOAP_TYPE_ns1__valOpMagType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__valOpMagType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__valOpMagType, default initialized and not managed by a soap context
        virtual ns1__valOpMagType *soap_alloc(void) const { return SOAP_NEW(ns1__valOpMagType); }
      public:
        /// Constructor with initializations
        ns1__valOpMagType() : validationType(), product(), profile(), stopOr(), stopD(), deductedAmount(), transferLine(), transferNum(), transferDiscount(), employee() { }
        virtual ~ns1__valOpMagType() { }
        /// Friend allocator used by soap_new_ns1__valOpMagType(struct soap*, int)
        friend SOAP_FMAC1 ns1__valOpMagType * SOAP_FMAC2 soap_instantiate_ns1__valOpMagType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:560 */
#ifndef SOAP_TYPE_ns1__InvoiceReceiptType
#define SOAP_TYPE_ns1__InvoiceReceiptType (136)
/* Type ns1__InvoiceReceiptType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InvoiceReceiptType': */
class SOAP_CMAC ns1__InvoiceReceiptType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'line' of XSD type 'ns1:ReceiptLine' stored in dynamic array line of length __sizeline
        int __sizeline;
        ns1__ReceiptLine **line;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
        /// optional attribute 'number' of XSD type 'xsd:unsignedInt'
        unsigned int *number;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InvoiceReceiptType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InvoiceReceiptType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InvoiceReceiptType, default initialized and not managed by a soap context
        virtual ns1__InvoiceReceiptType *soap_alloc(void) const { return SOAP_NEW(ns1__InvoiceReceiptType); }
      public:
        /// Constructor with initializations
        ns1__InvoiceReceiptType() : __sizeline(), line(), length(), type(), number() { }
        virtual ~ns1__InvoiceReceiptType() { }
        /// Friend allocator used by soap_new_ns1__InvoiceReceiptType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InvoiceReceiptType * SOAP_FMAC2 soap_instantiate_ns1__InvoiceReceiptType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:563 */
#ifndef SOAP_TYPE_ns1__ReceiptLine
#define SOAP_TYPE_ns1__ReceiptLine (137)
/* Type ns1__ReceiptLine is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ReceiptLine': */
class SOAP_CMAC ns1__ReceiptLine : public xsd__anyType {
      public:
        /// Optional element 'leftItem' of XSD type 'ns1:ReceiptItem'
        ns1__ReceiptItem *leftItem;
        /// Optional element 'centerItem' of XSD type 'ns1:ReceiptItem'
        ns1__ReceiptItem *centerItem;
        /// Optional element 'rightItem' of XSD type 'ns1:ReceiptItem'
        ns1__ReceiptItem *rightItem;
        /// optional attribute 'lineNumber' of XSD type 'xsd:unsignedInt'
        unsigned int *lineNumber;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReceiptLine
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReceiptLine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReceiptLine, default initialized and not managed by a soap context
        virtual ns1__ReceiptLine *soap_alloc(void) const { return SOAP_NEW(ns1__ReceiptLine); }
      public:
        /// Constructor with initializations
        ns1__ReceiptLine() : leftItem(), centerItem(), rightItem(), lineNumber() { }
        virtual ~ns1__ReceiptLine() { }
        /// Friend allocator used by soap_new_ns1__ReceiptLine(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReceiptLine * SOAP_FMAC2 soap_instantiate_ns1__ReceiptLine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:572 */
#ifndef SOAP_TYPE_ns1__AccountingOpType
#define SOAP_TYPE_ns1__AccountingOpType (140)
/* Type ns1__AccountingOpType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:AccountingOpType': */
class SOAP_CMAC ns1__AccountingOpType : public xsd__anyType {
      public:
        /// required attribute 'nReq' of XSD type 'xsd:long'
        LONG64 nReq;
        /// required attribute 'nSucc' of XSD type 'xsd:long'
        LONG64 nSucc;
        /// required attribute 'tp' of XSD type 'xsd:long'
        LONG64 tp;
        /// required attribute 'pd' of XSD type 'xsd:long'
        LONG64 pd;
        /// required attribute 'returned' of XSD type 'xsd:long'
        LONG64 returned;
        /// required attribute 'tR' of XSD type 'xsd:long'
        LONG64 tR;
        /// optional attribute 'invoiceNum' of XSD type 'xsd:string'
        char *invoiceNum;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingOpType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingOpType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingOpType, default initialized and not managed by a soap context
        virtual ns1__AccountingOpType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingOpType); }
      public:
        /// Constructor with initializations
        ns1__AccountingOpType() : nReq(), nSucc(), tp(), pd(), returned(), tR(), invoiceNum() { }
        virtual ~ns1__AccountingOpType() { }
        /// Friend allocator used by soap_new_ns1__AccountingOpType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingOpType * SOAP_FMAC2 soap_instantiate_ns1__AccountingOpType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:575 */
#ifndef SOAP_TYPE_ns1__AccountingOperationInfo
#define SOAP_TYPE_ns1__AccountingOperationInfo (141)
/* Type ns1__AccountingOperationInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingOperationInfo': */
class SOAP_CMAC ns1__AccountingOperationInfo : public xsd__anyType {
      public:
        /// Required element 'nReq' of XSD type 'xsd:unsignedInt'
        unsigned int nReq;
        /// Required element 'nSuc' of XSD type 'xsd:unsignedInt'
        unsigned int nSuc;
        /// Required element 'total' of XSD type 'xsd:long'
        LONG64 total;
        /// Required element 'paid' of XSD type 'xsd:long'
        LONG64 paid;
        /// Required element 'returned' of XSD type 'xsd:long'
        LONG64 returned;
        /// Required element 'owed' of XSD type 'xsd:long'
        LONG64 owed;
        /// Optional element 'invoiceNum' of XSD type 'xsd:string'
        char *invoiceNum;
        /// optional attribute 'num' of XSD type 'xsd:string'
        char *num;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingOperationInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingOperationInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingOperationInfo, default initialized and not managed by a soap context
        virtual ns1__AccountingOperationInfo *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingOperationInfo); }
      public:
        /// Constructor with initializations
        ns1__AccountingOperationInfo() : nReq(), nSuc(), total(), paid(), returned(), owed(), invoiceNum(), num() { }
        virtual ~ns1__AccountingOperationInfo() { }
        /// Friend allocator used by soap_new_ns1__AccountingOperationInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingOperationInfo * SOAP_FMAC2 soap_instantiate_ns1__AccountingOperationInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:578 */
#ifndef SOAP_TYPE_ns1__AccountingUnitListType
#define SOAP_TYPE_ns1__AccountingUnitListType (142)
/* Type ns1__AccountingUnitListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingUnitListType': */
class SOAP_CMAC ns1__AccountingUnitListType : public xsd__anyType {
      public:
        /// Sequence of elements 'unit' of XSD type 'ns1:AccountingUnitType' stored in dynamic array unit of length __sizeunit
        int __sizeunit;
        ns1__AccountingUnitType **unit;
        /// Sequence of elements 'accUnit' of XSD type 'ns1:AccountingUnit' stored in dynamic array accUnit of length __sizeaccUnit
        int __sizeaccUnit;
        ns1__AccountingUnit **accUnit;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingUnitListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingUnitListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingUnitListType, default initialized and not managed by a soap context
        virtual ns1__AccountingUnitListType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingUnitListType); }
      public:
        /// Constructor with initializations
        ns1__AccountingUnitListType() : __sizeunit(), unit(), __sizeaccUnit(), accUnit() { }
        virtual ~ns1__AccountingUnitListType() { }
        /// Friend allocator used by soap_new_ns1__AccountingUnitListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingUnitListType * SOAP_FMAC2 soap_instantiate_ns1__AccountingUnitListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:3126 */
#ifndef SOAP_TYPE__ns1__AccountingUnitType_doc
#define SOAP_TYPE__ns1__AccountingUnitType_doc (531)
/* complex XSD type 'ns1:AccountingUnitType-doc': */
class SOAP_CMAC _ns1__AccountingUnitType_doc {
      public:
        /// required attribute 'type' of XSD type 'xsd:unsignedShort'
        unsigned short type;
        /// required attribute 'id' of XSD type 'xsd:string'
        char *id;
        /// required attribute 'name' of XSD type 'xsd:string'
        char *name;
        /// required attribute 'addr' of XSD type 'xsd:string'
        char *addr;
        /// required attribute 'cntNum' of XSD type 'xsd:long'
        LONG64 cntNum;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AccountingUnitType_doc
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AccountingUnitType_doc; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AccountingUnitType_doc, default initialized and not managed by a soap context
        virtual _ns1__AccountingUnitType_doc *soap_alloc(void) const { return SOAP_NEW(_ns1__AccountingUnitType_doc); }
      public:
        /// Constructor with initializations
        _ns1__AccountingUnitType_doc() : type(), id(), name(), addr(), cntNum() { }
        virtual ~_ns1__AccountingUnitType_doc() { }
        /// Friend allocator used by soap_new__ns1__AccountingUnitType_doc(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AccountingUnitType_doc * SOAP_FMAC2 soap_instantiate__ns1__AccountingUnitType_doc(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:3149 */
#ifndef SOAP_TYPE__ns1__AccountingUnitType_mda
#define SOAP_TYPE__ns1__AccountingUnitType_mda (532)
/* complex XSD type 'ns1:AccountingUnitType-mda': */
class SOAP_CMAC _ns1__AccountingUnitType_mda {
      public:
        /// required attribute 't' of XSD type 'xsd:long'
        LONG64 t;
        /// required attribute 'p' of XSD type 'xsd:long'
        LONG64 p;
        /// required attribute 's' of XSD type 'xsd:long'
        LONG64 s;
        /// required attribute 'pr' of XSD type 'xsd:long'
        LONG64 pr;
        /// required attribute 'n' of XSD type 'xsd:long'
        LONG64 n;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AccountingUnitType_mda
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AccountingUnitType_mda; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AccountingUnitType_mda, default initialized and not managed by a soap context
        virtual _ns1__AccountingUnitType_mda *soap_alloc(void) const { return SOAP_NEW(_ns1__AccountingUnitType_mda); }
      public:
        /// Constructor with initializations
        _ns1__AccountingUnitType_mda() : t(), p(), s(), pr(), n() { }
        virtual ~_ns1__AccountingUnitType_mda() { }
        /// Friend allocator used by soap_new__ns1__AccountingUnitType_mda(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AccountingUnitType_mda * SOAP_FMAC2 soap_instantiate__ns1__AccountingUnitType_mda(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:3174 */
#ifndef SOAP_TYPE__ns1__AccountingUnitType_purse
#define SOAP_TYPE__ns1__AccountingUnitType_purse (534)
/* complex XSD type 'ns1:AccountingUnitType-purse': */
class SOAP_CMAC _ns1__AccountingUnitType_purse {
      public:
        /// required attribute 'sr' of XSD type 'xsd:long'
        LONG64 sr;
        /// required attribute 'sv' of XSD type 'xsd:long'
        LONG64 sv;
      public:
        /// Return unique type id SOAP_TYPE__ns1__AccountingUnitType_purse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__AccountingUnitType_purse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__AccountingUnitType_purse, default initialized and not managed by a soap context
        virtual _ns1__AccountingUnitType_purse *soap_alloc(void) const { return SOAP_NEW(_ns1__AccountingUnitType_purse); }
      public:
        /// Constructor with initializations
        _ns1__AccountingUnitType_purse() : sr(), sv() { }
        virtual ~_ns1__AccountingUnitType_purse() { }
        /// Friend allocator used by soap_new__ns1__AccountingUnitType_purse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__AccountingUnitType_purse * SOAP_FMAC2 soap_instantiate__ns1__AccountingUnitType_purse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:581 */
#ifndef SOAP_TYPE_ns1__AccountingUnitType
#define SOAP_TYPE_ns1__AccountingUnitType (143)
/* Type ns1__AccountingUnitType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingUnitType': */
class SOAP_CMAC ns1__AccountingUnitType : public xsd__anyType {
      public:
        /// Required element 'doc' of XSD type 'ns1:AccountingUnitType-doc'
        _ns1__AccountingUnitType_doc doc;
        /// Required element 'mda' of XSD type 'ns1:AccountingUnitType-mda'
        _ns1__AccountingUnitType_mda mda;
        /// Required element 'prd' of XSD type 'ns1:TitleCodeType'
        ns1__TitleCodeType *prd;
        /// Required element 'purse' of XSD type 'ns1:AccountingUnitType-purse'
        _ns1__AccountingUnitType_purse purse;
        /// Optional element 'taxList' of XSD type 'ns1:taxAppliedList'
        ns1__taxAppliedList *taxList;
        /// Required element 'idfSale' of XSD type 'xsd:int'
        int idfSale;
        /// Required element 'smId' of XSD type 'xsd:long'
        LONG64 smId;
        /// Optional element 'entryCode' of XSD type 'xsd:string'
        char *entryCode;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// required attribute 'opT' of XSD type 'xsd:long'
        LONG64 opT;
        /// required attribute 'prc' of XSD type 'xsd:long'
        LONG64 prc;
        /// required attribute 'dps' of XSD type 'xsd:long'
        LONG64 dps;
        /// required attribute 'isTest' of XSD type 'xsd:long'
        LONG64 isTest;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingUnitType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingUnitType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingUnitType, default initialized and not managed by a soap context
        virtual ns1__AccountingUnitType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingUnitType); }
      public:
        /// Constructor with initializations
        ns1__AccountingUnitType() : doc(), mda(), prd(), purse(), taxList(), idfSale(), smId(), entryCode(), ctlInfo(), ctlData(), cData(), rawData(), opT(), prc(), dps(), isTest() { }
        virtual ~ns1__AccountingUnitType() { }
        /// Friend allocator used by soap_new_ns1__AccountingUnitType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingUnitType * SOAP_FMAC2 soap_instantiate_ns1__AccountingUnitType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:584 */
#ifndef SOAP_TYPE_ns1__taxAppliedList
#define SOAP_TYPE_ns1__taxAppliedList (144)
/* Type ns1__taxAppliedList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:taxAppliedList': */
class SOAP_CMAC ns1__taxAppliedList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'tax' of XSD type 'ns1:taxAppliedType' stored in dynamic array tax of length __sizetax
        int __sizetax;
        ns1__taxAppliedType **tax;
        /// required attribute 'amountBase' of XSD type 'xsd:long'
        LONG64 amountBase;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__taxAppliedList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__taxAppliedList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__taxAppliedList, default initialized and not managed by a soap context
        virtual ns1__taxAppliedList *soap_alloc(void) const { return SOAP_NEW(ns1__taxAppliedList); }
      public:
        /// Constructor with initializations
        ns1__taxAppliedList() : __sizetax(), tax(), amountBase(), length() { }
        virtual ~ns1__taxAppliedList() { }
        /// Friend allocator used by soap_new_ns1__taxAppliedList(struct soap*, int)
        friend SOAP_FMAC1 ns1__taxAppliedList * SOAP_FMAC2 soap_instantiate_ns1__taxAppliedList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:587 */
#ifndef SOAP_TYPE_ns1__taxAppliedType
#define SOAP_TYPE_ns1__taxAppliedType (145)
/* Type ns1__taxAppliedType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:taxAppliedType': */
class SOAP_CMAC ns1__taxAppliedType : public xsd__anyType {
      public:
        /// required attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int id;
        /// required attribute 'amountReported' of XSD type 'xsd:long'
        LONG64 amountReported;
      public:
        /// Return unique type id SOAP_TYPE_ns1__taxAppliedType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__taxAppliedType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__taxAppliedType, default initialized and not managed by a soap context
        virtual ns1__taxAppliedType *soap_alloc(void) const { return SOAP_NEW(ns1__taxAppliedType); }
      public:
        /// Constructor with initializations
        ns1__taxAppliedType() : id(), amountReported() { }
        virtual ~ns1__taxAppliedType() { }
        /// Friend allocator used by soap_new_ns1__taxAppliedType(struct soap*, int)
        friend SOAP_FMAC1 ns1__taxAppliedType * SOAP_FMAC2 soap_instantiate_ns1__taxAppliedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:590 */
#ifndef SOAP_TYPE_ns1__AccountingUnit
#define SOAP_TYPE_ns1__AccountingUnit (146)
/* Type ns1__AccountingUnit is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingUnit': */
class SOAP_CMAC ns1__AccountingUnit : public xsd__anyType {
      public:
        /// Required element 'fareInfo' of XSD type 'ns1:FareInfo'
        ns1__FareInfo *fareInfo;
        /// Optional element 'doc' of XSD type 'ns1:IdentificationDocument'
        ns1__IdentificationDocument *doc;
        /// Required element 'accInfo' of XSD type 'ns1:AccountingUnitInfo'
        ns1__AccountingUnitInfo *accInfo;
        /// Optional element 'actionID' of XSD type 'xsd:long'
        LONG64 *actionID;
        /// Optional element 'sam' of XSD type 'xsd:unsignedLong'
        ULONG64 *sam;
        /// Optional element 'card' of XSD type 'ns1:cardIdentificationType'
        ns1__cardIdentificationType *card;
        /// Optional element 'opInfo' of XSD type 'ns1:OperationInfoType'
        ns1__OperationInfoType *opInfo;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingUnit
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingUnit, default initialized and not managed by a soap context
        virtual ns1__AccountingUnit *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingUnit); }
      public:
        /// Constructor with initializations
        ns1__AccountingUnit() : fareInfo(), doc(), accInfo(), actionID(), sam(), card(), opInfo(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__AccountingUnit() { }
        /// Friend allocator used by soap_new_ns1__AccountingUnit(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingUnit * SOAP_FMAC2 soap_instantiate_ns1__AccountingUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:593 */
#ifndef SOAP_TYPE_ns1__IdentificationDocument
#define SOAP_TYPE_ns1__IdentificationDocument (147)
/* Type ns1__IdentificationDocument is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:IdentificationDocument': */
class SOAP_CMAC ns1__IdentificationDocument : public xsd__anyType {
      public:
        /// Required element 'name' of XSD type 'xsd:string'
        char *name;
        /// Required element 'addr' of XSD type 'xsd:string'
        char *addr;
        /// Required element 'contact' of XSD type 'xsd:string'
        char *contact;
        /// required attribute 'type' of XSD type 'xsd:unsignedShort'
        unsigned short type;
        /// required attribute 'id' of XSD type 'xsd:string'
        char *id;
      public:
        /// Return unique type id SOAP_TYPE_ns1__IdentificationDocument
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__IdentificationDocument; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__IdentificationDocument, default initialized and not managed by a soap context
        virtual ns1__IdentificationDocument *soap_alloc(void) const { return SOAP_NEW(ns1__IdentificationDocument); }
      public:
        /// Constructor with initializations
        ns1__IdentificationDocument() : name(), addr(), contact(), type(), id() { }
        virtual ~ns1__IdentificationDocument() { }
        /// Friend allocator used by soap_new_ns1__IdentificationDocument(struct soap*, int)
        friend SOAP_FMAC1 ns1__IdentificationDocument * SOAP_FMAC2 soap_instantiate_ns1__IdentificationDocument(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:596 */
#ifndef SOAP_TYPE_ns1__AccountingUnitInfo
#define SOAP_TYPE_ns1__AccountingUnitInfo (148)
/* Type ns1__AccountingUnitInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingUnitInfo': */
class SOAP_CMAC ns1__AccountingUnitInfo : public xsd__anyType {
      public:
        /// Optional element 'price' of XSD type 'xsd:long'
        LONG64 *price;
        /// Optional element 'deposit' of XSD type 'xsd:unsignedLong'
        ULONG64 *deposit;
        /// Optional element 'taxList' of XSD type 'ns1:taxAppliedList'
        ns1__taxAppliedList *taxList;
        /// Optional element 'entryCode' of XSD type 'xsd:string'
        char *entryCode;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
        /// optional attribute 'test' of XSD type 'xsd:boolean'
        bool *test;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingUnitInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingUnitInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingUnitInfo, default initialized and not managed by a soap context
        virtual ns1__AccountingUnitInfo *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingUnitInfo); }
      public:
        /// Constructor with initializations
        ns1__AccountingUnitInfo() : price(), deposit(), taxList(), entryCode(), type(), test() { }
        virtual ~ns1__AccountingUnitInfo() { }
        /// Friend allocator used by soap_new_ns1__AccountingUnitInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingUnitInfo * SOAP_FMAC2 soap_instantiate_ns1__AccountingUnitInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:599 */
#ifndef SOAP_TYPE_ns1__AccountingFailureListType
#define SOAP_TYPE_ns1__AccountingFailureListType (149)
/* Type ns1__AccountingFailureListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingFailureListType': */
class SOAP_CMAC ns1__AccountingFailureListType : public xsd__anyType {
      public:
        /// Sequence of elements 'failure' of XSD type 'ns1:AccountingFailureType' stored in dynamic array failure of length __sizefailure
        int __sizefailure;
        ns1__AccountingFailureType **failure;
        /// Sequence of elements 'failInfo' of XSD type 'ns1:AccountingFailureInfo' stored in dynamic array failInfo of length __sizefailInfo
        int __sizefailInfo;
        ns1__AccountingFailureInfo **failInfo;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingFailureListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingFailureListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingFailureListType, default initialized and not managed by a soap context
        virtual ns1__AccountingFailureListType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingFailureListType); }
      public:
        /// Constructor with initializations
        ns1__AccountingFailureListType() : __sizefailure(), failure(), __sizefailInfo(), failInfo() { }
        virtual ~ns1__AccountingFailureListType() { }
        /// Friend allocator used by soap_new_ns1__AccountingFailureListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingFailureListType * SOAP_FMAC2 soap_instantiate_ns1__AccountingFailureListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:602 */
#ifndef SOAP_TYPE_ns1__AccountingFailureType
#define SOAP_TYPE_ns1__AccountingFailureType (150)
/* Type ns1__AccountingFailureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingFailureType': */
class SOAP_CMAC ns1__AccountingFailureType : public xsd__anyType {
      public:
        /// Required element 'prd' of XSD type 'ns1:TitleCodeType'
        ns1__TitleCodeType *prd;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// required attribute 'opT' of XSD type 'xsd:long'
        LONG64 opT;
        /// required attribute 'cs' of XSD type 'xsd:long'
        LONG64 cs;
        /// required attribute 'mtype' of XSD type 'xsd:long'
        LONG64 mtype;
        /// required attribute 'isTest' of XSD type 'xsd:long'
        LONG64 isTest;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingFailureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingFailureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingFailureType, default initialized and not managed by a soap context
        virtual ns1__AccountingFailureType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingFailureType); }
      public:
        /// Constructor with initializations
        ns1__AccountingFailureType() : prd(), ctlInfo(), ctlData(), cData(), rawData(), opT(), cs(), mtype(), isTest() { }
        virtual ~ns1__AccountingFailureType() { }
        /// Friend allocator used by soap_new_ns1__AccountingFailureType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingFailureType * SOAP_FMAC2 soap_instantiate_ns1__AccountingFailureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:605 */
#ifndef SOAP_TYPE_ns1__AccountingFailureInfo
#define SOAP_TYPE_ns1__AccountingFailureInfo (151)
/* Type ns1__AccountingFailureInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingFailureInfo': */
class SOAP_CMAC ns1__AccountingFailureInfo : public xsd__anyType {
      public:
        /// Required element 'cause' of XSD type 'xsd:unsignedInt'
        unsigned int cause;
        /// required attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int type;
        /// optional attribute 'test' of XSD type 'xsd:boolean'
        bool *test;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingFailureInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingFailureInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingFailureInfo, default initialized and not managed by a soap context
        virtual ns1__AccountingFailureInfo *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingFailureInfo); }
      public:
        /// Constructor with initializations
        ns1__AccountingFailureInfo() : cause(), type(), test() { }
        virtual ~ns1__AccountingFailureInfo() { }
        /// Friend allocator used by soap_new_ns1__AccountingFailureInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingFailureInfo * SOAP_FMAC2 soap_instantiate_ns1__AccountingFailureInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:608 */
#ifndef SOAP_TYPE_ns1__PaymentModeListType
#define SOAP_TYPE_ns1__PaymentModeListType (152)
/* Type ns1__PaymentModeListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PaymentModeListType': */
class SOAP_CMAC ns1__PaymentModeListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'payment' of XSD type 'ns1:PaymentModeType' stored in dynamic array payment of length __sizepayment
        int __sizepayment;
        ns1__PaymentModeType **payment;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PaymentModeListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PaymentModeListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PaymentModeListType, default initialized and not managed by a soap context
        virtual ns1__PaymentModeListType *soap_alloc(void) const { return SOAP_NEW(ns1__PaymentModeListType); }
      public:
        /// Constructor with initializations
        ns1__PaymentModeListType() : __sizepayment(), payment() { }
        virtual ~ns1__PaymentModeListType() { }
        /// Friend allocator used by soap_new_ns1__PaymentModeListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PaymentModeListType * SOAP_FMAC2 soap_instantiate_ns1__PaymentModeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:611 */
#ifndef SOAP_TYPE_ns1__PaymentModeType
#define SOAP_TYPE_ns1__PaymentModeType (153)
/* Type ns1__PaymentModeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:PaymentModeType': */
class SOAP_CMAC ns1__PaymentModeType : public xsd__anyType {
      public:
        /// required attribute 'mId' of XSD type 'xsd:long'
        LONG64 mId;
        /// required attribute 'amnt' of XSD type 'xsd:long'
        LONG64 amnt;
        /// required attribute 'ref' of XSD type 'xsd:string'
        char *ref;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PaymentModeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PaymentModeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PaymentModeType, default initialized and not managed by a soap context
        virtual ns1__PaymentModeType *soap_alloc(void) const { return SOAP_NEW(ns1__PaymentModeType); }
      public:
        /// Constructor with initializations
        ns1__PaymentModeType() : mId(), amnt(), ref() { }
        virtual ~ns1__PaymentModeType() { }
        /// Friend allocator used by soap_new_ns1__PaymentModeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PaymentModeType * SOAP_FMAC2 soap_instantiate_ns1__PaymentModeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:614 */
#ifndef SOAP_TYPE_ns1__AwardListType
#define SOAP_TYPE_ns1__AwardListType (154)
/* Type ns1__AwardListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AwardListType': */
class SOAP_CMAC ns1__AwardListType : public xsd__anyType {
      public:
        /// Sequence of elements 'award' of XSD type 'ns1:AwardType' stored in dynamic array award of length __sizeaward
        int __sizeaward;
        ns1__AwardType **award;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AwardListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AwardListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AwardListType, default initialized and not managed by a soap context
        virtual ns1__AwardListType *soap_alloc(void) const { return SOAP_NEW(ns1__AwardListType); }
      public:
        /// Constructor with initializations
        ns1__AwardListType() : __sizeaward(), award() { }
        virtual ~ns1__AwardListType() { }
        /// Friend allocator used by soap_new_ns1__AwardListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AwardListType * SOAP_FMAC2 soap_instantiate_ns1__AwardListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:617 */
#ifndef SOAP_TYPE_ns1__AwardType
#define SOAP_TYPE_ns1__AwardType (155)
/* Type ns1__AwardType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:AwardType': */
class SOAP_CMAC ns1__AwardType : public xsd__anyType {
      public:
        /// required attribute 'id' of XSD type 'xsd:long'
        LONG64 id;
        /// required attribute 'ownr' of XSD type 'xsd:long'
        LONG64 ownr;
        /// required attribute 'value' of XSD type 'xsd:long'
        LONG64 value;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AwardType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AwardType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AwardType, default initialized and not managed by a soap context
        virtual ns1__AwardType *soap_alloc(void) const { return SOAP_NEW(ns1__AwardType); }
      public:
        /// Constructor with initializations
        ns1__AwardType() : id(), ownr(), value() { }
        virtual ~ns1__AwardType() { }
        /// Friend allocator used by soap_new_ns1__AwardType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AwardType * SOAP_FMAC2 soap_instantiate_ns1__AwardType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:620 */
#ifndef SOAP_TYPE_ns1__CoinNoteInsertedListType
#define SOAP_TYPE_ns1__CoinNoteInsertedListType (156)
/* Type ns1__CoinNoteInsertedListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CoinNoteInsertedListType': */
class SOAP_CMAC ns1__CoinNoteInsertedListType : public xsd__anyType {
      public:
        /// Sequence of elements 'cni' of XSD type 'ns1:MoneyInsertedFlow' stored in dynamic array cni of length __sizecni
        int __sizecni;
        ns1__MoneyInsertedFlow **cni;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CoinNoteInsertedListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CoinNoteInsertedListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CoinNoteInsertedListType, default initialized and not managed by a soap context
        virtual ns1__CoinNoteInsertedListType *soap_alloc(void) const { return SOAP_NEW(ns1__CoinNoteInsertedListType); }
      public:
        /// Constructor with initializations
        ns1__CoinNoteInsertedListType() : __sizecni(), cni() { }
        virtual ~ns1__CoinNoteInsertedListType() { }
        /// Friend allocator used by soap_new_ns1__CoinNoteInsertedListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CoinNoteInsertedListType * SOAP_FMAC2 soap_instantiate_ns1__CoinNoteInsertedListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:623 */
#ifndef SOAP_TYPE_ns1__MoneyInsertedFlow
#define SOAP_TYPE_ns1__MoneyInsertedFlow (157)
/* Type ns1__MoneyInsertedFlow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:MoneyInsertedFlow': */
class SOAP_CMAC ns1__MoneyInsertedFlow : public xsd__anyType {
      public:
        /// required attribute 'fVal' of XSD type 'xsd:long'
        LONG64 fVal;
        /// required attribute 'amnt' of XSD type 'xsd:long'
        LONG64 amnt;
        /// required attribute 'type' of XSD type 'xsd:int'
        int type;
        /// optional attribute 'hprD' of XSD type 'xsd:long'
        LONG64 *hprD;
        /// optional attribute 'bxD' of XSD type 'xsd:long'
        LONG64 *bxD;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MoneyInsertedFlow
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MoneyInsertedFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MoneyInsertedFlow, default initialized and not managed by a soap context
        virtual ns1__MoneyInsertedFlow *soap_alloc(void) const { return SOAP_NEW(ns1__MoneyInsertedFlow); }
      public:
        /// Constructor with initializations
        ns1__MoneyInsertedFlow() : fVal(), amnt(), type(), hprD(), bxD() { }
        virtual ~ns1__MoneyInsertedFlow() { }
        /// Friend allocator used by soap_new_ns1__MoneyInsertedFlow(struct soap*, int)
        friend SOAP_FMAC1 ns1__MoneyInsertedFlow * SOAP_FMAC2 soap_instantiate_ns1__MoneyInsertedFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:626 */
#ifndef SOAP_TYPE_ns1__CoinNoteReturnedListType
#define SOAP_TYPE_ns1__CoinNoteReturnedListType (158)
/* Type ns1__CoinNoteReturnedListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CoinNoteReturnedListType': */
class SOAP_CMAC ns1__CoinNoteReturnedListType : public xsd__anyType {
      public:
        /// Sequence of elements 'cnr' of XSD type 'ns1:MoneyReturnedFlow' stored in dynamic array cnr of length __sizecnr
        int __sizecnr;
        ns1__MoneyReturnedFlow **cnr;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CoinNoteReturnedListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CoinNoteReturnedListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CoinNoteReturnedListType, default initialized and not managed by a soap context
        virtual ns1__CoinNoteReturnedListType *soap_alloc(void) const { return SOAP_NEW(ns1__CoinNoteReturnedListType); }
      public:
        /// Constructor with initializations
        ns1__CoinNoteReturnedListType() : __sizecnr(), cnr() { }
        virtual ~ns1__CoinNoteReturnedListType() { }
        /// Friend allocator used by soap_new_ns1__CoinNoteReturnedListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CoinNoteReturnedListType * SOAP_FMAC2 soap_instantiate_ns1__CoinNoteReturnedListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:629 */
#ifndef SOAP_TYPE_ns1__MoneyReturnedFlow
#define SOAP_TYPE_ns1__MoneyReturnedFlow (159)
/* Type ns1__MoneyReturnedFlow is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:MoneyReturnedFlow': */
class SOAP_CMAC ns1__MoneyReturnedFlow : public xsd__anyType {
      public:
        /// required attribute 'fVal' of XSD type 'xsd:long'
        LONG64 fVal;
        /// required attribute 'amnt' of XSD type 'xsd:long'
        LONG64 amnt;
        /// required attribute 'type' of XSD type 'xsd:int'
        int type;
        /// required attribute 'hprO' of XSD type 'xsd:long'
        LONG64 hprO;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MoneyReturnedFlow
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MoneyReturnedFlow; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MoneyReturnedFlow, default initialized and not managed by a soap context
        virtual ns1__MoneyReturnedFlow *soap_alloc(void) const { return SOAP_NEW(ns1__MoneyReturnedFlow); }
      public:
        /// Constructor with initializations
        ns1__MoneyReturnedFlow() : fVal(), amnt(), type(), hprO() { }
        virtual ~ns1__MoneyReturnedFlow() { }
        /// Friend allocator used by soap_new_ns1__MoneyReturnedFlow(struct soap*, int)
        friend SOAP_FMAC1 ns1__MoneyReturnedFlow * SOAP_FMAC2 soap_instantiate_ns1__MoneyReturnedFlow(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:632 */
#ifndef SOAP_TYPE_ns1__AccountingReceiptType
#define SOAP_TYPE_ns1__AccountingReceiptType (160)
/* Type ns1__AccountingReceiptType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingReceiptType': */
class SOAP_CMAC ns1__AccountingReceiptType : public xsd__anyType {
      public:
        /// Required element 'receipt' of XSD type 'ns1:InvoiceReceiptType'
        ns1__InvoiceReceiptType *receipt;
        /// Optional element 'hash' of XSD type 'xsd:string'
        char *hash;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingReceiptType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingReceiptType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingReceiptType, default initialized and not managed by a soap context
        virtual ns1__AccountingReceiptType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingReceiptType); }
      public:
        /// Constructor with initializations
        ns1__AccountingReceiptType() : receipt(), hash() { }
        virtual ~ns1__AccountingReceiptType() { }
        /// Friend allocator used by soap_new_ns1__AccountingReceiptType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingReceiptType * SOAP_FMAC2 soap_instantiate_ns1__AccountingReceiptType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:644 */
#ifndef SOAP_TYPE_ns1__dataReportListType
#define SOAP_TYPE_ns1__dataReportListType (164)
/* Type ns1__dataReportListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:dataReportListType': */
class SOAP_CMAC ns1__dataReportListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'dr' of XSD type 'ns1:dataReportType' stored in dynamic array dr of length __sizedr
        int __sizedr;
        ns1__dataReportType **dr;
      public:
        /// Return unique type id SOAP_TYPE_ns1__dataReportListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__dataReportListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__dataReportListType, default initialized and not managed by a soap context
        virtual ns1__dataReportListType *soap_alloc(void) const { return SOAP_NEW(ns1__dataReportListType); }
      public:
        /// Constructor with initializations
        ns1__dataReportListType() : __sizedr(), dr() { }
        virtual ~ns1__dataReportListType() { }
        /// Friend allocator used by soap_new_ns1__dataReportListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__dataReportListType * SOAP_FMAC2 soap_instantiate_ns1__dataReportListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:647 */
#ifndef SOAP_TYPE_ns1__dataReportType
#define SOAP_TYPE_ns1__dataReportType (165)
/* Type ns1__dataReportType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:dataReportType': */
class SOAP_CMAC ns1__dataReportType : public xsd__anyType {
      public:
        /// required attribute 'rTId' of XSD type 'xsd:long'
        LONG64 rTId;
        /// required attribute 'qtty' of XSD type 'xsd:long'
        LONG64 qtty;
      public:
        /// Return unique type id SOAP_TYPE_ns1__dataReportType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__dataReportType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__dataReportType, default initialized and not managed by a soap context
        virtual ns1__dataReportType *soap_alloc(void) const { return SOAP_NEW(ns1__dataReportType); }
      public:
        /// Constructor with initializations
        ns1__dataReportType() : rTId(), qtty() { }
        virtual ~ns1__dataReportType() { }
        /// Friend allocator used by soap_new_ns1__dataReportType(struct soap*, int)
        friend SOAP_FMAC1 ns1__dataReportType * SOAP_FMAC2 soap_instantiate_ns1__dataReportType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:650 */
#ifndef SOAP_TYPE_ns1__SlaveDataReportListType
#define SOAP_TYPE_ns1__SlaveDataReportListType (166)
/* Type ns1__SlaveDataReportListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlaveDataReportListType': */
class SOAP_CMAC ns1__SlaveDataReportListType : public xsd__anyType {
      public:
        /// Sequence of elements 'slaveReport' of XSD type 'ns1:SlaveDataReportType' stored in dynamic array slaveReport of length __sizeslaveReport
        int __sizeslaveReport;
        ns1__SlaveDataReportType **slaveReport;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlaveDataReportListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlaveDataReportListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlaveDataReportListType, default initialized and not managed by a soap context
        virtual ns1__SlaveDataReportListType *soap_alloc(void) const { return SOAP_NEW(ns1__SlaveDataReportListType); }
      public:
        /// Constructor with initializations
        ns1__SlaveDataReportListType() : __sizeslaveReport(), slaveReport(), length() { }
        virtual ~ns1__SlaveDataReportListType() { }
        /// Friend allocator used by soap_new_ns1__SlaveDataReportListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlaveDataReportListType * SOAP_FMAC2 soap_instantiate_ns1__SlaveDataReportListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:653 */
#ifndef SOAP_TYPE_ns1__SlaveDataReportType
#define SOAP_TYPE_ns1__SlaveDataReportType (167)
/* Type ns1__SlaveDataReportType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlaveDataReportType': */
class SOAP_CMAC ns1__SlaveDataReportType : public xsd__anyType {
      public:
        /// Required element 'drL' of XSD type 'ns1:dataReportListType'
        ns1__dataReportListType *drL;
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlaveDataReportType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlaveDataReportType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlaveDataReportType, default initialized and not managed by a soap context
        virtual ns1__SlaveDataReportType *soap_alloc(void) const { return SOAP_NEW(ns1__SlaveDataReportType); }
      public:
        /// Constructor with initializations
        ns1__SlaveDataReportType() : drL(), id() { }
        virtual ~ns1__SlaveDataReportType() { }
        /// Friend allocator used by soap_new_ns1__SlaveDataReportType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlaveDataReportType * SOAP_FMAC2 soap_instantiate_ns1__SlaveDataReportType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:659 */
#ifndef SOAP_TYPE_ns1__missingDataListType
#define SOAP_TYPE_ns1__missingDataListType (169)
/* Type ns1__missingDataListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:missingDataListType': */
class SOAP_CMAC ns1__missingDataListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'miss' of XSD type 'ns1:missingDataType' stored in dynamic array miss of length __sizemiss
        int __sizemiss;
        ns1__missingDataType **miss;
      public:
        /// Return unique type id SOAP_TYPE_ns1__missingDataListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__missingDataListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__missingDataListType, default initialized and not managed by a soap context
        virtual ns1__missingDataListType *soap_alloc(void) const { return SOAP_NEW(ns1__missingDataListType); }
      public:
        /// Constructor with initializations
        ns1__missingDataListType() : __sizemiss(), miss() { }
        virtual ~ns1__missingDataListType() { }
        /// Friend allocator used by soap_new_ns1__missingDataListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__missingDataListType * SOAP_FMAC2 soap_instantiate_ns1__missingDataListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:662 */
#ifndef SOAP_TYPE_ns1__missingDataType
#define SOAP_TYPE_ns1__missingDataType (170)
/* Type ns1__missingDataType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:missingDataType': */
class SOAP_CMAC ns1__missingDataType : public xsd__anyType {
      public:
        /// required attribute 'uS' of XSD type 'xsd:long'
        LONG64 uS;
        /// required attribute 'uSTo' of XSD type 'xsd:long'
        LONG64 uSTo;
      public:
        /// Return unique type id SOAP_TYPE_ns1__missingDataType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__missingDataType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__missingDataType, default initialized and not managed by a soap context
        virtual ns1__missingDataType *soap_alloc(void) const { return SOAP_NEW(ns1__missingDataType); }
      public:
        /// Constructor with initializations
        ns1__missingDataType() : uS(), uSTo() { }
        virtual ~ns1__missingDataType() { }
        /// Friend allocator used by soap_new_ns1__missingDataType(struct soap*, int)
        friend SOAP_FMAC1 ns1__missingDataType * SOAP_FMAC2 soap_instantiate_ns1__missingDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:671 */
#ifndef SOAP_TYPE_ns1__MediaOperationListType
#define SOAP_TYPE_ns1__MediaOperationListType (173)
/* Type ns1__MediaOperationListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaOperationListType': */
class SOAP_CMAC ns1__MediaOperationListType : public xsd__anyType {
      public:
        /// Sequence of elements 'mO' of XSD type 'ns1:MediaOperationType' stored in dynamic array mO of length __sizemO
        int __sizemO;
        ns1__MediaOperationType **mO;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaOperationListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaOperationListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaOperationListType, default initialized and not managed by a soap context
        virtual ns1__MediaOperationListType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaOperationListType); }
      public:
        /// Constructor with initializations
        ns1__MediaOperationListType() : __sizemO(), mO(), length() { }
        virtual ~ns1__MediaOperationListType() { }
        /// Friend allocator used by soap_new_ns1__MediaOperationListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaOperationListType * SOAP_FMAC2 soap_instantiate_ns1__MediaOperationListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:674 */
#ifndef SOAP_TYPE_ns1__MediaOperationType
#define SOAP_TYPE_ns1__MediaOperationType (174)
/* Type ns1__MediaOperationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaOperationType': */
class SOAP_CMAC ns1__MediaOperationType : public xsd__anyType {
      public:
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Required element 'opL' of XSD type 'ns1:OperationListType'
        ns1__OperationListType *opL;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaOperationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaOperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaOperationType, default initialized and not managed by a soap context
        virtual ns1__MediaOperationType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaOperationType); }
      public:
        /// Constructor with initializations
        ns1__MediaOperationType() : mT(), opL() { }
        virtual ~ns1__MediaOperationType() { }
        /// Friend allocator used by soap_new_ns1__MediaOperationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaOperationType * SOAP_FMAC2 soap_instantiate_ns1__MediaOperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:677 */
#ifndef SOAP_TYPE_ns1__OperationListType
#define SOAP_TYPE_ns1__OperationListType (175)
/* Type ns1__OperationListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OperationListType': */
class SOAP_CMAC ns1__OperationListType : public xsd__anyType {
      public:
        /// Sequence of elements 'op' of XSD type 'ns1:OperationType' stored in dynamic array op of length __sizeop
        int __sizeop;
        ns1__OperationType **op;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OperationListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OperationListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OperationListType, default initialized and not managed by a soap context
        virtual ns1__OperationListType *soap_alloc(void) const { return SOAP_NEW(ns1__OperationListType); }
      public:
        /// Constructor with initializations
        ns1__OperationListType() : __sizeop(), op(), length() { }
        virtual ~ns1__OperationListType() { }
        /// Friend allocator used by soap_new_ns1__OperationListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OperationListType * SOAP_FMAC2 soap_instantiate_ns1__OperationListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:680 */
#ifndef SOAP_TYPE_ns1__OperationType
#define SOAP_TYPE_ns1__OperationType (176)
/* Type ns1__OperationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:OperationType': */
class SOAP_CMAC ns1__OperationType : public xsd__anyType {
      public:
        /// required attribute 'opC' of XSD type 'xsd:long'
        LONG64 opC;
        /// required attribute 'prd' of XSD type 'xsd:unsignedShort'
        unsigned short prd;
        /// required attribute 'perNum' of XSD type 'xsd:long'
        LONG64 perNum;
        /// required attribute 'perAmt' of XSD type 'xsd:long'
        LONG64 perAmt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OperationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OperationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OperationType, default initialized and not managed by a soap context
        virtual ns1__OperationType *soap_alloc(void) const { return SOAP_NEW(ns1__OperationType); }
      public:
        /// Constructor with initializations
        ns1__OperationType() : opC(), prd(), perNum(), perAmt() { }
        virtual ~ns1__OperationType() { }
        /// Friend allocator used by soap_new_ns1__OperationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OperationType * SOAP_FMAC2 soap_instantiate_ns1__OperationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:716 */
#ifndef SOAP_TYPE_ns1__SamType
#define SOAP_TYPE_ns1__SamType (188)
/* Type ns1__SamType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:SamType': */
class SOAP_CMAC ns1__SamType : public xsd__anyType {
      public:
        /// optional attribute 'id' of XSD type 'xsd:long'
        LONG64 *id;
        /// optional attribute 'sN' of XSD type 'xsd:long'
        LONG64 *sN;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SamType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SamType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SamType, default initialized and not managed by a soap context
        virtual ns1__SamType *soap_alloc(void) const { return SOAP_NEW(ns1__SamType); }
      public:
        /// Constructor with initializations
        ns1__SamType() : id(), sN() { }
        virtual ~ns1__SamType() { }
        /// Friend allocator used by soap_new_ns1__SamType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SamType * SOAP_FMAC2 soap_instantiate_ns1__SamType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:725 */
#ifndef SOAP_TYPE_ns1__monetaryUnitListType
#define SOAP_TYPE_ns1__monetaryUnitListType (191)
/* Type ns1__monetaryUnitListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:monetaryUnitListType': */
class SOAP_CMAC ns1__monetaryUnitListType : public xsd__anyType {
      public:
        /// Sequence of elements 'unit' of XSD type 'ns1:monetaryUnit' stored in dynamic array unit of length __sizeunit
        int __sizeunit;
        ns1__monetaryUnit **unit;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__monetaryUnitListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__monetaryUnitListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__monetaryUnitListType, default initialized and not managed by a soap context
        virtual ns1__monetaryUnitListType *soap_alloc(void) const { return SOAP_NEW(ns1__monetaryUnitListType); }
      public:
        /// Constructor with initializations
        ns1__monetaryUnitListType() : __sizeunit(), unit(), length() { }
        virtual ~ns1__monetaryUnitListType() { }
        /// Friend allocator used by soap_new_ns1__monetaryUnitListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__monetaryUnitListType * SOAP_FMAC2 soap_instantiate_ns1__monetaryUnitListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:728 */
#ifndef SOAP_TYPE_ns1__monetaryUnit
#define SOAP_TYPE_ns1__monetaryUnit (192)
/* Type ns1__monetaryUnit is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:monetaryUnit': */
class SOAP_CMAC ns1__monetaryUnit : public xsd__anyType {
      public:
        /// optional attribute 'value' of XSD type 'xsd:long'
        LONG64 *value;
        /// optional attribute 'quantity' of XSD type 'xsd:long'
        LONG64 *quantity;
        /// optional attribute 'type' of XSD type 'xsd:int'
        int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__monetaryUnit
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__monetaryUnit; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__monetaryUnit, default initialized and not managed by a soap context
        virtual ns1__monetaryUnit *soap_alloc(void) const { return SOAP_NEW(ns1__monetaryUnit); }
      public:
        /// Constructor with initializations
        ns1__monetaryUnit() : value(), quantity(), type() { }
        virtual ~ns1__monetaryUnit() { }
        /// Friend allocator used by soap_new_ns1__monetaryUnit(struct soap*, int)
        friend SOAP_FMAC1 ns1__monetaryUnit * SOAP_FMAC2 soap_instantiate_ns1__monetaryUnit(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:746 */
#ifndef SOAP_TYPE_ns1__MediaStockListType
#define SOAP_TYPE_ns1__MediaStockListType (198)
/* Type ns1__MediaStockListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaStockListType': */
class SOAP_CMAC ns1__MediaStockListType : public xsd__anyType {
      public:
        /// Sequence of elements 'stock' of XSD type 'ns1:mediaStockType' stored in dynamic array stock of length __sizestock
        int __sizestock;
        ns1__mediaStockType **stock;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaStockListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaStockListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaStockListType, default initialized and not managed by a soap context
        virtual ns1__MediaStockListType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaStockListType); }
      public:
        /// Constructor with initializations
        ns1__MediaStockListType() : __sizestock(), stock() { }
        virtual ~ns1__MediaStockListType() { }
        /// Friend allocator used by soap_new_ns1__MediaStockListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaStockListType * SOAP_FMAC2 soap_instantiate_ns1__MediaStockListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:749 */
#ifndef SOAP_TYPE_ns1__mediaStockType
#define SOAP_TYPE_ns1__mediaStockType (199)
/* Type ns1__mediaStockType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:mediaStockType': */
class SOAP_CMAC ns1__mediaStockType : public xsd__anyType {
      public:
        /// optional attribute 'mT' of XSD type 'xsd:long'
        LONG64 *mT;
        /// optional attribute 'dT' of XSD type 'xsd:long'
        LONG64 *dT;
        /// optional attribute 'dId' of XSD type 'xsd:long'
        LONG64 *dId;
        /// optional attribute 'lotId' of XSD type 'xsd:long'
        LONG64 *lotId;
        /// optional attribute 'qtt' of XSD type 'xsd:long'
        LONG64 *qtt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__mediaStockType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__mediaStockType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__mediaStockType, default initialized and not managed by a soap context
        virtual ns1__mediaStockType *soap_alloc(void) const { return SOAP_NEW(ns1__mediaStockType); }
      public:
        /// Constructor with initializations
        ns1__mediaStockType() : mT(), dT(), dId(), lotId(), qtt() { }
        virtual ~ns1__mediaStockType() { }
        /// Friend allocator used by soap_new_ns1__mediaStockType(struct soap*, int)
        friend SOAP_FMAC1 ns1__mediaStockType * SOAP_FMAC2 soap_instantiate_ns1__mediaStockType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:767 */
#ifndef SOAP_TYPE_ns1__Penalty
#define SOAP_TYPE_ns1__Penalty (205)
/* Type ns1__Penalty is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:Penalty': */
class SOAP_CMAC ns1__Penalty : public xsd__anyType {
      public:
        /// Required element 'amount' of XSD type 'xsd:unsignedLong'
        ULONG64 amount;
        /// Optional element 'code' of XSD type 'xsd:string'
        char *code;
        /// Optional element 'desc' of XSD type 'xsd:string'
        char *desc;
        /// Optional element 'medium' of XSD type 'ns1:FareMediumType'
        ns1__FareMediumType *medium;
        /// Optional element 'invoiceNum' of XSD type 'xsd:string'
        char *invoiceNum;
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Penalty
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Penalty; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Penalty, default initialized and not managed by a soap context
        virtual ns1__Penalty *soap_alloc(void) const { return SOAP_NEW(ns1__Penalty); }
      public:
        /// Constructor with initializations
        ns1__Penalty() : amount(), code(), desc(), medium(), invoiceNum(), id() { }
        virtual ~ns1__Penalty() { }
        /// Friend allocator used by soap_new_ns1__Penalty(struct soap*, int)
        friend SOAP_FMAC1 ns1__Penalty * SOAP_FMAC2 soap_instantiate_ns1__Penalty(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:770 */
#ifndef SOAP_TYPE_ns1__FareMediumType
#define SOAP_TYPE_ns1__FareMediumType (206)
/* Type ns1__FareMediumType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FareMediumType': */
class SOAP_CMAC ns1__FareMediumType : public xsd__anyType {
      public:
        /// Optional element 'cscData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *cscData;
        /// Optional element 'mgnData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *mgnData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
        /// optional attribute 'sn' of XSD type 'xsd:unsignedLong'
        ULONG64 *sn;
        /// optional attribute 'uid' of XSD type 'xsd:unsignedLong'
        ULONG64 *uid;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FareMediumType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FareMediumType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FareMediumType, default initialized and not managed by a soap context
        virtual ns1__FareMediumType *soap_alloc(void) const { return SOAP_NEW(ns1__FareMediumType); }
      public:
        /// Constructor with initializations
        ns1__FareMediumType() : cscData(), mgnData(), rawData(), type(), sn(), uid() { }
        virtual ~ns1__FareMediumType() { }
        /// Friend allocator used by soap_new_ns1__FareMediumType(struct soap*, int)
        friend SOAP_FMAC1 ns1__FareMediumType * SOAP_FMAC2 soap_instantiate_ns1__FareMediumType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:773 */
#ifndef SOAP_TYPE_ns1__PendingPaymentType
#define SOAP_TYPE_ns1__PendingPaymentType (207)
/* Type ns1__PendingPaymentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PendingPaymentType': */
class SOAP_CMAC ns1__PendingPaymentType : public xsd__anyType {
      public:
        /// Required element 'entryCode' of XSD type 'xsd:string'
        char *entryCode;
        /// Required element 'balance' of XSD type 'ns1:PendingPaymentBalanceType'
        ns1__PendingPaymentBalanceType *balance;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PendingPaymentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PendingPaymentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PendingPaymentType, default initialized and not managed by a soap context
        virtual ns1__PendingPaymentType *soap_alloc(void) const { return SOAP_NEW(ns1__PendingPaymentType); }
      public:
        /// Constructor with initializations
        ns1__PendingPaymentType() : entryCode(), balance() { }
        virtual ~ns1__PendingPaymentType() { }
        /// Friend allocator used by soap_new_ns1__PendingPaymentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PendingPaymentType * SOAP_FMAC2 soap_instantiate_ns1__PendingPaymentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:776 */
#ifndef SOAP_TYPE_ns1__PendingPaymentBalanceType
#define SOAP_TYPE_ns1__PendingPaymentBalanceType (208)
/* Type ns1__PendingPaymentBalanceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PendingPaymentBalanceType': */
class SOAP_CMAC ns1__PendingPaymentBalanceType : public xsd__anyType {
      public:
        /// Required element 'amount' of XSD type 'xsd:long'
        LONG64 amount;
        /// Optional element 'card' of XSD type 'ns1:cardIdentificationType'
        ns1__cardIdentificationType *card;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PendingPaymentBalanceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PendingPaymentBalanceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PendingPaymentBalanceType, default initialized and not managed by a soap context
        virtual ns1__PendingPaymentBalanceType *soap_alloc(void) const { return SOAP_NEW(ns1__PendingPaymentBalanceType); }
      public:
        /// Constructor with initializations
        ns1__PendingPaymentBalanceType() : amount(), card(), type() { }
        virtual ~ns1__PendingPaymentBalanceType() { }
        /// Friend allocator used by soap_new_ns1__PendingPaymentBalanceType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PendingPaymentBalanceType * SOAP_FMAC2 soap_instantiate_ns1__PendingPaymentBalanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:782 */
#ifndef SOAP_TYPE_ns1__PenaltyType
#define SOAP_TYPE_ns1__PenaltyType (210)
/* Type ns1__PenaltyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PenaltyType': */
class SOAP_CMAC ns1__PenaltyType : public xsd__anyType {
      public:
        /// Required element 'reason' of XSD type 'xsd:long'
        LONG64 reason;
        /// Required element 'desc' of XSD type 'xsd:string'
        char *desc;
        /// Required element 'amount' of XSD type 'xsd:long'
        LONG64 amount;
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// Required element 'unit' of XSD type 'ns1:AccountingUnitType'
        ns1__AccountingUnitType *unit;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PenaltyType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PenaltyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PenaltyType, default initialized and not managed by a soap context
        virtual ns1__PenaltyType *soap_alloc(void) const { return SOAP_NEW(ns1__PenaltyType); }
      public:
        /// Constructor with initializations
        ns1__PenaltyType() : reason(), desc(), amount(), mT(), ctlInfo(), ctlData(), cData(), rawData(), unit() { }
        virtual ~ns1__PenaltyType() { }
        /// Friend allocator used by soap_new_ns1__PenaltyType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PenaltyType * SOAP_FMAC2 soap_instantiate_ns1__PenaltyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:800 */
#ifndef SOAP_TYPE_ns1__ActionListType
#define SOAP_TYPE_ns1__ActionListType (216)
/* Type ns1__ActionListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ActionListType': */
class SOAP_CMAC ns1__ActionListType : public xsd__anyType {
      public:
        /// Sequence of elements 'action' of XSD type 'ns1:ActionType' stored in dynamic array action of length __sizeaction
        int __sizeaction;
        ns1__ActionType **action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ActionListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionListType, default initialized and not managed by a soap context
        virtual ns1__ActionListType *soap_alloc(void) const { return SOAP_NEW(ns1__ActionListType); }
      public:
        /// Constructor with initializations
        ns1__ActionListType() : __sizeaction(), action() { }
        virtual ~ns1__ActionListType() { }
        /// Friend allocator used by soap_new_ns1__ActionListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionListType * SOAP_FMAC2 soap_instantiate_ns1__ActionListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:803 */
#ifndef SOAP_TYPE_ns1__ActionType
#define SOAP_TYPE_ns1__ActionType (217)
/* Type ns1__ActionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ActionType': */
class SOAP_CMAC ns1__ActionType : public xsd__anyType {
      public:
        /// Required element 'idL' of XSD type 'xsd:long'
        LONG64 idL;
        /// Optional element 'idTarget' of XSD type 'xsd:long'
        LONG64 *idTarget;
        /// Optional element 'idEntry' of XSD type 'xsd:long'
        LONG64 *idEntry;
        /// Optional element 'idSequence' of XSD type 'xsd:long'
        LONG64 *idSequence;
        /// Optional element 'idSelector' of XSD type 'xsd:long'
        LONG64 *idSelector;
        /// Optional element 'dRun' of XSD type 'xsd:dateTime'
        time_t *dRun;
        /// Optional element 'reasonId' of XSD type 'xsd:unsignedInt'
        unsigned int *reasonId;
        /// Optional element 'actionType' of XSD type 'xsd:unsignedInt'
        unsigned int *actionType;
        /// Optional element 'relTrans' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *relTrans;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ActionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionType, default initialized and not managed by a soap context
        virtual ns1__ActionType *soap_alloc(void) const { return SOAP_NEW(ns1__ActionType); }
      public:
        /// Constructor with initializations
        ns1__ActionType() : idL(), idTarget(), idEntry(), idSequence(), idSelector(), dRun(), reasonId(), actionType(), relTrans(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__ActionType() { }
        /// Friend allocator used by soap_new_ns1__ActionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionType * SOAP_FMAC2 soap_instantiate_ns1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:842 */
#ifndef SOAP_TYPE_ns1__ParkingValidationInfo
#define SOAP_TYPE_ns1__ParkingValidationInfo (230)
/* Type ns1__ParkingValidationInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ParkingValidationInfo': */
class SOAP_CMAC ns1__ParkingValidationInfo : public xsd__anyType {
      public:
        /// Required element 'type' of XSD type 'xsd:unsignedInt'
        unsigned int type;
        /// Required element 'rslt' of XSD type 'xsd:unsignedInt'
        unsigned int rslt;
        /// Required element 'veh' of XSD type 'ns1:Vehicle'
        ns1__Vehicle *veh;
        /// optional attribute 'test' of XSD type 'xsd:boolean'
        bool *test;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ParkingValidationInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ParkingValidationInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ParkingValidationInfo, default initialized and not managed by a soap context
        virtual ns1__ParkingValidationInfo *soap_alloc(void) const { return SOAP_NEW(ns1__ParkingValidationInfo); }
      public:
        /// Constructor with initializations
        ns1__ParkingValidationInfo() : type(), rslt(), veh(), test() { }
        virtual ~ns1__ParkingValidationInfo() { }
        /// Friend allocator used by soap_new_ns1__ParkingValidationInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__ParkingValidationInfo * SOAP_FMAC2 soap_instantiate_ns1__ParkingValidationInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:845 */
#ifndef SOAP_TYPE_ns1__Vehicle
#define SOAP_TYPE_ns1__Vehicle (231)
/* Type ns1__Vehicle is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:Vehicle': */
class SOAP_CMAC ns1__Vehicle : public xsd__anyType {
      public:
        /// required attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int type;
        /// optional attribute 'plate' of XSD type 'xsd:string'
        char *plate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Vehicle
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Vehicle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Vehicle, default initialized and not managed by a soap context
        virtual ns1__Vehicle *soap_alloc(void) const { return SOAP_NEW(ns1__Vehicle); }
      public:
        /// Constructor with initializations
        ns1__Vehicle() : type(), plate() { }
        virtual ~ns1__Vehicle() { }
        /// Friend allocator used by soap_new_ns1__Vehicle(struct soap*, int)
        friend SOAP_FMAC1 ns1__Vehicle * SOAP_FMAC2 soap_instantiate_ns1__Vehicle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:851 */
#ifndef SOAP_TYPE_ns1__SignedRecordType
#define SOAP_TYPE_ns1__SignedRecordType (233)
/* Type ns1__SignedRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SignedRecordType': */
class SOAP_CMAC ns1__SignedRecordType : public xsd__anyType {
      public:
        /// Required element 'record' of XSD type 'ns1:UnsignedRecordType'
        ns1__UnsignedRecordType *record;
        /// Required element 'signature' of XSD type 'xsd:anyType'
        xsd__anyType *signature;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SignedRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SignedRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SignedRecordType, default initialized and not managed by a soap context
        virtual ns1__SignedRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__SignedRecordType); }
      public:
        /// Constructor with initializations
        ns1__SignedRecordType() : record(), signature() { }
        virtual ~ns1__SignedRecordType() { }
        /// Friend allocator used by soap_new_ns1__SignedRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SignedRecordType * SOAP_FMAC2 soap_instantiate_ns1__SignedRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:857 */
#ifndef SOAP_TYPE_ns1__TransactionMTCRegTypeList
#define SOAP_TYPE_ns1__TransactionMTCRegTypeList (235)
/* Type ns1__TransactionMTCRegTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionMTCRegTypeList': */
class SOAP_CMAC ns1__TransactionMTCRegTypeList : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:TransactionMTCRegType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__TransactionMTCRegType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionMTCRegTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionMTCRegTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionMTCRegTypeList, default initialized and not managed by a soap context
        virtual ns1__TransactionMTCRegTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionMTCRegTypeList); }
      public:
        /// Constructor with initializations
        ns1__TransactionMTCRegTypeList() : __sizeitems(), items() { }
        virtual ~ns1__TransactionMTCRegTypeList() { }
        /// Friend allocator used by soap_new_ns1__TransactionMTCRegTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionMTCRegTypeList * SOAP_FMAC2 soap_instantiate_ns1__TransactionMTCRegTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:860 */
#ifndef SOAP_TYPE_ns1__TransactionMTCRegType
#define SOAP_TYPE_ns1__TransactionMTCRegType (236)
/* Type ns1__TransactionMTCRegType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionMTCRegType': */
class SOAP_CMAC ns1__TransactionMTCRegType : public xsd__anyType {
      public:
        /// Optional element 'unsignedReg' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *unsignedReg;
        /// Optional element 'unsignedRegType' of XSD type 'ns1:MTC_UnsignedTransactionRegType'
        ns1__MTC_USCOREUnsignedTransactionRegType *unsignedRegType;
        /// Optional element 'signedReg' of XSD type 'ns1:SignedTransactionMTCRegType'
        ns1__SignedTransactionMTCRegType *signedReg;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionMTCRegType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionMTCRegType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionMTCRegType, default initialized and not managed by a soap context
        virtual ns1__TransactionMTCRegType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionMTCRegType); }
      public:
        /// Constructor with initializations
        ns1__TransactionMTCRegType() : unsignedReg(), unsignedRegType(), signedReg() { }
        virtual ~ns1__TransactionMTCRegType() { }
        /// Friend allocator used by soap_new_ns1__TransactionMTCRegType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionMTCRegType * SOAP_FMAC2 soap_instantiate_ns1__TransactionMTCRegType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:4281 */
#ifndef SOAP_TYPE__ns1__union_MTC_USCOREUnsignedTransactionRegType
#define SOAP_TYPE__ns1__union_MTC_USCOREUnsignedTransactionRegType (597)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_MTC_USCOREUnsignedTransactionRegType
{
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_susFabrication	(1)	/**< union variant selector value for member susFabrication */
        ns1__MTC_USCOREFabricationSusContentType *susFabrication;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_susInitialization	(2)	/**< union variant selector value for member susInitialization */
        ns1__MTC_USCOREInitializationSusContentType *susInitialization;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_appInstance	(3)	/**< union variant selector value for member appInstance */
        ns1__MTC_USCOREInstanceAppContentType *appInstance;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_appEdit	(4)	/**< union variant selector value for member appEdit */
        ns1__MTC_USCOREEditAppContentType *appEdit;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_prfInstance	(5)	/**< union variant selector value for member prfInstance */
        ns1__MTC_USCOREInstanceProfileContentType *prfInstance;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_prfEdit	(6)	/**< union variant selector value for member prfEdit */
        ns1__MTC_USCOREEditProfileContentType *prfEdit;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_prfDelete	(7)	/**< union variant selector value for member prfDelete */
        ns1__MTC_USCOREDeleteProfileContentType *prfDelete;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titInstance	(8)	/**< union variant selector value for member titInstance */
        ns1__MTC_USCOREInstanceTitleContentType *titInstance;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titRecharge	(9)	/**< union variant selector value for member titRecharge */
        ns1__MTC_USCORERechargeTitleContentType *titRecharge;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titValidation	(10)	/**< union variant selector value for member titValidation */
        ns1__MTC_USCOREValidationTitleContentType *titValidation;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titEdit	(11)	/**< union variant selector value for member titEdit */
        ns1__MTC_USCOREEditTitleContentType *titEdit;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titRestitution	(12)	/**< union variant selector value for member titRestitution */
        ns1__MTC_USCORERestitutionTitleContentType *titRestitution;
        #define SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_actionExec	(13)	/**< union variant selector value for member actionExec */
        ns1__MTC_USCOREActionExecutedContentType *actionExec;
};
#endif

/* sopa.h:863 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREUnsignedTransactionRegType
#define SOAP_TYPE_ns1__MTC_USCOREUnsignedTransactionRegType (237)
/* Type ns1__MTC_USCOREUnsignedTransactionRegType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_UnsignedTransactionRegType': */
class SOAP_CMAC ns1__MTC_USCOREUnsignedTransactionRegType : public xsd__anyType {
      public:
        /// Union with union _ns1__union_MTC_USCOREUnsignedTransactionRegType variant selector __union_MTC_USCOREUnsignedTransactionRegType set to one of: SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_susFabrication SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_susInitialization SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_appInstance SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_appEdit SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_prfInstance SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_prfEdit SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_prfDelete SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titInstance SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titRecharge SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titValidation SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titEdit SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_titRestitution SOAP_UNION__ns1__union_MTC_USCOREUnsignedTransactionRegType_actionExec
        int __union_MTC_USCOREUnsignedTransactionRegType;
        union _ns1__union_MTC_USCOREUnsignedTransactionRegType union_MTC_USCOREUnsignedTransactionRegType;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREUnsignedTransactionRegType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREUnsignedTransactionRegType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREUnsignedTransactionRegType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREUnsignedTransactionRegType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREUnsignedTransactionRegType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREUnsignedTransactionRegType() : __union_MTC_USCOREUnsignedTransactionRegType() { }
        virtual ~ns1__MTC_USCOREUnsignedTransactionRegType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREUnsignedTransactionRegType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREUnsignedTransactionRegType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREUnsignedTransactionRegType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:869 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREBaseTransactionType
#define SOAP_TYPE_ns1__MTC_USCOREBaseTransactionType (239)
/* Type ns1__MTC_USCOREBaseTransactionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_BaseTransactionType': */
class SOAP_CMAC ns1__MTC_USCOREBaseTransactionType : public xsd__anyType {
      public:
        /// Required element 'id' of XSD type 'ns1:MTC_TransactionIdType'
        ns1__MTC_USCORETransactionIdType *id;
        /// Required element 'date_time' of XSD type 'xsd:dateTime'
        time_t date_USCOREtime;
        /// Required element 'loc' of XSD type 'ns1:MTC_LocationType'
        ns1__MTC_USCORELocationType *loc;
        /// Required element 'od_id' of XSD type 'xsd:unsignedLong'
        ULONG64 od_USCOREid;
        /// Optional element 'cv' of XSD type 'ns1:MTC_ConfigVersionTypeList'
        ns1__MTC_USCOREConfigVersionTypeList *cv;
        /// Optional element 'equip' of XSD type 'ns1:MTC_EquipmentInfoType'
        ns1__MTC_USCOREEquipmentInfoType *equip;
        /// Sequence of elements 'log' of XSD type 'ns1:MTC_LogValueType' stored in dynamic array log of length __sizelog
        int __sizelog;
        ns1__MTC_USCORELogValueType **log;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREBaseTransactionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREBaseTransactionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREBaseTransactionType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREBaseTransactionType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREBaseTransactionType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREBaseTransactionType() : id(), date_USCOREtime(), loc(), od_USCOREid(), cv(), equip(), __sizelog(), log() { }
        virtual ~ns1__MTC_USCOREBaseTransactionType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREBaseTransactionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREBaseTransactionType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREBaseTransactionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:872 */
#ifndef SOAP_TYPE_ns1__MTC_USCORELocationType
#define SOAP_TYPE_ns1__MTC_USCORELocationType (240)
/* Type ns1__MTC_USCORELocationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_LocationType': */
class SOAP_CMAC ns1__MTC_USCORELocationType : public xsd__anyType {
      public:
        /// Optional element 'network' of XSD type 'ns1:MTC_NetworkLocationType'
        ns1__MTC_USCORENetworkLocationType *network;
        /// Optional element 'other' of XSD type 'ns1:MTC_OtherPoint'
        ns1__MTC_USCOREOtherPoint *other;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORELocationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORELocationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORELocationType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORELocationType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORELocationType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORELocationType() : network(), other() { }
        virtual ~ns1__MTC_USCORELocationType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORELocationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORELocationType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORELocationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:875 */
#ifndef SOAP_TYPE_ns1__MTC_USCORENetworkLocationType
#define SOAP_TYPE_ns1__MTC_USCORENetworkLocationType (241)
/* Type ns1__MTC_USCORENetworkLocationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_NetworkLocationType': */
class SOAP_CMAC ns1__MTC_USCORENetworkLocationType : public xsd__anyType {
      public:
        /// Required element 'logicalZone' of XSD type 'xsd:unsignedInt'
        unsigned int logicalZone;
        /// Required element 'company' of XSD type 'xsd:unsignedInt'
        unsigned int company;
        /// Optional element 'accessOnStation' of XSD type 'ns1:MTC_OnStationAccessPointType'
        ns1__MTC_USCOREOnStationAccessPointType *accessOnStation;
        /// Optional element 'accessOnBoard' of XSD type 'ns1:MTC_OnBoardAccessPointType'
        ns1__MTC_USCOREOnBoardAccessPointType *accessOnBoard;
        /// Optional element 'sellOnStation' of XSD type 'ns1:MTC_OnStationSellPointType'
        ns1__MTC_USCOREOnStationSellPointType *sellOnStation;
        /// Optional element 'sellOnBoard' of XSD type 'ns1:MTC_OnBoardSellPointType'
        ns1__MTC_USCOREOnBoardSellPointType *sellOnBoard;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORENetworkLocationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORENetworkLocationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORENetworkLocationType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORENetworkLocationType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORENetworkLocationType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORENetworkLocationType() : logicalZone(), company(), accessOnStation(), accessOnBoard(), sellOnStation(), sellOnBoard() { }
        virtual ~ns1__MTC_USCORENetworkLocationType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORENetworkLocationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORENetworkLocationType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORENetworkLocationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:878 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnStationAccessPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnStationAccessPointType (242)
/* Type ns1__MTC_USCOREOnStationAccessPointType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_OnStationAccessPointType': */
class SOAP_CMAC ns1__MTC_USCOREOnStationAccessPointType : public xsd__anyType {
      public:
        /// Required element 'station' of XSD type 'xsd:unsignedInt'
        unsigned int station;
        /// Required element 'hall' of XSD type 'xsd:unsignedInt'
        unsigned int hall;
        /// Required element 'position' of XSD type 'xsd:unsignedInt'
        unsigned int position;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREOnStationAccessPointType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREOnStationAccessPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREOnStationAccessPointType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREOnStationAccessPointType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREOnStationAccessPointType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREOnStationAccessPointType() : station(), hall(), position() { }
        virtual ~ns1__MTC_USCOREOnStationAccessPointType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREOnStationAccessPointType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREOnStationAccessPointType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREOnStationAccessPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:881 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnBoardAccessPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnBoardAccessPointType (243)
/* Type ns1__MTC_USCOREOnBoardAccessPointType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_OnBoardAccessPointType': */
class SOAP_CMAC ns1__MTC_USCOREOnBoardAccessPointType : public xsd__anyType {
      public:
        /// Required element 'line' of XSD type 'xsd:unsignedInt'
        unsigned int line;
        /// Required element 'itinerary' of XSD type 'xsd:unsignedInt'
        unsigned int itinerary;
        /// Required element 'way' of XSD type 'xsd:unsignedInt'
        unsigned int way;
        /// Required element 'stop' of XSD type 'xsd:unsignedInt'
        unsigned int stop;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREOnBoardAccessPointType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREOnBoardAccessPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREOnBoardAccessPointType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREOnBoardAccessPointType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREOnBoardAccessPointType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREOnBoardAccessPointType() : line(), itinerary(), way(), stop() { }
        virtual ~ns1__MTC_USCOREOnBoardAccessPointType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREOnBoardAccessPointType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREOnBoardAccessPointType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREOnBoardAccessPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:884 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnStationSellPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnStationSellPointType (244)
/* Type ns1__MTC_USCOREOnStationSellPointType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_OnStationSellPointType': */
class SOAP_CMAC ns1__MTC_USCOREOnStationSellPointType : public xsd__anyType {
      public:
        /// Required element 'station' of XSD type 'xsd:unsignedInt'
        unsigned int station;
        /// Required element 'hall' of XSD type 'xsd:unsignedInt'
        unsigned int hall;
        /// Required element 'position' of XSD type 'xsd:unsignedInt'
        unsigned int position;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREOnStationSellPointType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREOnStationSellPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREOnStationSellPointType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREOnStationSellPointType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREOnStationSellPointType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREOnStationSellPointType() : station(), hall(), position() { }
        virtual ~ns1__MTC_USCOREOnStationSellPointType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREOnStationSellPointType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREOnStationSellPointType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREOnStationSellPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:887 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnBoardSellPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnBoardSellPointType (245)
/* Type ns1__MTC_USCOREOnBoardSellPointType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_OnBoardSellPointType': */
class SOAP_CMAC ns1__MTC_USCOREOnBoardSellPointType : public xsd__anyType {
      public:
        /// Required element 'line' of XSD type 'xsd:unsignedInt'
        unsigned int line;
        /// Required element 'itinerary' of XSD type 'xsd:unsignedInt'
        unsigned int itinerary;
        /// Required element 'way' of XSD type 'xsd:unsignedInt'
        unsigned int way;
        /// Required element 'stop' of XSD type 'xsd:unsignedInt'
        unsigned int stop;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREOnBoardSellPointType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREOnBoardSellPointType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREOnBoardSellPointType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREOnBoardSellPointType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREOnBoardSellPointType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREOnBoardSellPointType() : line(), itinerary(), way(), stop() { }
        virtual ~ns1__MTC_USCOREOnBoardSellPointType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREOnBoardSellPointType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREOnBoardSellPointType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREOnBoardSellPointType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:890 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOtherPoint
#define SOAP_TYPE_ns1__MTC_USCOREOtherPoint (246)
/* Type ns1__MTC_USCOREOtherPoint is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_OtherPoint': */
class SOAP_CMAC ns1__MTC_USCOREOtherPoint : public xsd__anyType {
      public:
        /// Required element 'pointType' of XSD type 'xsd:unsignedShort'
        unsigned short pointType;
        /// Required element 'pointId' of XSD type 'xsd:unsignedInt'
        unsigned int pointId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREOtherPoint
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREOtherPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREOtherPoint, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREOtherPoint *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREOtherPoint); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREOtherPoint() : pointType(), pointId() { }
        virtual ~ns1__MTC_USCOREOtherPoint() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREOtherPoint(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREOtherPoint * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREOtherPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:893 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREConfigVersionTypeList
#define SOAP_TYPE_ns1__MTC_USCOREConfigVersionTypeList (247)
/* Type ns1__MTC_USCOREConfigVersionTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_ConfigVersionTypeList': */
class SOAP_CMAC ns1__MTC_USCOREConfigVersionTypeList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'cv' of XSD type 'ns1:MTC_ConfigVersionType' stored in dynamic array cv of length __sizecv
        int __sizecv;
        ns1__MTC_USCOREConfigVersionType **cv;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREConfigVersionTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREConfigVersionTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREConfigVersionTypeList, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREConfigVersionTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREConfigVersionTypeList); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREConfigVersionTypeList() : __sizecv(), cv() { }
        virtual ~ns1__MTC_USCOREConfigVersionTypeList() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREConfigVersionTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREConfigVersionTypeList * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREConfigVersionTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:896 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREConfigVersionType
#define SOAP_TYPE_ns1__MTC_USCOREConfigVersionType (248)
/* Type ns1__MTC_USCOREConfigVersionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:MTC_ConfigVersionType': */
class SOAP_CMAC ns1__MTC_USCOREConfigVersionType : public xsd__anyType {
      public:
        /// required attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int id;
        /// required attribute 'v' of XSD type 'xsd:unsignedInt'
        unsigned int v;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREConfigVersionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREConfigVersionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREConfigVersionType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREConfigVersionType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREConfigVersionType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREConfigVersionType() : id(), v() { }
        virtual ~ns1__MTC_USCOREConfigVersionType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREConfigVersionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREConfigVersionType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREConfigVersionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:899 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEquipmentInfoType
#define SOAP_TYPE_ns1__MTC_USCOREEquipmentInfoType (249)
/* Type ns1__MTC_USCOREEquipmentInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_EquipmentInfoType': */
class SOAP_CMAC ns1__MTC_USCOREEquipmentInfoType : public xsd__anyType {
      public:
        /// Required element 'cctiuId' of XSD type 'xsd:unsignedInt'
        unsigned int cctiuId;
        /// Required element 'operationId' of XSD type 'xsd:unsignedInt'
        unsigned int operationId;
        /// Required element 'session_id' of XSD type 'xsd:unsignedInt'
        unsigned int session_USCOREid;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREEquipmentInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREEquipmentInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREEquipmentInfoType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREEquipmentInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREEquipmentInfoType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREEquipmentInfoType() : cctiuId(), operationId(), session_USCOREid() { }
        virtual ~ns1__MTC_USCOREEquipmentInfoType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREEquipmentInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREEquipmentInfoType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREEquipmentInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:902 */
#ifndef SOAP_TYPE_ns1__MTC_USCORELogValueType
#define SOAP_TYPE_ns1__MTC_USCORELogValueType (250)
/* Type ns1__MTC_USCORELogValueType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_LogValueType': */
class SOAP_CMAC ns1__MTC_USCORELogValueType : public xsd__anyType {
      public:
        /// Required element 'field' of XSD type 'xsd:unsignedInt'
        unsigned int field;
        /// Required element 'value' of XSD type 'ns1:ValueType'
        ns1__ValueType *value;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORELogValueType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORELogValueType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORELogValueType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORELogValueType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORELogValueType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORELogValueType() : field(), value() { }
        virtual ~ns1__MTC_USCORELogValueType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORELogValueType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORELogValueType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORELogValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:911 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREApplicationInfoType
#define SOAP_TYPE_ns1__MTC_USCOREApplicationInfoType (253)
/* Type ns1__MTC_USCOREApplicationInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_ApplicationInfoType': */
class SOAP_CMAC ns1__MTC_USCOREApplicationInfoType : public xsd__anyType {
      public:
        /// Required element 'version' of XSD type 'xsd:unsignedInt'
        unsigned int version;
        /// Required element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short status;
        /// Required element 'userType' of XSD type 'xsd:unsignedShort'
        unsigned short userType;
        /// Required element 'validity' of XSD type 'ns1:MTC_RangeDateType'
        ns1__MTC_USCORERangeDateType *validity;
        /// Required element 'numTransac' of XSD type 'xsd:unsignedLong'
        ULONG64 numTransac;
        /// Required element 'isCommited' of XSD type 'xsd:boolean'
        bool isCommited;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREApplicationInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREApplicationInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREApplicationInfoType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREApplicationInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREApplicationInfoType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREApplicationInfoType() : version(), status(), userType(), validity(), numTransac(), isCommited() { }
        virtual ~ns1__MTC_USCOREApplicationInfoType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREApplicationInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREApplicationInfoType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREApplicationInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:914 */
#ifndef SOAP_TYPE_ns1__MTC_USCORERangeDateType
#define SOAP_TYPE_ns1__MTC_USCORERangeDateType (254)
/* Type ns1__MTC_USCORERangeDateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_RangeDateType': */
class SOAP_CMAC ns1__MTC_USCORERangeDateType : public xsd__anyType {
      public:
        /// Required element 'start' of XSD type 'xsd:date'
        char *start;
        /// Required element 'end' of XSD type 'xsd:date'
        char *end;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORERangeDateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORERangeDateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORERangeDateType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORERangeDateType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORERangeDateType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORERangeDateType() : start(), end() { }
        virtual ~ns1__MTC_USCORERangeDateType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORERangeDateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORERangeDateType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORERangeDateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:917 */
#ifndef SOAP_TYPE_ns1__ActionIdType
#define SOAP_TYPE_ns1__ActionIdType (255)
/* Type ns1__ActionIdType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ActionIdType': */
class SOAP_CMAC ns1__ActionIdType : public xsd__anyType {
      public:
        /// optional attribute 'class' of XSD type 'xsd:integer'
        char *class_;
        /// optional attribute 'sequence' of XSD type 'xsd:unsignedLong'
        ULONG64 *sequence;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionIdType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ActionIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionIdType, default initialized and not managed by a soap context
        virtual ns1__ActionIdType *soap_alloc(void) const { return SOAP_NEW(ns1__ActionIdType); }
      public:
        /// Constructor with initializations
        ns1__ActionIdType() : class_(), sequence() { }
        virtual ~ns1__ActionIdType() { }
        /// Friend allocator used by soap_new_ns1__ActionIdType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionIdType * SOAP_FMAC2 soap_instantiate_ns1__ActionIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:926 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREProfileInfoType
#define SOAP_TYPE_ns1__MTC_USCOREProfileInfoType (258)
/* Type ns1__MTC_USCOREProfileInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_ProfileInfoType': */
class SOAP_CMAC ns1__MTC_USCOREProfileInfoType : public xsd__anyType {
      public:
        /// Required element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short status;
        /// Required element 'validity' of XSD type 'ns1:MTC_RangeDateType'
        ns1__MTC_USCORERangeDateType *validity;
        /// Required element 'position' of XSD type 'xsd:unsignedInt'
        unsigned int position;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREProfileInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREProfileInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREProfileInfoType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREProfileInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREProfileInfoType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREProfileInfoType() : status(), validity(), position() { }
        virtual ~ns1__MTC_USCOREProfileInfoType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREProfileInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREProfileInfoType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREProfileInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:938 */
#ifndef SOAP_TYPE_ns1__ProductIdType
#define SOAP_TYPE_ns1__ProductIdType (262)
/* Type ns1__ProductIdType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ProductIdType': */
class SOAP_CMAC ns1__ProductIdType : public xsd__anyType {
      public:
        /// Required element 'Owner' of XSD type 'xsd:unsignedInt'
        unsigned int Owner;
        /// Required element 'Code' of XSD type 'xsd:unsignedInt'
        unsigned int Code;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ProductIdType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ProductIdType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ProductIdType, default initialized and not managed by a soap context
        virtual ns1__ProductIdType *soap_alloc(void) const { return SOAP_NEW(ns1__ProductIdType); }
      public:
        /// Constructor with initializations
        ns1__ProductIdType() : Owner(), Code() { }
        virtual ~ns1__ProductIdType() { }
        /// Friend allocator used by soap_new_ns1__ProductIdType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ProductIdType * SOAP_FMAC2 soap_instantiate_ns1__ProductIdType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:941 */
#ifndef SOAP_TYPE_ns1__MTC_USCORETitleInfoType
#define SOAP_TYPE_ns1__MTC_USCORETitleInfoType (263)
/* Type ns1__MTC_USCORETitleInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_TitleInfoType': */
class SOAP_CMAC ns1__MTC_USCORETitleInfoType : public xsd__anyType {
      public:
        /// Required element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short status;
        /// Required element 'cargas' of XSD type 'ns1:MTC_TitleLoadContainerInfoListType'
        ns1__MTC_USCORETitleLoadContainerInfoListType *cargas;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORETitleInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORETitleInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORETitleInfoType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORETitleInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORETitleInfoType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORETitleInfoType() : status(), cargas() { }
        virtual ~ns1__MTC_USCORETitleInfoType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORETitleInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORETitleInfoType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORETitleInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:944 */
#ifndef SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoListType
#define SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoListType (264)
/* Type ns1__MTC_USCORETitleLoadContainerInfoListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_TitleLoadContainerInfoListType': */
class SOAP_CMAC ns1__MTC_USCORETitleLoadContainerInfoListType : public xsd__anyType {
      public:
        /// Sequence of elements 'carga' of XSD type 'ns1:MTC_TitleLoadContainerInfoType' stored in dynamic array carga of length __sizecarga
        int __sizecarga;
        ns1__MTC_USCORETitleLoadContainerInfoType **carga;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORETitleLoadContainerInfoListType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORETitleLoadContainerInfoListType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORETitleLoadContainerInfoListType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORETitleLoadContainerInfoListType() : __sizecarga(), carga() { }
        virtual ~ns1__MTC_USCORETitleLoadContainerInfoListType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORETitleLoadContainerInfoListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORETitleLoadContainerInfoListType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORETitleLoadContainerInfoListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:947 */
#ifndef SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoType
#define SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoType (265)
/* Type ns1__MTC_USCORETitleLoadContainerInfoType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_TitleLoadContainerInfoType': */
class SOAP_CMAC ns1__MTC_USCORETitleLoadContainerInfoType : public xsd__anyType {
      public:
        /// Required element 'isActived' of XSD type 'xsd:boolean'
        bool isActived;
        /// Required element 'loadDate' of XSD type 'xsd:date'
        char *loadDate;
        /// Required element 'totalAmount' of XSD type 'ns1:MTC_QuantityType'
        ns1__MTC_USCOREQuantityType *totalAmount;
        /// Required element 'firstUse' of XSD type 'ns1:MTC_RangeDateType'
        ns1__MTC_USCORERangeDateType *firstUse;
        /// Required element 'validity' of XSD type 'ns1:MTC_RangeDateType'
        ns1__MTC_USCORERangeDateType *validity;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORETitleLoadContainerInfoType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORETitleLoadContainerInfoType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORETitleLoadContainerInfoType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORETitleLoadContainerInfoType() : isActived(), loadDate(), totalAmount(), firstUse(), validity() { }
        virtual ~ns1__MTC_USCORETitleLoadContainerInfoType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORETitleLoadContainerInfoType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORETitleLoadContainerInfoType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORETitleLoadContainerInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:950 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREQuantityType
#define SOAP_TYPE_ns1__MTC_USCOREQuantityType (266)
/* Type ns1__MTC_USCOREQuantityType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_QuantityType': */
class SOAP_CMAC ns1__MTC_USCOREQuantityType : public xsd__anyType {
      public:
        /// Required element 'units' of XSD type 'xsd:string'
        char *units;
        /// Required element 'quantity' of XSD type 'xsd:unsignedInt'
        unsigned int quantity;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREQuantityType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREQuantityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREQuantityType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREQuantityType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREQuantityType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREQuantityType() : units(), quantity() { }
        virtual ~ns1__MTC_USCOREQuantityType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREQuantityType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREQuantityType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREQuantityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:959 */
#ifndef SOAP_TYPE_ns1__MTC_USCORETMobilitatCurveType
#define SOAP_TYPE_ns1__MTC_USCORETMobilitatCurveType (269)
/* Type ns1__MTC_USCORETMobilitatCurveType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_TMobilitatCurveType': */
class SOAP_CMAC ns1__MTC_USCORETMobilitatCurveType : public xsd__anyType {
      public:
        /// Required element 'date' of XSD type 'xsd:date'
        char *date;
        /// Sequence of elements 'count' of XSD type 'xsd:unsignedInt' stored in dynamic array count of length __sizecount
        int __sizecount;
        unsigned int *count;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORETMobilitatCurveType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORETMobilitatCurveType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORETMobilitatCurveType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORETMobilitatCurveType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORETMobilitatCurveType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORETMobilitatCurveType() : date(), __sizecount(), count() { }
        virtual ~ns1__MTC_USCORETMobilitatCurveType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORETMobilitatCurveType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORETMobilitatCurveType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORETMobilitatCurveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:971 */
#ifndef SOAP_TYPE_ns1__SignedTransactionMTCRegType
#define SOAP_TYPE_ns1__SignedTransactionMTCRegType (273)
/* Type ns1__SignedTransactionMTCRegType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SignedTransactionMTCRegType': */
class SOAP_CMAC ns1__SignedTransactionMTCRegType : public xsd__anyType {
      public:
        /// Optional element 'register' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *register_;
        /// Optional element 'registerType' of XSD type 'ns1:MTC_UnsignedTransactionRegType'
        ns1__MTC_USCOREUnsignedTransactionRegType *registerType;
        /// Required element 'signature' of XSD type 'xsd:base64Binary'
        xsd__base64Binary signature;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SignedTransactionMTCRegType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SignedTransactionMTCRegType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SignedTransactionMTCRegType, default initialized and not managed by a soap context
        virtual ns1__SignedTransactionMTCRegType *soap_alloc(void) const { return SOAP_NEW(ns1__SignedTransactionMTCRegType); }
      public:
        /// Constructor with initializations
        ns1__SignedTransactionMTCRegType() : register_(), registerType(), signature() { }
        virtual ~ns1__SignedTransactionMTCRegType() { }
        /// Friend allocator used by soap_new_ns1__SignedTransactionMTCRegType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SignedTransactionMTCRegType * SOAP_FMAC2 soap_instantiate_ns1__SignedTransactionMTCRegType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:977 */
#ifndef SOAP_TYPE_ns1__InfoFERecordMTCType
#define SOAP_TYPE_ns1__InfoFERecordMTCType (275)
/* Type ns1__InfoFERecordMTCType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InfoFERecordMTCType': */
class SOAP_CMAC ns1__InfoFERecordMTCType : public xsd__anyType {
      public:
        /// Required element 'location' of XSD type 'ns1:LocationType'
        ns1__LocationType *location;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InfoFERecordMTCType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InfoFERecordMTCType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InfoFERecordMTCType, default initialized and not managed by a soap context
        virtual ns1__InfoFERecordMTCType *soap_alloc(void) const { return SOAP_NEW(ns1__InfoFERecordMTCType); }
      public:
        /// Constructor with initializations
        ns1__InfoFERecordMTCType() : location() { }
        virtual ~ns1__InfoFERecordMTCType() { }
        /// Friend allocator used by soap_new_ns1__InfoFERecordMTCType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InfoFERecordMTCType * SOAP_FMAC2 soap_instantiate_ns1__InfoFERecordMTCType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:983 */
#ifndef SOAP_TYPE_ns1__stateType
#define SOAP_TYPE_ns1__stateType (277)
/* Type ns1__stateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:stateType': */
class SOAP_CMAC ns1__stateType : public xsd__anyType {
      public:
        /// Required element 'workingMode' of XSD type 'xsd:int'
        int workingMode;
        /// Required element 'stationMode' of XSD type 'xsd:int'
        int stationMode;
        /// Required element 'deviceList' of XSD type 'ns1:DeviceListType'
        ns1__DeviceListType *deviceList;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmListType'
        ns1__AlarmListType *alarmList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stateType, default initialized and not managed by a soap context
        virtual ns1__stateType *soap_alloc(void) const { return SOAP_NEW(ns1__stateType); }
      public:
        /// Constructor with initializations
        ns1__stateType() : workingMode(), stationMode(), deviceList(), alarmList() { }
        virtual ~ns1__stateType() { }
        /// Friend allocator used by soap_new_ns1__stateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stateType * SOAP_FMAC2 soap_instantiate_ns1__stateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:986 */
#ifndef SOAP_TYPE_ns1__DeviceListType
#define SOAP_TYPE_ns1__DeviceListType (278)
/* Type ns1__DeviceListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DeviceListType': */
class SOAP_CMAC ns1__DeviceListType : public xsd__anyType {
      public:
        /// Sequence of elements 'device' of XSD type 'ns1:DeviceType' stored in dynamic array device of length __sizedevice
        int __sizedevice;
        ns1__DeviceType **device;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DeviceListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DeviceListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DeviceListType, default initialized and not managed by a soap context
        virtual ns1__DeviceListType *soap_alloc(void) const { return SOAP_NEW(ns1__DeviceListType); }
      public:
        /// Constructor with initializations
        ns1__DeviceListType() : __sizedevice(), device(), length() { }
        virtual ~ns1__DeviceListType() { }
        /// Friend allocator used by soap_new_ns1__DeviceListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DeviceListType * SOAP_FMAC2 soap_instantiate_ns1__DeviceListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:989 */
#ifndef SOAP_TYPE_ns1__DeviceType
#define SOAP_TYPE_ns1__DeviceType (279)
/* Type ns1__DeviceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DeviceType': */
class SOAP_CMAC ns1__DeviceType : public xsd__anyType {
      public:
        /// Optional element 'version' of XSD type 'xsd:long'
        LONG64 *version;
        /// Required element 'deviceCode' of XSD type 'xsd:long'
        LONG64 deviceCode;
        /// Required element 'serialNumber' of XSD type 'xsd:long'
        LONG64 serialNumber;
        /// Required element 'state' of XSD type 'xsd:long'
        LONG64 state;
        /// Optional element 'stationId' of XSD type 'xsd:long'
        LONG64 *stationId;
        /// Optional element 'measureList' of XSD type 'ns1:MeasureListType'
        ns1__MeasureListType *measureList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DeviceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DeviceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DeviceType, default initialized and not managed by a soap context
        virtual ns1__DeviceType *soap_alloc(void) const { return SOAP_NEW(ns1__DeviceType); }
      public:
        /// Constructor with initializations
        ns1__DeviceType() : version(), deviceCode(), serialNumber(), state(), stationId(), measureList() { }
        virtual ~ns1__DeviceType() { }
        /// Friend allocator used by soap_new_ns1__DeviceType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DeviceType * SOAP_FMAC2 soap_instantiate_ns1__DeviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:992 */
#ifndef SOAP_TYPE_ns1__MeasureListType
#define SOAP_TYPE_ns1__MeasureListType (280)
/* Type ns1__MeasureListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MeasureListType': */
class SOAP_CMAC ns1__MeasureListType : public xsd__anyType {
      public:
        /// Sequence of elements 'value' of XSD type 'ns1:MeasureType' stored in dynamic array value of length __sizevalue
        int __sizevalue;
        ns1__MeasureType **value;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MeasureListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MeasureListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MeasureListType, default initialized and not managed by a soap context
        virtual ns1__MeasureListType *soap_alloc(void) const { return SOAP_NEW(ns1__MeasureListType); }
      public:
        /// Constructor with initializations
        ns1__MeasureListType() : __sizevalue(), value(), length() { }
        virtual ~ns1__MeasureListType() { }
        /// Friend allocator used by soap_new_ns1__MeasureListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MeasureListType * SOAP_FMAC2 soap_instantiate_ns1__MeasureListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:998 */
#ifndef SOAP_TYPE_ns1__AlarmListType
#define SOAP_TYPE_ns1__AlarmListType (282)
/* Type ns1__AlarmListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AlarmListType': */
class SOAP_CMAC ns1__AlarmListType : public xsd__anyType {
      public:
        /// Sequence of elements 'alarm' of XSD type 'ns1:AlarmType' stored in dynamic array alarm of length __sizealarm
        int __sizealarm;
        ns1__AlarmType **alarm;
        /// optional attribute 'length' of XSD type 'xsd:unsignedInt'
        unsigned int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AlarmListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AlarmListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AlarmListType, default initialized and not managed by a soap context
        virtual ns1__AlarmListType *soap_alloc(void) const { return SOAP_NEW(ns1__AlarmListType); }
      public:
        /// Constructor with initializations
        ns1__AlarmListType() : __sizealarm(), alarm(), length() { }
        virtual ~ns1__AlarmListType() { }
        /// Friend allocator used by soap_new_ns1__AlarmListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AlarmListType * SOAP_FMAC2 soap_instantiate_ns1__AlarmListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1001 */
#ifndef SOAP_TYPE_ns1__AlarmType
#define SOAP_TYPE_ns1__AlarmType (283)
/* Type ns1__AlarmType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AlarmType': */
class SOAP_CMAC ns1__AlarmType : public xsd__anyType {
      public:
        /// Required element 'version' of XSD type 'xsd:long'
        LONG64 version;
        /// Required element 'alarmCode' of XSD type 'xsd:long'
        LONG64 alarmCode;
        /// Required element 'deviceCode' of XSD type 'xsd:long'
        LONG64 deviceCode;
        /// Required element 'level' of XSD type 'xsd:unsignedInt'
        unsigned int level;
        /// Required element 'deactivated' of XSD type 'xsd:long'
        LONG64 deactivated;
        /// Required element 'date' of XSD type 'xsd:dateTime'
        time_t date;
        /// Required element 'description' of XSD type 'xsd:string'
        char *description;
        /// Required element 'openingDate' of XSD type 'xsd:dateTime'
        time_t openingDate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AlarmType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AlarmType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AlarmType, default initialized and not managed by a soap context
        virtual ns1__AlarmType *soap_alloc(void) const { return SOAP_NEW(ns1__AlarmType); }
      public:
        /// Constructor with initializations
        ns1__AlarmType() : version(), alarmCode(), deviceCode(), level(), deactivated(), date(), description(), openingDate() { }
        virtual ~ns1__AlarmType() { }
        /// Friend allocator used by soap_new_ns1__AlarmType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AlarmType * SOAP_FMAC2 soap_instantiate_ns1__AlarmType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1007 */
#ifndef SOAP_TYPE_ns1__SlaveStateListType
#define SOAP_TYPE_ns1__SlaveStateListType (285)
/* Type ns1__SlaveStateListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlaveStateListType': */
class SOAP_CMAC ns1__SlaveStateListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'slave' of XSD type 'ns1:SlaveStateType' stored in dynamic array slave of length __sizeslave
        int __sizeslave;
        ns1__SlaveStateType **slave;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlaveStateListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlaveStateListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlaveStateListType, default initialized and not managed by a soap context
        virtual ns1__SlaveStateListType *soap_alloc(void) const { return SOAP_NEW(ns1__SlaveStateListType); }
      public:
        /// Constructor with initializations
        ns1__SlaveStateListType() : __sizeslave(), slave() { }
        virtual ~ns1__SlaveStateListType() { }
        /// Friend allocator used by soap_new_ns1__SlaveStateListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlaveStateListType * SOAP_FMAC2 soap_instantiate_ns1__SlaveStateListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1013 */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUListType
#define SOAP_TYPE_ns1__AlarmCCTIUListType (287)
/* Type ns1__AlarmCCTIUListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AlarmCCTIUListType': */
class SOAP_CMAC ns1__AlarmCCTIUListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:AlarmCCTIUType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__AlarmCCTIUType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AlarmCCTIUListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AlarmCCTIUListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AlarmCCTIUListType, default initialized and not managed by a soap context
        virtual ns1__AlarmCCTIUListType *soap_alloc(void) const { return SOAP_NEW(ns1__AlarmCCTIUListType); }
      public:
        /// Constructor with initializations
        ns1__AlarmCCTIUListType() : __sizeitems(), items() { }
        virtual ~ns1__AlarmCCTIUListType() { }
        /// Friend allocator used by soap_new_ns1__AlarmCCTIUListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AlarmCCTIUListType * SOAP_FMAC2 soap_instantiate_ns1__AlarmCCTIUListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1016 */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUType
#define SOAP_TYPE_ns1__AlarmCCTIUType (288)
/* Type ns1__AlarmCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AlarmCCTIUType': */
class SOAP_CMAC ns1__AlarmCCTIUType : public xsd__anyType {
      public:
        /// Required element 'value' of XSD type 'xsd:string'
        char *value;
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// optional attribute 'item' of XSD type 'xsd:unsignedInt'
        unsigned int *item;
        /// optional attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int *code;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AlarmCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AlarmCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AlarmCCTIUType, default initialized and not managed by a soap context
        virtual ns1__AlarmCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__AlarmCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__AlarmCCTIUType() : value(), dateTime(), item(), code() { }
        virtual ~ns1__AlarmCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__AlarmCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AlarmCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__AlarmCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1022 */
#ifndef SOAP_TYPE_ns1__StatusCCTIUListType
#define SOAP_TYPE_ns1__StatusCCTIUListType (290)
/* Type ns1__StatusCCTIUListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StatusCCTIUListType': */
class SOAP_CMAC ns1__StatusCCTIUListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:StatusCCTIUType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__StatusCCTIUType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StatusCCTIUListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StatusCCTIUListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StatusCCTIUListType, default initialized and not managed by a soap context
        virtual ns1__StatusCCTIUListType *soap_alloc(void) const { return SOAP_NEW(ns1__StatusCCTIUListType); }
      public:
        /// Constructor with initializations
        ns1__StatusCCTIUListType() : __sizeitems(), items() { }
        virtual ~ns1__StatusCCTIUListType() { }
        /// Friend allocator used by soap_new_ns1__StatusCCTIUListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StatusCCTIUListType * SOAP_FMAC2 soap_instantiate_ns1__StatusCCTIUListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1025 */
#ifndef SOAP_TYPE_ns1__StatusCCTIUType
#define SOAP_TYPE_ns1__StatusCCTIUType (291)
/* Type ns1__StatusCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StatusCCTIUType': */
class SOAP_CMAC ns1__StatusCCTIUType : public xsd__anyType {
      public:
        /// Required element 'value' of XSD type 'xsd:unsignedInt'
        unsigned int value;
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// optional attribute 'item' of XSD type 'xsd:unsignedInt'
        unsigned int *item;
        /// optional attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int *code;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StatusCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StatusCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StatusCCTIUType, default initialized and not managed by a soap context
        virtual ns1__StatusCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__StatusCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__StatusCCTIUType() : value(), dateTime(), item(), code() { }
        virtual ~ns1__StatusCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__StatusCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StatusCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__StatusCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1031 */
#ifndef SOAP_TYPE_ns1__DiagnosticCCTIUListType
#define SOAP_TYPE_ns1__DiagnosticCCTIUListType (293)
/* Type ns1__DiagnosticCCTIUListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DiagnosticCCTIUListType': */
class SOAP_CMAC ns1__DiagnosticCCTIUListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:DiagnosticCCTIUType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__DiagnosticCCTIUType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DiagnosticCCTIUListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DiagnosticCCTIUListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DiagnosticCCTIUListType, default initialized and not managed by a soap context
        virtual ns1__DiagnosticCCTIUListType *soap_alloc(void) const { return SOAP_NEW(ns1__DiagnosticCCTIUListType); }
      public:
        /// Constructor with initializations
        ns1__DiagnosticCCTIUListType() : __sizeitems(), items() { }
        virtual ~ns1__DiagnosticCCTIUListType() { }
        /// Friend allocator used by soap_new_ns1__DiagnosticCCTIUListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DiagnosticCCTIUListType * SOAP_FMAC2 soap_instantiate_ns1__DiagnosticCCTIUListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1034 */
#ifndef SOAP_TYPE_ns1__DiagnosticCCTIUType
#define SOAP_TYPE_ns1__DiagnosticCCTIUType (294)
/* Type ns1__DiagnosticCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DiagnosticCCTIUType': */
class SOAP_CMAC ns1__DiagnosticCCTIUType : public xsd__anyType {
      public:
        /// Required element 'value' of XSD type 'ns1:ValueType'
        ns1__ValueType *value;
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// optional attribute 'item' of XSD type 'xsd:unsignedInt'
        unsigned int *item;
        /// optional attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int *code;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DiagnosticCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DiagnosticCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DiagnosticCCTIUType, default initialized and not managed by a soap context
        virtual ns1__DiagnosticCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__DiagnosticCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__DiagnosticCCTIUType() : value(), dateTime(), item(), code() { }
        virtual ~ns1__DiagnosticCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__DiagnosticCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DiagnosticCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__DiagnosticCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1040 */
#ifndef SOAP_TYPE_ns1__VersionsCCTIUType
#define SOAP_TYPE_ns1__VersionsCCTIUType (296)
/* Type ns1__VersionsCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:VersionsCCTIUType': */
class SOAP_CMAC ns1__VersionsCCTIUType : public xsd__anyType {
      public:
        /// Required element 'fw' of XSD type 'ns1:VersionFW_HWListType'
        ns1__VersionFW_USCOREHWListType *fw;
        /// Required element 'hw' of XSD type 'ns1:VersionFW_HWListType'
        ns1__VersionFW_USCOREHWListType *hw;
        /// Required element 'cfg' of XSD type 'ns1:VersionCfgListType'
        ns1__VersionCfgListType *cfg;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionsCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionsCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionsCCTIUType, default initialized and not managed by a soap context
        virtual ns1__VersionsCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionsCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__VersionsCCTIUType() : fw(), hw(), cfg() { }
        virtual ~ns1__VersionsCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__VersionsCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionsCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__VersionsCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1043 */
#ifndef SOAP_TYPE_ns1__VersionFW_USCOREHWListType
#define SOAP_TYPE_ns1__VersionFW_USCOREHWListType (297)
/* Type ns1__VersionFW_USCOREHWListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:VersionFW_HWListType': */
class SOAP_CMAC ns1__VersionFW_USCOREHWListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:VersionFW_HWType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__VersionFW_USCOREHWType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionFW_USCOREHWListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionFW_USCOREHWListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionFW_USCOREHWListType, default initialized and not managed by a soap context
        virtual ns1__VersionFW_USCOREHWListType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionFW_USCOREHWListType); }
      public:
        /// Constructor with initializations
        ns1__VersionFW_USCOREHWListType() : __sizeitems(), items() { }
        virtual ~ns1__VersionFW_USCOREHWListType() { }
        /// Friend allocator used by soap_new_ns1__VersionFW_USCOREHWListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionFW_USCOREHWListType * SOAP_FMAC2 soap_instantiate_ns1__VersionFW_USCOREHWListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1046 */
#ifndef SOAP_TYPE_ns1__VersionFW_USCOREHWType
#define SOAP_TYPE_ns1__VersionFW_USCOREHWType (298)
/* Type ns1__VersionFW_USCOREHWType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:VersionFW_HWType': */
class SOAP_CMAC ns1__VersionFW_USCOREHWType : public xsd__anyType {
      public:
        /// Required element 'value' of XSD type 'xsd:string'
        char *value;
        /// optional attribute 'item' of XSD type 'xsd:unsignedInt'
        unsigned int *item;
        /// optional attribute 'code' of XSD type 'xsd:unsignedInt'
        unsigned int *code;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionFW_USCOREHWType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionFW_USCOREHWType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionFW_USCOREHWType, default initialized and not managed by a soap context
        virtual ns1__VersionFW_USCOREHWType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionFW_USCOREHWType); }
      public:
        /// Constructor with initializations
        ns1__VersionFW_USCOREHWType() : value(), item(), code() { }
        virtual ~ns1__VersionFW_USCOREHWType() { }
        /// Friend allocator used by soap_new_ns1__VersionFW_USCOREHWType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionFW_USCOREHWType * SOAP_FMAC2 soap_instantiate_ns1__VersionFW_USCOREHWType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1049 */
#ifndef SOAP_TYPE_ns1__VersionCfgListType
#define SOAP_TYPE_ns1__VersionCfgListType (299)
/* Type ns1__VersionCfgListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:VersionCfgListType': */
class SOAP_CMAC ns1__VersionCfgListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'pkg' of XSD type 'ns1:VersionCfgType' stored in dynamic array pkg of length __sizepkg
        int __sizepkg;
        ns1__VersionCfgType **pkg;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionCfgListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionCfgListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionCfgListType, default initialized and not managed by a soap context
        virtual ns1__VersionCfgListType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionCfgListType); }
      public:
        /// Constructor with initializations
        ns1__VersionCfgListType() : __sizepkg(), pkg() { }
        virtual ~ns1__VersionCfgListType() { }
        /// Friend allocator used by soap_new_ns1__VersionCfgListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionCfgListType * SOAP_FMAC2 soap_instantiate_ns1__VersionCfgListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1052 */
#ifndef SOAP_TYPE_ns1__VersionCfgType
#define SOAP_TYPE_ns1__VersionCfgType (300)
/* Type ns1__VersionCfgType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:VersionCfgType': */
class SOAP_CMAC ns1__VersionCfgType : public xsd__anyType {
      public:
        /// Optional element 'elementList' of XSD type 'ns1:VersionElementCfgListType'
        ns1__VersionElementCfgListType *elementList;
        /// optional attribute 'current' of XSD type 'xsd:boolean'
        bool *current;
        /// optional attribute 'owner' of XSD type 'xsd:unsignedInt'
        unsigned int *owner;
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
        /// optional attribute 'version' of XSD type 'xsd:unsignedInt'
        unsigned int *version;
        /// optional attribute 'name' of XSD type 'xsd:string'
        char *name;
        /// optional attribute 'activation' of XSD type 'xsd:dateTime'
        time_t *activation;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionCfgType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionCfgType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionCfgType, default initialized and not managed by a soap context
        virtual ns1__VersionCfgType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionCfgType); }
      public:
        /// Constructor with initializations
        ns1__VersionCfgType() : elementList(), current(), owner(), id(), version(), name(), activation() { }
        virtual ~ns1__VersionCfgType() { }
        /// Friend allocator used by soap_new_ns1__VersionCfgType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionCfgType * SOAP_FMAC2 soap_instantiate_ns1__VersionCfgType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1055 */
#ifndef SOAP_TYPE_ns1__VersionElementCfgListType
#define SOAP_TYPE_ns1__VersionElementCfgListType (301)
/* Type ns1__VersionElementCfgListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:VersionElementCfgListType': */
class SOAP_CMAC ns1__VersionElementCfgListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'element' of XSD type 'ns1:VersionElementCfgType' stored in dynamic array element of length __sizeelement
        int __sizeelement;
        ns1__VersionElementCfgType **element;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionElementCfgListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionElementCfgListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionElementCfgListType, default initialized and not managed by a soap context
        virtual ns1__VersionElementCfgListType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionElementCfgListType); }
      public:
        /// Constructor with initializations
        ns1__VersionElementCfgListType() : __sizeelement(), element() { }
        virtual ~ns1__VersionElementCfgListType() { }
        /// Friend allocator used by soap_new_ns1__VersionElementCfgListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionElementCfgListType * SOAP_FMAC2 soap_instantiate_ns1__VersionElementCfgListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1058 */
#ifndef SOAP_TYPE_ns1__VersionElementCfgType
#define SOAP_TYPE_ns1__VersionElementCfgType (302)
/* Type ns1__VersionElementCfgType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:VersionElementCfgType': */
class SOAP_CMAC ns1__VersionElementCfgType : public xsd__anyType {
      public:
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
        /// optional attribute 'version' of XSD type 'xsd:unsignedInt'
        unsigned int *version;
        /// optional attribute 'name' of XSD type 'xsd:string'
        char *name;
      public:
        /// Return unique type id SOAP_TYPE_ns1__VersionElementCfgType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__VersionElementCfgType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__VersionElementCfgType, default initialized and not managed by a soap context
        virtual ns1__VersionElementCfgType *soap_alloc(void) const { return SOAP_NEW(ns1__VersionElementCfgType); }
      public:
        /// Constructor with initializations
        ns1__VersionElementCfgType() : id(), version(), name() { }
        virtual ~ns1__VersionElementCfgType() { }
        /// Friend allocator used by soap_new_ns1__VersionElementCfgType(struct soap*, int)
        friend SOAP_FMAC1 ns1__VersionElementCfgType * SOAP_FMAC2 soap_instantiate_ns1__VersionElementCfgType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1073 */
#ifndef SOAP_TYPE_ns1__InfoFEMonitorCCTIUType
#define SOAP_TYPE_ns1__InfoFEMonitorCCTIUType (307)
/* Type ns1__InfoFEMonitorCCTIUType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InfoFEMonitorCCTIUType': */
class SOAP_CMAC ns1__InfoFEMonitorCCTIUType : public xsd__anyType {
      public:
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// Required element 'location' of XSD type 'ns1:LocationType'
        ns1__LocationType *location;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InfoFEMonitorCCTIUType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InfoFEMonitorCCTIUType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InfoFEMonitorCCTIUType, default initialized and not managed by a soap context
        virtual ns1__InfoFEMonitorCCTIUType *soap_alloc(void) const { return SOAP_NEW(ns1__InfoFEMonitorCCTIUType); }
      public:
        /// Constructor with initializations
        ns1__InfoFEMonitorCCTIUType() : dateTime(), location() { }
        virtual ~ns1__InfoFEMonitorCCTIUType() { }
        /// Friend allocator used by soap_new_ns1__InfoFEMonitorCCTIUType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InfoFEMonitorCCTIUType * SOAP_FMAC2 soap_instantiate_ns1__InfoFEMonitorCCTIUType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1097 */
#ifndef SOAP_TYPE_ns1__SlavePresentationResponseListType
#define SOAP_TYPE_ns1__SlavePresentationResponseListType (315)
/* Type ns1__SlavePresentationResponseListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlavePresentationResponseListType': */
class SOAP_CMAC ns1__SlavePresentationResponseListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'slaveResponse' of XSD type 'ns1:SlavePresentationResponseType' stored in dynamic array slaveResponse of length __sizeslaveResponse
        int __sizeslaveResponse;
        ns1__SlavePresentationResponseType **slaveResponse;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlavePresentationResponseListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlavePresentationResponseListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlavePresentationResponseListType, default initialized and not managed by a soap context
        virtual ns1__SlavePresentationResponseListType *soap_alloc(void) const { return SOAP_NEW(ns1__SlavePresentationResponseListType); }
      public:
        /// Constructor with initializations
        ns1__SlavePresentationResponseListType() : __sizeslaveResponse(), slaveResponse() { }
        virtual ~ns1__SlavePresentationResponseListType() { }
        /// Friend allocator used by soap_new_ns1__SlavePresentationResponseListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlavePresentationResponseListType * SOAP_FMAC2 soap_instantiate_ns1__SlavePresentationResponseListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1100 */
#ifndef SOAP_TYPE_ns1__SlavePresentationResponseType
#define SOAP_TYPE_ns1__SlavePresentationResponseType (316)
/* Type ns1__SlavePresentationResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlavePresentationResponseType': */
class SOAP_CMAC ns1__SlavePresentationResponseType : public xsd__anyType {
      public:
        /// Required element 'slave' of XSD type 'ns1:MonitoringTypeId'
        ns1__MonitoringTypeId *slave;
        /// Required element 'result' of XSD type 'xsd:unsignedShort'
        unsigned short result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlavePresentationResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlavePresentationResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlavePresentationResponseType, default initialized and not managed by a soap context
        virtual ns1__SlavePresentationResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SlavePresentationResponseType); }
      public:
        /// Constructor with initializations
        ns1__SlavePresentationResponseType() : slave(), result() { }
        virtual ~ns1__SlavePresentationResponseType() { }
        /// Friend allocator used by soap_new_ns1__SlavePresentationResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlavePresentationResponseType * SOAP_FMAC2 soap_instantiate_ns1__SlavePresentationResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1103 */
#ifndef SOAP_TYPE_ns1__MonitoringTypeId
#define SOAP_TYPE_ns1__MonitoringTypeId (317)
/* Type ns1__MonitoringTypeId is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:MonitoringTypeId': */
class SOAP_CMAC ns1__MonitoringTypeId : public xsd__anyType {
      public:
        /// required attribute 'eId' of XSD type 'xsd:unsignedInt'
        unsigned int eId;
        /// required attribute 'date' of XSD type 'xsd:dateTime'
        time_t date;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MonitoringTypeId
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MonitoringTypeId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MonitoringTypeId, default initialized and not managed by a soap context
        virtual ns1__MonitoringTypeId *soap_alloc(void) const { return SOAP_NEW(ns1__MonitoringTypeId); }
      public:
        /// Constructor with initializations
        ns1__MonitoringTypeId() : eId(), date() { }
        virtual ~ns1__MonitoringTypeId() { }
        /// Friend allocator used by soap_new_ns1__MonitoringTypeId(struct soap*, int)
        friend SOAP_FMAC1 ns1__MonitoringTypeId * SOAP_FMAC2 soap_instantiate_ns1__MonitoringTypeId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1112 */
#ifndef SOAP_TYPE_ns1__confPackageListType
#define SOAP_TYPE_ns1__confPackageListType (320)
/* Type ns1__confPackageListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:confPackageListType': */
class SOAP_CMAC ns1__confPackageListType : public xsd__anyType {
      public:
        /// Sequence of elements 'package' of XSD type 'ns1:packageType' stored in dynamic array package of length __sizepackage
        int __sizepackage;
        ns1__packageType **package;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__confPackageListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__confPackageListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__confPackageListType, default initialized and not managed by a soap context
        virtual ns1__confPackageListType *soap_alloc(void) const { return SOAP_NEW(ns1__confPackageListType); }
      public:
        /// Constructor with initializations
        ns1__confPackageListType() : __sizepackage(), package(), length() { }
        virtual ~ns1__confPackageListType() { }
        /// Friend allocator used by soap_new_ns1__confPackageListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__confPackageListType * SOAP_FMAC2 soap_instantiate_ns1__confPackageListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1115 */
#ifndef SOAP_TYPE_ns1__packageType
#define SOAP_TYPE_ns1__packageType (321)
/* Type ns1__packageType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:packageType': */
class SOAP_CMAC ns1__packageType : public xsd__anyType {
      public:
        /// Required element 'configFileList' of XSD type 'ns1:configFileListType'
        ns1__configFileListType *configFileList;
        /// required attribute 'id' of XSD type 'xsd:long'
        LONG64 id;
        /// required attribute 'version' of XSD type 'xsd:long'
        LONG64 version;
      public:
        /// Return unique type id SOAP_TYPE_ns1__packageType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__packageType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__packageType, default initialized and not managed by a soap context
        virtual ns1__packageType *soap_alloc(void) const { return SOAP_NEW(ns1__packageType); }
      public:
        /// Constructor with initializations
        ns1__packageType() : configFileList(), id(), version() { }
        virtual ~ns1__packageType() { }
        /// Friend allocator used by soap_new_ns1__packageType(struct soap*, int)
        friend SOAP_FMAC1 ns1__packageType * SOAP_FMAC2 soap_instantiate_ns1__packageType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1118 */
#ifndef SOAP_TYPE_ns1__configFileListType
#define SOAP_TYPE_ns1__configFileListType (322)
/* Type ns1__configFileListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:configFileListType': */
class SOAP_CMAC ns1__configFileListType : public xsd__anyType {
      public:
        /// Sequence of elements 'configFile' of XSD type 'ns1:configFileType' stored in dynamic array configFile of length __sizeconfigFile
        int __sizeconfigFile;
        ns1__configFileType **configFile;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__configFileListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__configFileListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__configFileListType, default initialized and not managed by a soap context
        virtual ns1__configFileListType *soap_alloc(void) const { return SOAP_NEW(ns1__configFileListType); }
      public:
        /// Constructor with initializations
        ns1__configFileListType() : __sizeconfigFile(), configFile(), length() { }
        virtual ~ns1__configFileListType() { }
        /// Friend allocator used by soap_new_ns1__configFileListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__configFileListType * SOAP_FMAC2 soap_instantiate_ns1__configFileListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1121 */
#ifndef SOAP_TYPE_ns1__configFileType
#define SOAP_TYPE_ns1__configFileType (323)
/* Type ns1__configFileType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:configFileType': */
class SOAP_CMAC ns1__configFileType : public xsd__anyType {
      public:
        /// required attribute 'id' of XSD type 'xsd:long'
        LONG64 id;
        /// required attribute 'version' of XSD type 'xsd:long'
        LONG64 version;
        /// required attribute 'incVersion' of XSD type 'xsd:long'
        LONG64 incVersion;
      public:
        /// Return unique type id SOAP_TYPE_ns1__configFileType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__configFileType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__configFileType, default initialized and not managed by a soap context
        virtual ns1__configFileType *soap_alloc(void) const { return SOAP_NEW(ns1__configFileType); }
      public:
        /// Constructor with initializations
        ns1__configFileType() : id(), version(), incVersion() { }
        virtual ~ns1__configFileType() { }
        /// Friend allocator used by soap_new_ns1__configFileType(struct soap*, int)
        friend SOAP_FMAC1 ns1__configFileType * SOAP_FMAC2 soap_instantiate_ns1__configFileType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1130 */
#ifndef SOAP_TYPE_ns1__MTC_USCORERangeDateTimeType
#define SOAP_TYPE_ns1__MTC_USCORERangeDateTimeType (326)
/* Type ns1__MTC_USCORERangeDateTimeType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_RangeDateTimeType': */
class SOAP_CMAC ns1__MTC_USCORERangeDateTimeType : public xsd__anyType {
      public:
        /// Required element 'start' of XSD type 'xsd:dateTime'
        time_t start;
        /// Required element 'end' of XSD type 'xsd:dateTime'
        time_t end;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORERangeDateTimeType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORERangeDateTimeType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORERangeDateTimeType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORERangeDateTimeType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORERangeDateTimeType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORERangeDateTimeType() : start(), end() { }
        virtual ~ns1__MTC_USCORERangeDateTimeType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORERangeDateTimeType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORERangeDateTimeType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORERangeDateTimeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1136 */
#ifndef SOAP_TYPE_ns1__ExtStateType
#define SOAP_TYPE_ns1__ExtStateType (328)
/* Type ns1__ExtStateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ExtStateType': */
class SOAP_CMAC ns1__ExtStateType : public xsd__anyType {
      public:
        /// Required element 'wM' of XSD type 'xsd:int'
        int wM;
        /// Required element 'sM' of XSD type 'xsd:int'
        int sM;
        /// Required element 'devList' of XSD type 'ns1:DeviceListType'
        ns1__DeviceListType *devList;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmListType'
        ns1__AlarmListType *alarmList;
        /// Required element 'mediaOpList' of XSD type 'ns1:MediaOperationListType'
        ns1__MediaOperationListType *mediaOpList;
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'shiftList' of XSD type 'ns1:ShiftList'
        ns1__ShiftList *shiftList;
        /// Optional element 'samDeviceList' of XSD type 'ns1:samDeviceTypeList'
        ns1__samDeviceTypeList *samDeviceList;
        /// Optional element 'cashInfoList' of XSD type 'ns1:CashInfoList'
        ns1__CashInfoList *cashInfoList;
        /// Optional element 'location' of XSD type 'ns1:LocationType'
        ns1__LocationType *location;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ExtStateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ExtStateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ExtStateType, default initialized and not managed by a soap context
        virtual ns1__ExtStateType *soap_alloc(void) const { return SOAP_NEW(ns1__ExtStateType); }
      public:
        /// Constructor with initializations
        ns1__ExtStateType() : wM(), sM(), devList(), alarmList(), mediaOpList(), shift(), shiftList(), samDeviceList(), cashInfoList(), location() { }
        virtual ~ns1__ExtStateType() { }
        /// Friend allocator used by soap_new_ns1__ExtStateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ExtStateType * SOAP_FMAC2 soap_instantiate_ns1__ExtStateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1139 */
#ifndef SOAP_TYPE_ns1__MediaDispenserListType
#define SOAP_TYPE_ns1__MediaDispenserListType (329)
/* Type ns1__MediaDispenserListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaDispenserListType': */
class SOAP_CMAC ns1__MediaDispenserListType : public xsd__anyType {
      public:
        /// Sequence of elements 'dispenser' of XSD type 'ns1:MediaDispenserType' stored in dynamic array dispenser of length __sizedispenser
        int __sizedispenser;
        ns1__MediaDispenserType **dispenser;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaDispenserListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaDispenserListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaDispenserListType, default initialized and not managed by a soap context
        virtual ns1__MediaDispenserListType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaDispenserListType); }
      public:
        /// Constructor with initializations
        ns1__MediaDispenserListType() : __sizedispenser(), dispenser(), length() { }
        virtual ~ns1__MediaDispenserListType() { }
        /// Friend allocator used by soap_new_ns1__MediaDispenserListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaDispenserListType * SOAP_FMAC2 soap_instantiate_ns1__MediaDispenserListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1142 */
#ifndef SOAP_TYPE_ns1__MediaDispenserType
#define SOAP_TYPE_ns1__MediaDispenserType (330)
/* Type ns1__MediaDispenserType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaDispenserType': */
class SOAP_CMAC ns1__MediaDispenserType : public xsd__anyType {
      public:
        /// Optional element 'stockList' of XSD type 'ns1:DispenserStockListType'
        ns1__DispenserStockListType *stockList;
        /// optional attribute 'id' of XSD type 'xsd:int'
        int *id;
        /// optional attribute 'type' of XSD type 'xsd:int'
        int *type;
        /// optional attribute 'status' of XSD type 'xsd:int'
        int *status;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaDispenserType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaDispenserType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaDispenserType, default initialized and not managed by a soap context
        virtual ns1__MediaDispenserType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaDispenserType); }
      public:
        /// Constructor with initializations
        ns1__MediaDispenserType() : stockList(), id(), type(), status() { }
        virtual ~ns1__MediaDispenserType() { }
        /// Friend allocator used by soap_new_ns1__MediaDispenserType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaDispenserType * SOAP_FMAC2 soap_instantiate_ns1__MediaDispenserType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1145 */
#ifndef SOAP_TYPE_ns1__DispenserStockListType
#define SOAP_TYPE_ns1__DispenserStockListType (331)
/* Type ns1__DispenserStockListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DispenserStockListType': */
class SOAP_CMAC ns1__DispenserStockListType : public xsd__anyType {
      public:
        /// Sequence of elements 'stock' of XSD type 'ns1:DispenserStockType' stored in dynamic array stock of length __sizestock
        int __sizestock;
        ns1__DispenserStockType **stock;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DispenserStockListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DispenserStockListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DispenserStockListType, default initialized and not managed by a soap context
        virtual ns1__DispenserStockListType *soap_alloc(void) const { return SOAP_NEW(ns1__DispenserStockListType); }
      public:
        /// Constructor with initializations
        ns1__DispenserStockListType() : __sizestock(), stock(), length() { }
        virtual ~ns1__DispenserStockListType() { }
        /// Friend allocator used by soap_new_ns1__DispenserStockListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DispenserStockListType * SOAP_FMAC2 soap_instantiate_ns1__DispenserStockListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1148 */
#ifndef SOAP_TYPE_ns1__DispenserStockType
#define SOAP_TYPE_ns1__DispenserStockType (332)
/* Type ns1__DispenserStockType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:DispenserStockType': */
class SOAP_CMAC ns1__DispenserStockType : public xsd__anyType {
      public:
        /// Required element 'mediaType' of XSD type 'xsd:int'
        int mediaType;
        /// Required element 'issued' of XSD type 'xsd:int'
        int issued;
        /// Required element 'left' of XSD type 'xsd:int'
        int left;
        /// Required element 'rejected' of XSD type 'xsd:int'
        int rejected;
        /// optional attribute 'id' of XSD type 'xsd:int'
        int *id;
        /// optional attribute 'status' of XSD type 'xsd:int'
        int *status;
      public:
        /// Return unique type id SOAP_TYPE_ns1__DispenserStockType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__DispenserStockType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__DispenserStockType, default initialized and not managed by a soap context
        virtual ns1__DispenserStockType *soap_alloc(void) const { return SOAP_NEW(ns1__DispenserStockType); }
      public:
        /// Constructor with initializations
        ns1__DispenserStockType() : mediaType(), issued(), left(), rejected(), id(), status() { }
        virtual ~ns1__DispenserStockType() { }
        /// Friend allocator used by soap_new_ns1__DispenserStockType(struct soap*, int)
        friend SOAP_FMAC1 ns1__DispenserStockType * SOAP_FMAC2 soap_instantiate_ns1__DispenserStockType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1151 */
#ifndef SOAP_TYPE_ns1__ShiftList
#define SOAP_TYPE_ns1__ShiftList (333)
/* Type ns1__ShiftList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ShiftList': */
class SOAP_CMAC ns1__ShiftList : public xsd__anyType {
      public:
        /// Sequence of elements 'shift' of XSD type 'ns1:Shift' stored in dynamic array shift of length __sizeshift
        int __sizeshift;
        ns1__Shift **shift;
        /// optional attribute 'size' of XSD type 'xsd:unsignedInt'
        unsigned int *size;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ShiftList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ShiftList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ShiftList, default initialized and not managed by a soap context
        virtual ns1__ShiftList *soap_alloc(void) const { return SOAP_NEW(ns1__ShiftList); }
      public:
        /// Constructor with initializations
        ns1__ShiftList() : __sizeshift(), shift(), size() { }
        virtual ~ns1__ShiftList() { }
        /// Friend allocator used by soap_new_ns1__ShiftList(struct soap*, int)
        friend SOAP_FMAC1 ns1__ShiftList * SOAP_FMAC2 soap_instantiate_ns1__ShiftList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1154 */
#ifndef SOAP_TYPE_ns1__Shift
#define SOAP_TYPE_ns1__Shift (334)
/* Type ns1__Shift is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:Shift': */
class SOAP_CMAC ns1__Shift : public xsd__anyType {
      public:
        /// required attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int id;
        /// required attribute 'user' of XSD type 'xsd:unsignedInt'
        unsigned int user;
        /// required attribute 'start' of XSD type 'xsd:dateTime'
        time_t start;
        /// optional attribute 'active' of XSD type 'xsd:boolean'
        bool *active;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Shift
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Shift; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Shift, default initialized and not managed by a soap context
        virtual ns1__Shift *soap_alloc(void) const { return SOAP_NEW(ns1__Shift); }
      public:
        /// Constructor with initializations
        ns1__Shift() : id(), user(), start(), active() { }
        virtual ~ns1__Shift() { }
        /// Friend allocator used by soap_new_ns1__Shift(struct soap*, int)
        friend SOAP_FMAC1 ns1__Shift * SOAP_FMAC2 soap_instantiate_ns1__Shift(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1157 */
#ifndef SOAP_TYPE_ns1__samDeviceTypeList
#define SOAP_TYPE_ns1__samDeviceTypeList (335)
/* Type ns1__samDeviceTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:samDeviceTypeList': */
class SOAP_CMAC ns1__samDeviceTypeList : public xsd__anyType {
      public:
        /// Sequence of elements 'samDevice' of XSD type 'ns1:samDeviceType' stored in dynamic array samDevice of length __sizesamDevice
        int __sizesamDevice;
        ns1__samDeviceType **samDevice;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__samDeviceTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__samDeviceTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__samDeviceTypeList, default initialized and not managed by a soap context
        virtual ns1__samDeviceTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__samDeviceTypeList); }
      public:
        /// Constructor with initializations
        ns1__samDeviceTypeList() : __sizesamDevice(), samDevice(), length() { }
        virtual ~ns1__samDeviceTypeList() { }
        /// Friend allocator used by soap_new_ns1__samDeviceTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__samDeviceTypeList * SOAP_FMAC2 soap_instantiate_ns1__samDeviceTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1160 */
#ifndef SOAP_TYPE_ns1__samDeviceType
#define SOAP_TYPE_ns1__samDeviceType (336)
/* Type ns1__samDeviceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:samDeviceType': */
class SOAP_CMAC ns1__samDeviceType : public xsd__anyType {
      public:
        /// Required element 'deviceCode' of XSD type 'xsd:long'
        LONG64 deviceCode;
        /// Required element 'sam' of XSD type 'xsd:long'
        LONG64 sam;
        /// Required element 'migrationLevel' of XSD type 'xsd:long'
        LONG64 migrationLevel;
        /// Required element 'currentQuotaTransactions' of XSD type 'xsd:long'
        LONG64 currentQuotaTransactions;
        /// Required element 'currentQuotaValue' of XSD type 'xsd:long'
        LONG64 currentQuotaValue;
      public:
        /// Return unique type id SOAP_TYPE_ns1__samDeviceType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__samDeviceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__samDeviceType, default initialized and not managed by a soap context
        virtual ns1__samDeviceType *soap_alloc(void) const { return SOAP_NEW(ns1__samDeviceType); }
      public:
        /// Constructor with initializations
        ns1__samDeviceType() : deviceCode(), sam(), migrationLevel(), currentQuotaTransactions(), currentQuotaValue() { }
        virtual ~ns1__samDeviceType() { }
        /// Friend allocator used by soap_new_ns1__samDeviceType(struct soap*, int)
        friend SOAP_FMAC1 ns1__samDeviceType * SOAP_FMAC2 soap_instantiate_ns1__samDeviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1163 */
#ifndef SOAP_TYPE_ns1__CashInfoList
#define SOAP_TYPE_ns1__CashInfoList (337)
/* Type ns1__CashInfoList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CashInfoList': */
class SOAP_CMAC ns1__CashInfoList : public xsd__anyType {
      public:
        /// Sequence of elements 'cashInfo' of XSD type 'ns1:CashInfo' stored in dynamic array cashInfo of length __sizecashInfo
        int __sizecashInfo;
        ns1__CashInfo **cashInfo;
        /// optional attribute 'size' of XSD type 'xsd:unsignedInt'
        unsigned int *size;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashInfoList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CashInfoList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashInfoList, default initialized and not managed by a soap context
        virtual ns1__CashInfoList *soap_alloc(void) const { return SOAP_NEW(ns1__CashInfoList); }
      public:
        /// Constructor with initializations
        ns1__CashInfoList() : __sizecashInfo(), cashInfo(), size() { }
        virtual ~ns1__CashInfoList() { }
        /// Friend allocator used by soap_new_ns1__CashInfoList(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashInfoList * SOAP_FMAC2 soap_instantiate_ns1__CashInfoList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1166 */
#ifndef SOAP_TYPE_ns1__CashInfo
#define SOAP_TYPE_ns1__CashInfo (338)
/* Type ns1__CashInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CashInfo': */
class SOAP_CMAC ns1__CashInfo : public xsd__anyType {
      public:
        /// Required element 'pert' of XSD type 'xsd:unsignedShort'
        unsigned short pert;
        /// Required element 'payt' of XSD type 'xsd:unsignedInt'
        unsigned int payt;
        /// Required element 'type' of XSD type 'xsd:int'
        int type;
        /// Required element 'amnt' of XSD type 'xsd:unsignedLong'
        ULONG64 amnt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CashInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashInfo, default initialized and not managed by a soap context
        virtual ns1__CashInfo *soap_alloc(void) const { return SOAP_NEW(ns1__CashInfo); }
      public:
        /// Constructor with initializations
        ns1__CashInfo() : pert(), payt(), type(), amnt() { }
        virtual ~ns1__CashInfo() { }
        /// Friend allocator used by soap_new_ns1__CashInfo(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashInfo * SOAP_FMAC2 soap_instantiate_ns1__CashInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1169 */
#ifndef SOAP_TYPE_ns1__TransactionMTCConfType
#define SOAP_TYPE_ns1__TransactionMTCConfType (339)
/* Type ns1__TransactionMTCConfType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionMTCConfType': */
class SOAP_CMAC ns1__TransactionMTCConfType : public xsd__anyType {
      public:
        /// Required element 'id' of XSD type 'ns1:MTC_TransactionIdType'
        ns1__MTC_USCORETransactionIdType *id;
        /// Required element 'admited' of XSD type 'xsd:boolean'
        bool admited;
        /// Required element 'rejectionCode' of XSD type 'xsd:unsignedInt'
        unsigned int rejectionCode;
        /// Required element 'rejectionDesc' of XSD type 'xsd:string'
        char *rejectionDesc;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionMTCConfType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionMTCConfType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionMTCConfType, default initialized and not managed by a soap context
        virtual ns1__TransactionMTCConfType *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionMTCConfType); }
      public:
        /// Constructor with initializations
        ns1__TransactionMTCConfType() : id(), admited(), rejectionCode(), rejectionDesc() { }
        virtual ~ns1__TransactionMTCConfType() { }
        /// Friend allocator used by soap_new_ns1__TransactionMTCConfType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionMTCConfType * SOAP_FMAC2 soap_instantiate_ns1__TransactionMTCConfType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1172 */
#ifndef SOAP_TYPE_ns1__TransactionMTCConfTypeList
#define SOAP_TYPE_ns1__TransactionMTCConfTypeList (340)
/* Type ns1__TransactionMTCConfTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TransactionMTCConfTypeList': */
class SOAP_CMAC ns1__TransactionMTCConfTypeList : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:TransactionMTCConfType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__TransactionMTCConfType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TransactionMTCConfTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TransactionMTCConfTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TransactionMTCConfTypeList, default initialized and not managed by a soap context
        virtual ns1__TransactionMTCConfTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__TransactionMTCConfTypeList); }
      public:
        /// Constructor with initializations
        ns1__TransactionMTCConfTypeList() : __sizeitems(), items() { }
        virtual ~ns1__TransactionMTCConfTypeList() { }
        /// Friend allocator used by soap_new_ns1__TransactionMTCConfTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__TransactionMTCConfTypeList * SOAP_FMAC2 soap_instantiate_ns1__TransactionMTCConfTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1175 */
#ifndef SOAP_TYPE_ns1__QuantityType
#define SOAP_TYPE_ns1__QuantityType (341)
/* Type ns1__QuantityType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:QuantityType': */
class SOAP_CMAC ns1__QuantityType : public xsd__anyType {
      public:
        /// Required element 'units' of XSD type 'xsd:string'
        char *units;
        /// Required element 'quantity' of XSD type 'xsd:unsignedInt'
        unsigned int quantity;
      public:
        /// Return unique type id SOAP_TYPE_ns1__QuantityType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__QuantityType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__QuantityType, default initialized and not managed by a soap context
        virtual ns1__QuantityType *soap_alloc(void) const { return SOAP_NEW(ns1__QuantityType); }
      public:
        /// Constructor with initializations
        ns1__QuantityType() : units(), quantity() { }
        virtual ~ns1__QuantityType() { }
        /// Friend allocator used by soap_new_ns1__QuantityType(struct soap*, int)
        friend SOAP_FMAC1 ns1__QuantityType * SOAP_FMAC2 soap_instantiate_ns1__QuantityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1178 */
#ifndef SOAP_TYPE_ns1__TvmExtStateType
#define SOAP_TYPE_ns1__TvmExtStateType (342)
/* Type ns1__TvmExtStateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TvmExtStateType': */
class SOAP_CMAC ns1__TvmExtStateType : public xsd__anyType {
      public:
        /// Required element 'wM' of XSD type 'xsd:int'
        int wM;
        /// Required element 'sM' of XSD type 'xsd:int'
        int sM;
        /// Required element 'devList' of XSD type 'ns1:DeviceListType'
        ns1__DeviceListType *devList;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmListType'
        ns1__AlarmListType *alarmList;
        /// Required element 'mediaOpList' of XSD type 'ns1:MediaOperationListType'
        ns1__MediaOperationListType *mediaOpList;
        /// Required element 'changeStatus' of XSD type 'xsd:int'
        int changeStatus;
        /// Required element 'purseStatus' of XSD type 'xsd:int'
        int purseStatus;
        /// Required element 'noteBoxStatus' of XSD type 'xsd:int'
        int noteBoxStatus;
        /// Required element 'creditStatus' of XSD type 'xsd:int'
        int creditStatus;
        /// Optional element 'refillBoxList' of XSD type 'ns1:BoxListType'
        ns1__BoxListType *refillBoxList;
        /// Optional element 'hopperBoxList' of XSD type 'ns1:BoxListType'
        ns1__BoxListType *hopperBoxList;
        /// Optional element 'collectionBoxList' of XSD type 'ns1:BoxListType'
        ns1__BoxListType *collectionBoxList;
        /// Optional element 'noteDispenserBoxList' of XSD type 'ns1:BoxListType'
        ns1__BoxListType *noteDispenserBoxList;
        /// Optional element 'rejectedBoxList' of XSD type 'ns1:BoxListType'
        ns1__BoxListType *rejectedBoxList;
        /// Optional element 'monetaryBoxList' of XSD type 'ns1:BoxListType'
        ns1__BoxListType *monetaryBoxList;
        /// Optional element 'mediaDispenserList' of XSD type 'ns1:MediaDispenserListType'
        ns1__MediaDispenserListType *mediaDispenserList;
        /// Required element 'samDeviceList' of XSD type 'ns1:samDeviceTypeList'
        ns1__samDeviceTypeList *samDeviceList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TvmExtStateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TvmExtStateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TvmExtStateType, default initialized and not managed by a soap context
        virtual ns1__TvmExtStateType *soap_alloc(void) const { return SOAP_NEW(ns1__TvmExtStateType); }
      public:
        /// Constructor with initializations
        ns1__TvmExtStateType() : wM(), sM(), devList(), alarmList(), mediaOpList(), changeStatus(), purseStatus(), noteBoxStatus(), creditStatus(), refillBoxList(), hopperBoxList(), collectionBoxList(), noteDispenserBoxList(), rejectedBoxList(), monetaryBoxList(), mediaDispenserList(), samDeviceList() { }
        virtual ~ns1__TvmExtStateType() { }
        /// Friend allocator used by soap_new_ns1__TvmExtStateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TvmExtStateType * SOAP_FMAC2 soap_instantiate_ns1__TvmExtStateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1181 */
#ifndef SOAP_TYPE_ns1__BoxListType
#define SOAP_TYPE_ns1__BoxListType (343)
/* Type ns1__BoxListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BoxListType': */
class SOAP_CMAC ns1__BoxListType : public xsd__anyType {
      public:
        /// Sequence of elements 'Box' of XSD type 'ns1:boxType' stored in dynamic array Box of length __sizeBox
        int __sizeBox;
        ns1__boxType **Box;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BoxListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BoxListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BoxListType, default initialized and not managed by a soap context
        virtual ns1__BoxListType *soap_alloc(void) const { return SOAP_NEW(ns1__BoxListType); }
      public:
        /// Constructor with initializations
        ns1__BoxListType() : __sizeBox(), Box(), length() { }
        virtual ~ns1__BoxListType() { }
        /// Friend allocator used by soap_new_ns1__BoxListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BoxListType * SOAP_FMAC2 soap_instantiate_ns1__BoxListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1184 */
#ifndef SOAP_TYPE_ns1__boxType
#define SOAP_TYPE_ns1__boxType (344)
/* Type ns1__boxType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:boxType': */
class SOAP_CMAC ns1__boxType : public xsd__anyType {
      public:
        /// Required element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short status;
        /// Required element 'sN' of XSD type 'xsd:long'
        LONG64 sN;
        /// Required element 'minLevel' of XSD type 'xsd:int'
        int minLevel;
        /// Required element 'maxLevel' of XSD type 'xsd:int'
        int maxLevel;
        /// Required element 'monetaryUnitList' of XSD type 'ns1:monetaryUnitListType'
        ns1__monetaryUnitListType *monetaryUnitList;
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__boxType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__boxType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__boxType, default initialized and not managed by a soap context
        virtual ns1__boxType *soap_alloc(void) const { return SOAP_NEW(ns1__boxType); }
      public:
        /// Constructor with initializations
        ns1__boxType() : status(), sN(), minLevel(), maxLevel(), monetaryUnitList(), id(), type() { }
        virtual ~ns1__boxType() { }
        /// Friend allocator used by soap_new_ns1__boxType(struct soap*, int)
        friend SOAP_FMAC1 ns1__boxType * SOAP_FMAC2 soap_instantiate_ns1__boxType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1187 */
#ifndef SOAP_TYPE_ns1__SceqExtStateType
#define SOAP_TYPE_ns1__SceqExtStateType (345)
/* Type ns1__SceqExtStateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SceqExtStateType': */
class SOAP_CMAC ns1__SceqExtStateType : public xsd__anyType {
      public:
        /// Required element 'wM' of XSD type 'xsd:int'
        int wM;
        /// Required element 'sM' of XSD type 'xsd:int'
        int sM;
        /// Required element 'devList' of XSD type 'ns1:DeviceListType'
        ns1__DeviceListType *devList;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmListType'
        ns1__AlarmListType *alarmList;
        /// Required element 'powerSupplyState' of XSD type 'xsd:int'
        int powerSupplyState;
        /// Required element 'mediaOpList' of XSD type 'ns1:MediaOperationListType'
        ns1__MediaOperationListType *mediaOpList;
        /// Required element 'eqList' of XSD type 'ns1:eqList'
        ns1__eqList *eqList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SceqExtStateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SceqExtStateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SceqExtStateType, default initialized and not managed by a soap context
        virtual ns1__SceqExtStateType *soap_alloc(void) const { return SOAP_NEW(ns1__SceqExtStateType); }
      public:
        /// Constructor with initializations
        ns1__SceqExtStateType() : wM(), sM(), devList(), alarmList(), powerSupplyState(), mediaOpList(), eqList() { }
        virtual ~ns1__SceqExtStateType() { }
        /// Friend allocator used by soap_new_ns1__SceqExtStateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SceqExtStateType * SOAP_FMAC2 soap_instantiate_ns1__SceqExtStateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:5957 */
#ifndef SOAP_TYPE__ns1__eqList_eq
#define SOAP_TYPE__ns1__eqList_eq (674)
/* complex XSD type 'ns1:eqList-eq': */
class SOAP_CMAC _ns1__eqList_eq {
      public:
        /// Required element 'eqT' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *eqT;
        /// Required element 'communicating' of XSD type 'xsd:int'
        int communicating;
      public:
        /// Return unique type id SOAP_TYPE__ns1__eqList_eq
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__eqList_eq; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__eqList_eq, default initialized and not managed by a soap context
        virtual _ns1__eqList_eq *soap_alloc(void) const { return SOAP_NEW(_ns1__eqList_eq); }
      public:
        /// Constructor with initializations
        _ns1__eqList_eq() : eqT(), communicating() { }
        virtual ~_ns1__eqList_eq() { }
        /// Friend allocator used by soap_new__ns1__eqList_eq(struct soap*, int)
        friend SOAP_FMAC1 _ns1__eqList_eq * SOAP_FMAC2 soap_instantiate__ns1__eqList_eq(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1190 */
#ifndef SOAP_TYPE_ns1__eqList
#define SOAP_TYPE_ns1__eqList (346)
/* Type ns1__eqList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:eqList': */
class SOAP_CMAC ns1__eqList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'eq' of XSD type 'ns1:eqList-eq' stored in dynamic array eq of length __sizeeq
        int __sizeeq;
        _ns1__eqList_eq *eq;
      public:
        /// Return unique type id SOAP_TYPE_ns1__eqList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__eqList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__eqList, default initialized and not managed by a soap context
        virtual ns1__eqList *soap_alloc(void) const { return SOAP_NEW(ns1__eqList); }
      public:
        /// Constructor with initializations
        ns1__eqList() : __sizeeq(), eq() { }
        virtual ~ns1__eqList() { }
        /// Friend allocator used by soap_new_ns1__eqList(struct soap*, int)
        friend SOAP_FMAC1 ns1__eqList * SOAP_FMAC2 soap_instantiate_ns1__eqList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1193 */
#ifndef SOAP_TYPE_ns1__versionListType
#define SOAP_TYPE_ns1__versionListType (347)
/* Type ns1__versionListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:versionListType': */
class SOAP_CMAC ns1__versionListType : public xsd__anyType {
      public:
        /// Sequence of elements 'version' of XSD type 'ns1:versionType' stored in dynamic array version of length __sizeversion
        int __sizeversion;
        ns1__versionType **version;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__versionListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__versionListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__versionListType, default initialized and not managed by a soap context
        virtual ns1__versionListType *soap_alloc(void) const { return SOAP_NEW(ns1__versionListType); }
      public:
        /// Constructor with initializations
        ns1__versionListType() : __sizeversion(), version(), length() { }
        virtual ~ns1__versionListType() { }
        /// Friend allocator used by soap_new_ns1__versionListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__versionListType * SOAP_FMAC2 soap_instantiate_ns1__versionListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1196 */
#ifndef SOAP_TYPE_ns1__versionType
#define SOAP_TYPE_ns1__versionType (348)
/* Type ns1__versionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:versionType': */
class SOAP_CMAC ns1__versionType : public xsd__anyType {
      public:
        /// Required element 'versionType' of XSD type 'xsd:int'
        int versionType;
        /// Required element 'itemCode' of XSD type 'xsd:int'
        int itemCode;
        /// Required element 'itemKey' of XSD type 'xsd:string'
        char *itemKey;
        /// Required element 'component' of XSD type 'xsd:int'
        int component;
        /// Required element 'value' of XSD type 'xsd:string'
        char *value;
        /// Required element 'date' of XSD type 'xsd:dateTime'
        time_t date;
      public:
        /// Return unique type id SOAP_TYPE_ns1__versionType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__versionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__versionType, default initialized and not managed by a soap context
        virtual ns1__versionType *soap_alloc(void) const { return SOAP_NEW(ns1__versionType); }
      public:
        /// Constructor with initializations
        ns1__versionType() : versionType(), itemCode(), itemKey(), component(), value(), date() { }
        virtual ~ns1__versionType() { }
        /// Friend allocator used by soap_new_ns1__versionType(struct soap*, int)
        friend SOAP_FMAC1 ns1__versionType * SOAP_FMAC2 soap_instantiate_ns1__versionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1199 */
#ifndef SOAP_TYPE_ns1__diagnosticListType
#define SOAP_TYPE_ns1__diagnosticListType (349)
/* Type ns1__diagnosticListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:diagnosticListType': */
class SOAP_CMAC ns1__diagnosticListType : public xsd__anyType {
      public:
        /// Sequence of elements 'diagnostic' of XSD type 'ns1:diagnosticType' stored in dynamic array diagnostic of length __sizediagnostic
        int __sizediagnostic;
        ns1__diagnosticType **diagnostic;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__diagnosticListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__diagnosticListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__diagnosticListType, default initialized and not managed by a soap context
        virtual ns1__diagnosticListType *soap_alloc(void) const { return SOAP_NEW(ns1__diagnosticListType); }
      public:
        /// Constructor with initializations
        ns1__diagnosticListType() : __sizediagnostic(), diagnostic(), length() { }
        virtual ~ns1__diagnosticListType() { }
        /// Friend allocator used by soap_new_ns1__diagnosticListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__diagnosticListType * SOAP_FMAC2 soap_instantiate_ns1__diagnosticListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1202 */
#ifndef SOAP_TYPE_ns1__diagnosticType
#define SOAP_TYPE_ns1__diagnosticType (350)
/* Type ns1__diagnosticType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:diagnosticType': */
class SOAP_CMAC ns1__diagnosticType : public xsd__anyType {
      public:
        /// Required element 'itemCode' of XSD type 'xsd:int'
        int itemCode;
        /// Required element 'itemKey' of XSD type 'xsd:string'
        char *itemKey;
        /// Required element 'component' of XSD type 'xsd:int'
        int component;
        /// Required element 'value' of XSD type 'xsd:string'
        char *value;
        /// Required element 'date' of XSD type 'xsd:dateTime'
        time_t date;
      public:
        /// Return unique type id SOAP_TYPE_ns1__diagnosticType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__diagnosticType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__diagnosticType, default initialized and not managed by a soap context
        virtual ns1__diagnosticType *soap_alloc(void) const { return SOAP_NEW(ns1__diagnosticType); }
      public:
        /// Constructor with initializations
        ns1__diagnosticType() : itemCode(), itemKey(), component(), value(), date() { }
        virtual ~ns1__diagnosticType() { }
        /// Friend allocator used by soap_new_ns1__diagnosticType(struct soap*, int)
        friend SOAP_FMAC1 ns1__diagnosticType * SOAP_FMAC2 soap_instantiate_ns1__diagnosticType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1205 */
#ifndef SOAP_TYPE_ns1__AgExtStateType
#define SOAP_TYPE_ns1__AgExtStateType (351)
/* Type ns1__AgExtStateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AgExtStateType': */
class SOAP_CMAC ns1__AgExtStateType : public xsd__anyType {
      public:
        /// Required element 'wM' of XSD type 'xsd:int'
        int wM;
        /// Required element 'sM' of XSD type 'xsd:int'
        int sM;
        /// Required element 'devList' of XSD type 'ns1:DeviceListType'
        ns1__DeviceListType *devList;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmListType'
        ns1__AlarmListType *alarmList;
        /// Required element 'mediaOpList' of XSD type 'ns1:MediaOperationListType'
        ns1__MediaOperationListType *mediaOpList;
        /// Required element 'teleCharginState' of XSD type 'xsd:int'
        int teleCharginState;
        /// Required element 'samDeviceList' of XSD type 'ns1:samDeviceTypeList'
        ns1__samDeviceTypeList *samDeviceList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AgExtStateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AgExtStateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AgExtStateType, default initialized and not managed by a soap context
        virtual ns1__AgExtStateType *soap_alloc(void) const { return SOAP_NEW(ns1__AgExtStateType); }
      public:
        /// Constructor with initializations
        ns1__AgExtStateType() : wM(), sM(), devList(), alarmList(), mediaOpList(), teleCharginState(), samDeviceList() { }
        virtual ~ns1__AgExtStateType() { }
        /// Friend allocator used by soap_new_ns1__AgExtStateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AgExtStateType * SOAP_FMAC2 soap_instantiate_ns1__AgExtStateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1208 */
#ifndef SOAP_TYPE_ns1__SceqExtStateTypeList
#define SOAP_TYPE_ns1__SceqExtStateTypeList (352)
/* Type ns1__SceqExtStateTypeList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SceqExtStateTypeList': */
class SOAP_CMAC ns1__SceqExtStateTypeList : public xsd__anyType {
      public:
        /// Sequence of elements 'stateSceq' of XSD type 'ns1:SceqExtStateType' stored in dynamic array stateSceq of length __sizestateSceq
        int __sizestateSceq;
        ns1__SceqExtStateType **stateSceq;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SceqExtStateTypeList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SceqExtStateTypeList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SceqExtStateTypeList, default initialized and not managed by a soap context
        virtual ns1__SceqExtStateTypeList *soap_alloc(void) const { return SOAP_NEW(ns1__SceqExtStateTypeList); }
      public:
        /// Constructor with initializations
        ns1__SceqExtStateTypeList() : __sizestateSceq(), stateSceq(), length() { }
        virtual ~ns1__SceqExtStateTypeList() { }
        /// Friend allocator used by soap_new_ns1__SceqExtStateTypeList(struct soap*, int)
        friend SOAP_FMAC1 ns1__SceqExtStateTypeList * SOAP_FMAC2 soap_instantiate_ns1__SceqExtStateTypeList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1214 */
#ifndef SOAP_TYPE_ns1__PatternServiceConfirmationType
#define SOAP_TYPE_ns1__PatternServiceConfirmationType (354)
/* Type ns1__PatternServiceConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PatternServiceConfirmationType': */
class SOAP_CMAC ns1__PatternServiceConfirmationType : public xsd__anyType {
      public:
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// Required element 'confirmationFrom' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *confirmationFrom;
        /// Optional element 'confirmationTo' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *confirmationTo;
        /// Optional element 'confSlaveList' of XSD type 'ns1:SlaveEquipmentListType'
        ns1__SlaveEquipmentListType *confSlaveList;
        /// Optional element 'idMessageNotification' of XSD type 'xsd:unsignedInt'
        unsigned int *idMessageNotification;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PatternServiceConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PatternServiceConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PatternServiceConfirmationType, default initialized and not managed by a soap context
        virtual ns1__PatternServiceConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__PatternServiceConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__PatternServiceConfirmationType() : dateTime(), confirmationFrom(), confirmationTo(), confSlaveList(), idMessageNotification() { }
        virtual ~ns1__PatternServiceConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__PatternServiceConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PatternServiceConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__PatternServiceConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1220 */
#ifndef SOAP_TYPE_ns1__RecordConfirmationListType
#define SOAP_TYPE_ns1__RecordConfirmationListType (356)
/* Type ns1__RecordConfirmationListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RecordConfirmationListType': */
class SOAP_CMAC ns1__RecordConfirmationListType : public xsd__anyType {
      public:
        /// Sequence of elements 'items' of XSD type 'ns1:RecordConfirmationType' stored in dynamic array items of length __sizeitems
        int __sizeitems;
        ns1__RecordConfirmationType **items;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordConfirmationListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordConfirmationListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordConfirmationListType, default initialized and not managed by a soap context
        virtual ns1__RecordConfirmationListType *soap_alloc(void) const { return SOAP_NEW(ns1__RecordConfirmationListType); }
      public:
        /// Constructor with initializations
        ns1__RecordConfirmationListType() : __sizeitems(), items() { }
        virtual ~ns1__RecordConfirmationListType() { }
        /// Friend allocator used by soap_new_ns1__RecordConfirmationListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordConfirmationListType * SOAP_FMAC2 soap_instantiate_ns1__RecordConfirmationListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1223 */
#ifndef SOAP_TYPE_ns1__RecordConfirmationType
#define SOAP_TYPE_ns1__RecordConfirmationType (357)
/* Type ns1__RecordConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:RecordConfirmationType': */
class SOAP_CMAC ns1__RecordConfirmationType : public xsd__anyType {
      public:
        /// Required element 'id' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *id;
        /// Required element 'admited' of XSD type 'xsd:boolean'
        bool admited;
        /// Required element 'rejectionCode' of XSD type 'xsd:unsignedInt'
        unsigned int rejectionCode;
        /// Required element 'rejectionDesc' of XSD type 'xsd:string'
        char *rejectionDesc;
      public:
        /// Return unique type id SOAP_TYPE_ns1__RecordConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__RecordConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__RecordConfirmationType, default initialized and not managed by a soap context
        virtual ns1__RecordConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__RecordConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__RecordConfirmationType() : id(), admited(), rejectionCode(), rejectionDesc() { }
        virtual ~ns1__RecordConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__RecordConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__RecordConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__RecordConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1253 */
#ifndef SOAP_TYPE_ns1__PatternServiceNotificationType
#define SOAP_TYPE_ns1__PatternServiceNotificationType (367)
/* Type ns1__PatternServiceNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PatternServiceNotificationType': */
class SOAP_CMAC ns1__PatternServiceNotificationType : public xsd__anyType {
      public:
        /// Required element 'dateTime' of XSD type 'xsd:dateTime'
        time_t dateTime;
        /// Required element 'notificationFrom' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *notificationFrom;
        /// Optional element 'notificationTo' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *notificationTo;
        /// Optional element 'notSlaveList' of XSD type 'ns1:SlaveEquipmentListType'
        ns1__SlaveEquipmentListType *notSlaveList;
        /// Optional element 'idMessage' of XSD type 'xsd:unsignedInt'
        unsigned int *idMessage;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PatternServiceNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PatternServiceNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PatternServiceNotificationType, default initialized and not managed by a soap context
        virtual ns1__PatternServiceNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__PatternServiceNotificationType); }
      public:
        /// Constructor with initializations
        ns1__PatternServiceNotificationType() : dateTime(), notificationFrom(), notificationTo(), notSlaveList(), idMessage() { }
        virtual ~ns1__PatternServiceNotificationType() { }
        /// Friend allocator used by soap_new_ns1__PatternServiceNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PatternServiceNotificationType * SOAP_FMAC2 soap_instantiate_ns1__PatternServiceNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1283 */
#ifndef SOAP_TYPE_ns1__StateConfigInstallationListType
#define SOAP_TYPE_ns1__StateConfigInstallationListType (377)
/* Type ns1__StateConfigInstallationListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StateConfigInstallationListType': */
class SOAP_CMAC ns1__StateConfigInstallationListType : public xsd__anyType {
      public:
        /// Sequence of elements 'sct' of XSD type 'ns1:stateConfigInstallationType' stored in dynamic array sct of length __sizesct
        int __sizesct;
        ns1__stateConfigInstallationType **sct;
        /// optional attribute 'length' of XSD type 'xsd:int'
        int *length;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StateConfigInstallationListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StateConfigInstallationListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StateConfigInstallationListType, default initialized and not managed by a soap context
        virtual ns1__StateConfigInstallationListType *soap_alloc(void) const { return SOAP_NEW(ns1__StateConfigInstallationListType); }
      public:
        /// Constructor with initializations
        ns1__StateConfigInstallationListType() : __sizesct(), sct(), length() { }
        virtual ~ns1__StateConfigInstallationListType() { }
        /// Friend allocator used by soap_new_ns1__StateConfigInstallationListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StateConfigInstallationListType * SOAP_FMAC2 soap_instantiate_ns1__StateConfigInstallationListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1286 */
#ifndef SOAP_TYPE_ns1__stateConfigInstallationType
#define SOAP_TYPE_ns1__stateConfigInstallationType (378)
/* Type ns1__stateConfigInstallationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:stateConfigInstallationType': */
class SOAP_CMAC ns1__stateConfigInstallationType : public xsd__anyType {
      public:
        /// Required element 'pkgId' of XSD type 'xsd:int'
        int pkgId;
        /// Required element 'v' of XSD type 'xsd:int'
        int v;
        /// Required element 'actDate' of XSD type 'xsd:dateTime'
        time_t actDate;
        /// Required element 'state' of XSD type 'xsd:int'
        int state;
      public:
        /// Return unique type id SOAP_TYPE_ns1__stateConfigInstallationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__stateConfigInstallationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__stateConfigInstallationType, default initialized and not managed by a soap context
        virtual ns1__stateConfigInstallationType *soap_alloc(void) const { return SOAP_NEW(ns1__stateConfigInstallationType); }
      public:
        /// Constructor with initializations
        ns1__stateConfigInstallationType() : pkgId(), v(), actDate(), state() { }
        virtual ~ns1__stateConfigInstallationType() { }
        /// Friend allocator used by soap_new_ns1__stateConfigInstallationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__stateConfigInstallationType * SOAP_FMAC2 soap_instantiate_ns1__stateConfigInstallationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1325 */
#ifndef SOAP_TYPE_ns1__SrvRecordNotificationListType
#define SOAP_TYPE_ns1__SrvRecordNotificationListType (391)
/* Type ns1__SrvRecordNotificationListType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvRecordNotificationListType': */
class SOAP_CMAC ns1__SrvRecordNotificationListType : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'srvRecordNotification' of XSD type 'ns1:SrvRecordNotificationType' stored in dynamic array srvRecordNotification of length __sizesrvRecordNotification
        int __sizesrvRecordNotification;
        ns1__SrvRecordNotificationType **srvRecordNotification;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvRecordNotificationListType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvRecordNotificationListType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvRecordNotificationListType, default initialized and not managed by a soap context
        virtual ns1__SrvRecordNotificationListType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvRecordNotificationListType); }
      public:
        /// Constructor with initializations
        ns1__SrvRecordNotificationListType() : __sizesrvRecordNotification(), srvRecordNotification() { }
        virtual ~ns1__SrvRecordNotificationListType() { }
        /// Friend allocator used by soap_new_ns1__SrvRecordNotificationListType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvRecordNotificationListType * SOAP_FMAC2 soap_instantiate_ns1__SrvRecordNotificationListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1328 */
#ifndef SOAP_TYPE_ns1__AccountingProductType
#define SOAP_TYPE_ns1__AccountingProductType (392)
/* Type ns1__AccountingProductType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:AccountingProductType': */
class SOAP_CMAC ns1__AccountingProductType : public xsd__anyType {
      public:
        /// required attribute 'cd' of XSD type 'xsd:long'
        LONG64 cd;
        /// required attribute 'ag' of XSD type 'xsd:long'
        LONG64 ag;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingProductType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingProductType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingProductType, default initialized and not managed by a soap context
        virtual ns1__AccountingProductType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingProductType); }
      public:
        /// Constructor with initializations
        ns1__AccountingProductType() : cd(), ag() { }
        virtual ~ns1__AccountingProductType() { }
        /// Friend allocator used by soap_new_ns1__AccountingProductType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingProductType * SOAP_FMAC2 soap_instantiate_ns1__AccountingProductType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:6459 */
#ifndef SOAP_TYPE__ns1__union_protocol
#define SOAP_TYPE__ns1__union_protocol (756)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _ns1__union_protocol
{
        #define SOAP_UNION__ns1__union_protocol_srvRecordNotification	(1)	/**< union variant selector value for member srvRecordNotification */
        ns1__SrvRecordNotificationType *srvRecordNotification;
        #define SOAP_UNION__ns1__union_protocol_srvRecordConfirmation	(2)	/**< union variant selector value for member srvRecordConfirmation */
        ns1__SrvRecordConfirmationType *srvRecordConfirmation;
        #define SOAP_UNION__ns1__union_protocol_srvRecordRequest	(3)	/**< union variant selector value for member srvRecordRequest */
        ns1__SrvRecordRequestType *srvRecordRequest;
        #define SOAP_UNION__ns1__union_protocol_srvRecordResponse	(4)	/**< union variant selector value for member srvRecordResponse */
        ns1__SrvRecordResponseType *srvRecordResponse;
        #define SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionNotification	(5)	/**< union variant selector value for member srvMTC_USCORETransactionNotification */
        ns1__SrvMTC_USCORETransactionNotificationType *srvMTC_USCORETransactionNotification;
        #define SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionConfirmation	(6)	/**< union variant selector value for member srvMTC_USCORETransactionConfirmation */
        ns1__SrvMTC_USCORETransactionConfirmationType *srvMTC_USCORETransactionConfirmation;
        #define SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionRequest	(7)	/**< union variant selector value for member srvMTC_USCORETransactionRequest */
        ns1__SrvMTC_USCORETransactionRequestType *srvMTC_USCORETransactionRequest;
        #define SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionResponse	(8)	/**< union variant selector value for member srvMTC_USCORETransactionResponse */
        ns1__SrvMTC_USCORETransactionResponseType *srvMTC_USCORETransactionResponse;
        #define SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionNotification	(9)	/**< union variant selector value for member srvFE_USCOREMTC_USCORETransactionNotification */
        ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType *srvFE_USCOREMTC_USCORETransactionNotification;
        #define SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionConfirmation	(10)	/**< union variant selector value for member srvFE_USCOREMTC_USCORETransactionConfirmation */
        ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType *srvFE_USCOREMTC_USCORETransactionConfirmation;
        #define SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionRequest	(11)	/**< union variant selector value for member srvFE_USCOREMTC_USCORETransactionRequest */
        ns1__SrvFE_USCOREMTC_USCORETransactionRequestType *srvFE_USCOREMTC_USCORETransactionRequest;
        #define SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionResponse	(12)	/**< union variant selector value for member srvFE_USCOREMTC_USCORETransactionResponse */
        ns1__SrvFE_USCOREMTC_USCORETransactionResponseType *srvFE_USCOREMTC_USCORETransactionResponse;
        #define SOAP_UNION__ns1__union_protocol_srvPresentationRequest	(13)	/**< union variant selector value for member srvPresentationRequest */
        ns1__srvPresentationV1RequestType *srvPresentationRequest;
        #define SOAP_UNION__ns1__union_protocol_srvPresentationResponse	(14)	/**< union variant selector value for member srvPresentationResponse */
        ns1__srvPresentationV1ResponseType *srvPresentationResponse;
        #define SOAP_UNION__ns1__union_protocol_srvStateRequest	(15)	/**< union variant selector value for member srvStateRequest */
        ns1__SrvStateRequestType *srvStateRequest;
        #define SOAP_UNION__ns1__union_protocol_srvStateResponse	(16)	/**< union variant selector value for member srvStateResponse */
        ns1__SrvStateResponseType *srvStateResponse;
        #define SOAP_UNION__ns1__union_protocol_srvStateNotification	(17)	/**< union variant selector value for member srvStateNotification */
        ns1__SrvStateNotificationType *srvStateNotification;
        #define SOAP_UNION__ns1__union_protocol_srvStateConfirmation	(18)	/**< union variant selector value for member srvStateConfirmation */
        ns1__SrvStateConfirmationType *srvStateConfirmation;
        #define SOAP_UNION__ns1__union_protocol_srvConfigurationRequest	(19)	/**< union variant selector value for member srvConfigurationRequest */
        ns1__srvConfigurationBaseRequestType *srvConfigurationRequest;
        #define SOAP_UNION__ns1__union_protocol_srvConfigurationResponse	(20)	/**< union variant selector value for member srvConfigurationResponse */
        ns1__srvConfigurationBaseResponseType *srvConfigurationResponse;
        #define SOAP_UNION__ns1__union_protocol_srvAlarmNotification	(21)	/**< union variant selector value for member srvAlarmNotification */
        ns1__SrvAlarmNotificationType *srvAlarmNotification;
        #define SOAP_UNION__ns1__union_protocol_srvAlarmConfirmation	(22)	/**< union variant selector value for member srvAlarmConfirmation */
        ns1__SrvAlarmConfirmationType *srvAlarmConfirmation;
        #define SOAP_UNION__ns1__union_protocol_srvCommandRequest	(23)	/**< union variant selector value for member srvCommandRequest */
        ns1__srvCommandBaseRequestType *srvCommandRequest;
        #define SOAP_UNION__ns1__union_protocol_srvCommandResponse	(24)	/**< union variant selector value for member srvCommandResponse */
        ns1__srvCommandBaseResponseType *srvCommandResponse;
        #define SOAP_UNION__ns1__union_protocol_srvConfigurationNotification	(25)	/**< union variant selector value for member srvConfigurationNotification */
        ns1__SrvConfigurationNotificationType *srvConfigurationNotification;
        #define SOAP_UNION__ns1__union_protocol_srvDiagnosticNotification	(26)	/**< union variant selector value for member srvDiagnosticNotification */
        ns1__SrvDiagnosticNotificationType *srvDiagnosticNotification;
        #define SOAP_UNION__ns1__union_protocol_srvVersionNotification	(27)	/**< union variant selector value for member srvVersionNotification */
        ns1__SrvVersionNotificationType *srvVersionNotification;
        #define SOAP_UNION__ns1__union_protocol_srvStateConfigInstallationNotification	(28)	/**< union variant selector value for member srvStateConfigInstallationNotification */
        ns1__SrvStateConfigInstallationNotificationType *srvStateConfigInstallationNotification;
        #define SOAP_UNION__ns1__union_protocol_srvStateScepNotification	(29)	/**< union variant selector value for member srvStateScepNotification */
        ns1__SrvStateSceqnNotificationType *srvStateScepNotification;
        #define SOAP_UNION__ns1__union_protocol_srvAgExtendedStateNotification	(30)	/**< union variant selector value for member srvAgExtendedStateNotification */
        ns1__SrvAgExtendedStateNotificationType *srvAgExtendedStateNotification;
        #define SOAP_UNION__ns1__union_protocol_srvTvmExtendedStateNotification	(31)	/**< union variant selector value for member srvTvmExtendedStateNotification */
        ns1__SrvTvmExtendedStateNotificationType *srvTvmExtendedStateNotification;
        #define SOAP_UNION__ns1__union_protocol_srvExtendedStateNotification	(32)	/**< union variant selector value for member srvExtendedStateNotification */
        ns1__SrvExtendedStateNotificationType *srvExtendedStateNotification;
        #define SOAP_UNION__ns1__union_protocol_srvMtvmExtendedStateNotification	(33)	/**< union variant selector value for member srvMtvmExtendedStateNotification */
        ns1__SrvMtvmExtendedStateNotificationType *srvMtvmExtendedStateNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREAlarmRequest	(34)	/**< union variant selector value for member SrvMTC_USCOREAlarmRequest */
        ns1__SrvMTC_USCOREAlarmRequestType *SrvMTC_USCOREAlarmRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREAlarmResponse	(35)	/**< union variant selector value for member SrvMTC_USCOREAlarmResponse */
        ns1__SrvMTC_USCOREAlarmResponseType *SrvMTC_USCOREAlarmResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREAlarmNotification	(36)	/**< union variant selector value for member SrvMTC_USCOREAlarmNotification */
        ns1__SrvMTC_USCOREAlarmNotificationType *SrvMTC_USCOREAlarmNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREStatusRequest	(37)	/**< union variant selector value for member SrvMTC_USCOREStatusRequest */
        ns1__SrvMTC_USCOREStatusRequestType *SrvMTC_USCOREStatusRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREStatusResponse	(38)	/**< union variant selector value for member SrvMTC_USCOREStatusResponse */
        ns1__SrvMTC_USCOREStatusResponseType *SrvMTC_USCOREStatusResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREStatusNotification	(39)	/**< union variant selector value for member SrvMTC_USCOREStatusNotification */
        ns1__SrvMTC_USCOREStatusNotificationType *SrvMTC_USCOREStatusNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREDiagnosticRequest	(40)	/**< union variant selector value for member SrvMTC_USCOREDiagnosticRequest */
        ns1__SrvMTC_USCOREDiagnosticRequestType *SrvMTC_USCOREDiagnosticRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREDiagnosticResponse	(41)	/**< union variant selector value for member SrvMTC_USCOREDiagnosticResponse */
        ns1__SrvMTC_USCOREDiagnosticResponseType *SrvMTC_USCOREDiagnosticResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREVersionRequest	(42)	/**< union variant selector value for member SrvMTC_USCOREVersionRequest */
        ns1__SrvMTC_USCOREVersionRequestType *SrvMTC_USCOREVersionRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREVersionResponse	(43)	/**< union variant selector value for member SrvMTC_USCOREVersionResponse */
        ns1__SrvMTC_USCOREVersionResponseType *SrvMTC_USCOREVersionResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementRequest	(44)	/**< union variant selector value for member SrvMTC_USCOREConfigElementRequest */
        ns1__SrvMTC_USCOREConfigElementRequestType *SrvMTC_USCOREConfigElementRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementResponse	(45)	/**< union variant selector value for member SrvMTC_USCOREConfigElementResponse */
        ns1__SrvMTC_USCOREConfigElementResponseType *SrvMTC_USCOREConfigElementResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementChangeRequest	(46)	/**< union variant selector value for member SrvMTC_USCOREConfigElementChangeRequest */
        ns1__SrvMTC_USCOREConfigElementChangeRequestType *SrvMTC_USCOREConfigElementChangeRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementChangeResponse	(47)	/**< union variant selector value for member SrvMTC_USCOREConfigElementChangeResponse */
        ns1__SrvMTC_USCOREConfigElementChangeResponseType *SrvMTC_USCOREConfigElementChangeResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCORECommandExecRequest	(48)	/**< union variant selector value for member SrvMTC_USCORECommandExecRequest */
        ns1__SrvMTC_USCORECommandExecRequestType *SrvMTC_USCORECommandExecRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCORECommandExecResponse	(49)	/**< union variant selector value for member SrvMTC_USCORECommandExecResponse */
        ns1__SrvMTC_USCORECommandExecResponseType *SrvMTC_USCORECommandExecResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvMTC_USCORECommandExecNotify	(50)	/**< union variant selector value for member SrvMTC_USCORECommandExecNotify */
        ns1__SrvMTC_USCORECommandExecNotifyType *SrvMTC_USCORECommandExecNotify;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREAlarmRequest	(51)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREAlarmRequest */
        ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType *SrvFE_USCOREMTC_USCOREAlarmRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREAlarmResponse	(52)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREAlarmResponse */
        ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType *SrvFE_USCOREMTC_USCOREAlarmResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREAlarmNotification	(53)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREAlarmNotification */
        ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType *SrvFE_USCOREMTC_USCOREAlarmNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREStatusRequest	(54)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREStatusRequest */
        ns1__SrvFE_USCOREMTC_USCOREStatusRequestType *SrvFE_USCOREMTC_USCOREStatusRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREStatusResponse	(55)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREStatusResponse */
        ns1__SrvFE_USCOREMTC_USCOREStatusResponseType *SrvFE_USCOREMTC_USCOREStatusResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREStatusNotification	(56)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREStatusNotification */
        ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType *SrvFE_USCOREMTC_USCOREStatusNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREDiagnosticRequest	(57)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREDiagnosticRequest */
        ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType *SrvFE_USCOREMTC_USCOREDiagnosticRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREDiagnosticResponse	(58)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREDiagnosticResponse */
        ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType *SrvFE_USCOREMTC_USCOREDiagnosticResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREVersionRequest	(59)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREVersionRequest */
        ns1__SrvFE_USCOREMTC_USCOREVersionRequestType *SrvFE_USCOREMTC_USCOREVersionRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREVersionResponse	(60)	/**< union variant selector value for member SrvFE_USCOREMTC_USCOREVersionResponse */
        ns1__SrvFE_USCOREMTC_USCOREVersionResponseType *SrvFE_USCOREMTC_USCOREVersionResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvNewConfigurationNotification	(61)	/**< union variant selector value for member SrvNewConfigurationNotification */
        ns1__SrvNewConfigurationNotificationType *SrvNewConfigurationNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvNewConfigurationConfirmation	(62)	/**< union variant selector value for member SrvNewConfigurationConfirmation */
        ns1__SrvNewConfigurationConfirmationType *SrvNewConfigurationConfirmation;
        #define SOAP_UNION__ns1__union_protocol_SrvNewConfigurationInfoRequest	(63)	/**< union variant selector value for member SrvNewConfigurationInfoRequest */
        ns1__SrvConfigurationInfoRequestType *SrvNewConfigurationInfoRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvNewConfigurationInforResponse	(64)	/**< union variant selector value for member SrvNewConfigurationInforResponse */
        ns1__SrvConfigurationInfoResponseType *SrvNewConfigurationInforResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvNewConfigurationContentRequest	(65)	/**< union variant selector value for member SrvNewConfigurationContentRequest */
        ns1__SrvConfigurationContentRequestType *SrvNewConfigurationContentRequest;
        #define SOAP_UNION__ns1__union_protocol_SrvNewConfigurationContentResponse	(66)	/**< union variant selector value for member SrvNewConfigurationContentResponse */
        ns1__SrvConfigurationContentResponseType *SrvNewConfigurationContentResponse;
        #define SOAP_UNION__ns1__union_protocol_SrvFileNotification	(67)	/**< union variant selector value for member SrvFileNotification */
        ns1__SrvFileNotificationType *SrvFileNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvFileConfirmation	(68)	/**< union variant selector value for member SrvFileConfirmation */
        ns1__SrvFileConfirmationType *SrvFileConfirmation;
        #define SOAP_UNION__ns1__union_protocol_SrvOrderNotification	(69)	/**< union variant selector value for member SrvOrderNotification */
        ns1__SrvOrderNotificationType *SrvOrderNotification;
        #define SOAP_UNION__ns1__union_protocol_SrvOrderConfirmation	(70)	/**< union variant selector value for member SrvOrderConfirmation */
        ns1__SrvOrderConfirmationType *SrvOrderConfirmation;
        #define SOAP_UNION__ns1__union_protocol_versionList	(71)	/**< union variant selector value for member versionList */
        ns1__versionList *versionList;
};
#endif

/* sopa.h:1331 */
#ifndef SOAP_TYPE__ns1__protocol
#define SOAP_TYPE__ns1__protocol (393)
/* complex XSD type 'ns1:protocol': */
class SOAP_CMAC _ns1__protocol {
      public:
        /// Union with union _ns1__union_protocol variant selector __union_protocol set to one of: SOAP_UNION__ns1__union_protocol_srvRecordNotification SOAP_UNION__ns1__union_protocol_srvRecordConfirmation SOAP_UNION__ns1__union_protocol_srvRecordRequest SOAP_UNION__ns1__union_protocol_srvRecordResponse SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionNotification SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionConfirmation SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionRequest SOAP_UNION__ns1__union_protocol_srvMTC_USCORETransactionResponse SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionNotification SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionConfirmation SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionRequest SOAP_UNION__ns1__union_protocol_srvFE_USCOREMTC_USCORETransactionResponse SOAP_UNION__ns1__union_protocol_srvPresentationRequest SOAP_UNION__ns1__union_protocol_srvPresentationResponse SOAP_UNION__ns1__union_protocol_srvStateRequest SOAP_UNION__ns1__union_protocol_srvStateResponse SOAP_UNION__ns1__union_protocol_srvStateNotification SOAP_UNION__ns1__union_protocol_srvStateConfirmation SOAP_UNION__ns1__union_protocol_srvConfigurationRequest SOAP_UNION__ns1__union_protocol_srvConfigurationResponse SOAP_UNION__ns1__union_protocol_srvAlarmNotification SOAP_UNION__ns1__union_protocol_srvAlarmConfirmation SOAP_UNION__ns1__union_protocol_srvCommandRequest SOAP_UNION__ns1__union_protocol_srvCommandResponse SOAP_UNION__ns1__union_protocol_srvConfigurationNotification SOAP_UNION__ns1__union_protocol_srvDiagnosticNotification SOAP_UNION__ns1__union_protocol_srvVersionNotification SOAP_UNION__ns1__union_protocol_srvStateConfigInstallationNotification SOAP_UNION__ns1__union_protocol_srvStateScepNotification SOAP_UNION__ns1__union_protocol_srvAgExtendedStateNotification SOAP_UNION__ns1__union_protocol_srvTvmExtendedStateNotification SOAP_UNION__ns1__union_protocol_srvExtendedStateNotification SOAP_UNION__ns1__union_protocol_srvMtvmExtendedStateNotification SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREAlarmRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREAlarmResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREAlarmNotification SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREStatusRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREStatusResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREStatusNotification SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREDiagnosticRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREDiagnosticResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREVersionRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREVersionResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementChangeRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCOREConfigElementChangeResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCORECommandExecRequest SOAP_UNION__ns1__union_protocol_SrvMTC_USCORECommandExecResponse SOAP_UNION__ns1__union_protocol_SrvMTC_USCORECommandExecNotify SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREAlarmRequest SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREAlarmResponse SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREAlarmNotification SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREStatusRequest SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREStatusResponse SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREStatusNotification SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREDiagnosticRequest SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREDiagnosticResponse SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREVersionRequest SOAP_UNION__ns1__union_protocol_SrvFE_USCOREMTC_USCOREVersionResponse SOAP_UNION__ns1__union_protocol_SrvNewConfigurationNotification SOAP_UNION__ns1__union_protocol_SrvNewConfigurationConfirmation SOAP_UNION__ns1__union_protocol_SrvNewConfigurationInfoRequest SOAP_UNION__ns1__union_protocol_SrvNewConfigurationInforResponse SOAP_UNION__ns1__union_protocol_SrvNewConfigurationContentRequest SOAP_UNION__ns1__union_protocol_SrvNewConfigurationContentResponse SOAP_UNION__ns1__union_protocol_SrvFileNotification SOAP_UNION__ns1__union_protocol_SrvFileConfirmation SOAP_UNION__ns1__union_protocol_SrvOrderNotification SOAP_UNION__ns1__union_protocol_SrvOrderConfirmation SOAP_UNION__ns1__union_protocol_versionList
        int __union_protocol;
        union _ns1__union_protocol union_protocol;
        /// required attribute 'version' of XSD type 'xsd:string'
        char *version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__protocol
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__protocol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__protocol, default initialized and not managed by a soap context
        virtual _ns1__protocol *soap_alloc(void) const { return SOAP_NEW(_ns1__protocol); }
      public:
        /// Constructor with initializations
        _ns1__protocol() : __union_protocol(), version(), soap() { }
        virtual ~_ns1__protocol() { }
        /// Friend allocator used by soap_new__ns1__protocol(struct soap*, int)
        friend SOAP_FMAC1 _ns1__protocol * SOAP_FMAC2 soap_instantiate__ns1__protocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1334 */
#ifndef SOAP_TYPE_ns2__ConfigurationDocument
#define SOAP_TYPE_ns2__ConfigurationDocument (394)
/* Type ns2__ConfigurationDocument is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:ConfigurationDocument': */
class SOAP_CMAC ns2__ConfigurationDocument : public xsd__anyType {
      public:
        /// Required element 'header' of XSD type 'ns2:Header'
        ns2__Header *header;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ConfigurationDocument
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ConfigurationDocument; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ConfigurationDocument, default initialized and not managed by a soap context
        virtual ns2__ConfigurationDocument *soap_alloc(void) const { return SOAP_NEW(ns2__ConfigurationDocument); }
      public:
        /// Constructor with initializations
        ns2__ConfigurationDocument() : header() { }
        virtual ~ns2__ConfigurationDocument() { }
        /// Friend allocator used by soap_new_ns2__ConfigurationDocument(struct soap*, int)
        friend SOAP_FMAC1 ns2__ConfigurationDocument * SOAP_FMAC2 soap_instantiate_ns2__ConfigurationDocument(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1337 */
#ifndef SOAP_TYPE_ns2__Header
#define SOAP_TYPE_ns2__Header (395)
/* Type ns2__Header is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Header': */
class SOAP_CMAC ns2__Header : public xsd__anyType {
      public:
        /// Required element 'formatVersion' of XSD type 'xsd:unsignedInt'
        unsigned int formatVersion;
        /// Required element 'configurationVersion' of XSD type 'xsd:unsignedInt'
        unsigned int configurationVersion;
        /// Optional element 'configurationIncVersion' of XSD type 'xsd:unsignedInt'
        unsigned int *configurationIncVersion;
        /// Required element 'generationDate' of XSD type 'xsd:dateTime'
        time_t generationDate;
        /// Required element 'activationDate' of XSD type 'xsd:dateTime'
        time_t activationDate;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Header
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Header; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Header, default initialized and not managed by a soap context
        virtual ns2__Header *soap_alloc(void) const { return SOAP_NEW(ns2__Header); }
      public:
        /// Constructor with initializations
        ns2__Header() : formatVersion(), configurationVersion(), configurationIncVersion(), generationDate(), activationDate() { }
        virtual ~ns2__Header() { }
        /// Friend allocator used by soap_new_ns2__Header(struct soap*, int)
        friend SOAP_FMAC1 ns2__Header * SOAP_FMAC2 soap_instantiate_ns2__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1340 */
#ifndef SOAP_TYPE_ns2__NameSetList
#define SOAP_TYPE_ns2__NameSetList (396)
/* Type ns2__NameSetList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:NameSetList': */
class SOAP_CMAC ns2__NameSetList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'nameSet' of XSD type 'ns2:NameSet' stored in dynamic array nameSet of length __sizenameSet
        int __sizenameSet;
        ns2__NameSet **nameSet;
        /// optional attribute 'length' of XSD type 'xsd:positiveInteger'
        char *length;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NameSetList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NameSetList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NameSetList, default initialized and not managed by a soap context
        virtual ns2__NameSetList *soap_alloc(void) const { return SOAP_NEW(ns2__NameSetList); }
      public:
        /// Constructor with initializations
        ns2__NameSetList() : __sizenameSet(), nameSet(), length() { }
        virtual ~ns2__NameSetList() { }
        /// Friend allocator used by soap_new_ns2__NameSetList(struct soap*, int)
        friend SOAP_FMAC1 ns2__NameSetList * SOAP_FMAC2 soap_instantiate_ns2__NameSetList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1343 */
#ifndef SOAP_TYPE_ns2__NameSet
#define SOAP_TYPE_ns2__NameSet (397)
/* Type ns2__NameSet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:NameSet': */
class SOAP_CMAC ns2__NameSet : public xsd__anyType {
      public:
        /// Required element 'name' of XSD type 'xsd:string'
        char *name;
        /// Optional element 'nameLong' of XSD type 'xsd:string'
        char *nameLong;
        /// Optional element 'display' of XSD type 'xsd:string'
        char *display;
        /// Optional element 'displayLong' of XSD type 'xsd:string'
        char *displayLong;
        /// Optional element 'receipt' of XSD type 'xsd:string'
        char *receipt;
        /// Optional element 'receiptLong' of XSD type 'xsd:string'
        char *receiptLong;
        /// Optional element 'abbr' of XSD type 'xsd:string'
        char *abbr;
        /// Optional element 'desc' of XSD type 'xsd:string'
        char *desc;
        /// required attribute 'lang' of XSD type 'xsd:language'
        char *lang;
      public:
        /// Return unique type id SOAP_TYPE_ns2__NameSet
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__NameSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__NameSet, default initialized and not managed by a soap context
        virtual ns2__NameSet *soap_alloc(void) const { return SOAP_NEW(ns2__NameSet); }
      public:
        /// Constructor with initializations
        ns2__NameSet() : name(), nameLong(), display(), displayLong(), receipt(), receiptLong(), abbr(), desc(), lang() { }
        virtual ~ns2__NameSet() { }
        /// Friend allocator used by soap_new_ns2__NameSet(struct soap*, int)
        friend SOAP_FMAC1 ns2__NameSet * SOAP_FMAC2 soap_instantiate_ns2__NameSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1346 */
#ifndef SOAP_TYPE_ns2__DistanceMatrixElement
#define SOAP_TYPE_ns2__DistanceMatrixElement (398)
/* Type ns2__DistanceMatrixElement is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:DistanceMatrixElement': */
class SOAP_CMAC ns2__DistanceMatrixElement : public xsd__anyType {
      public:
        /// Required element 'distances' of XSD type 'ns2:DistanceList'
        ns2__DistanceList *distances;
        /// Required element 'originId' of XSD type 'xsd:unsignedInt'
        unsigned int originId;
        /// Required element 'destinationId' of XSD type 'xsd:unsignedInt'
        unsigned int destinationId;
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DistanceMatrixElement
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DistanceMatrixElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DistanceMatrixElement, default initialized and not managed by a soap context
        virtual ns2__DistanceMatrixElement *soap_alloc(void) const { return SOAP_NEW(ns2__DistanceMatrixElement); }
      public:
        /// Constructor with initializations
        ns2__DistanceMatrixElement() : distances(), originId(), destinationId(), id() { }
        virtual ~ns2__DistanceMatrixElement() { }
        /// Friend allocator used by soap_new_ns2__DistanceMatrixElement(struct soap*, int)
        friend SOAP_FMAC1 ns2__DistanceMatrixElement * SOAP_FMAC2 soap_instantiate_ns2__DistanceMatrixElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1349 */
#ifndef SOAP_TYPE_ns2__DistanceList
#define SOAP_TYPE_ns2__DistanceList (399)
/* Type ns2__DistanceList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:DistanceList': */
class SOAP_CMAC ns2__DistanceList : public xsd__anyType {
      public:
        /// Sequence of at least 1 elements 'distance' of XSD type 'ns2:Distance' stored in dynamic array distance of length __sizedistance
        int __sizedistance;
        ns2__Distance **distance;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DistanceList
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DistanceList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DistanceList, default initialized and not managed by a soap context
        virtual ns2__DistanceList *soap_alloc(void) const { return SOAP_NEW(ns2__DistanceList); }
      public:
        /// Constructor with initializations
        ns2__DistanceList() : __sizedistance(), distance() { }
        virtual ~ns2__DistanceList() { }
        /// Friend allocator used by soap_new_ns2__DistanceList(struct soap*, int)
        friend SOAP_FMAC1 ns2__DistanceList * SOAP_FMAC2 soap_instantiate_ns2__DistanceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1352 */
#ifndef SOAP_TYPE_ns2__Distance
#define SOAP_TYPE_ns2__Distance (400)
/* Type ns2__Distance is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns2:Distance': */
class SOAP_CMAC ns2__Distance : public xsd__anyType {
      public:
        /// Required element 'Distance' of XSD type 'xsd:unsignedInt'
        unsigned int Distance;
        /// optional attribute 'type' of XSD type 'xsd:long'
        LONG64 *type;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Distance
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Distance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Distance, default initialized and not managed by a soap context
        virtual ns2__Distance *soap_alloc(void) const { return SOAP_NEW(ns2__Distance); }
      public:
        /// Constructor with initializations
        ns2__Distance() : Distance(), type() { }
        virtual ~ns2__Distance() { }
        /// Friend allocator used by soap_new_ns2__Distance(struct soap*, int)
        friend SOAP_FMAC1 ns2__Distance * SOAP_FMAC2 soap_instantiate_ns2__Distance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:287 */
#ifndef SOAP_TYPE_ns1__SrvConfigurationInfoRequestType
#define SOAP_TYPE_ns1__SrvConfigurationInfoRequestType (45)
/* Type ns1__SrvConfigurationInfoRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvConfigurationInfoRequestType': */
class SOAP_CMAC ns1__SrvConfigurationInfoRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Sequence of elements 'pkgId' of XSD type 'xsd:unsignedInt' stored in dynamic array pkgId of length __sizepkgId
        int __sizepkgId;
        unsigned int *pkgId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvConfigurationInfoRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvConfigurationInfoRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvConfigurationInfoRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvConfigurationInfoRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvConfigurationInfoRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvConfigurationInfoRequestType() : __sizepkgId(), pkgId() { }
        virtual ~ns1__SrvConfigurationInfoRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvConfigurationInfoRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvConfigurationInfoRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvConfigurationInfoRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:299 */
#ifndef SOAP_TYPE_ns1__SrvRecordRequestType
#define SOAP_TYPE_ns1__SrvRecordRequestType (49)
/* Type ns1__SrvRecordRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvRecordRequestType': */
class SOAP_CMAC ns1__SrvRecordRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Optional element 'rngList' of XSD type 'ns1:RecordRangeIdTypeList'
        ns1__RecordRangeIdTypeList *rngList;
        /// Optional element 'rng' of XSD type 'ns1:RecordRangeIdType'
        ns1__RecordRangeIdType *rng;
        /// Optional element 'cutomRecordRequest' of XSD type 'ns1:CustomRecordRequest'
        ns1__CustomRecordRequest *cutomRecordRequest;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvRecordRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvRecordRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvRecordRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvRecordRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvRecordRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvRecordRequestType() : rngList(), rng(), cutomRecordRequest() { }
        virtual ~ns1__SrvRecordRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvRecordRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvRecordRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvRecordRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:320 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionRequestType (56)
/* Type ns1__SrvMTC_USCORETransactionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_TransactionRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCORETransactionRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Optional element 'rngList' of XSD type 'ns1:TransactionMTCIdRangeListType'
        ns1__TransactionMTCIdRangeListType *rngList;
        /// Optional element 'rng' of XSD type 'ns1:TransactionMTCIdRangeType'
        ns1__TransactionMTCIdRangeType *rng;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORETransactionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORETransactionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORETransactionRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORETransactionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORETransactionRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORETransactionRequestType() : rngList(), rng() { }
        virtual ~ns1__SrvMTC_USCORETransactionRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORETransactionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORETransactionRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORETransactionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:332 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType (60)
/* Type ns1__SrvFE_USCOREMTC_USCORETransactionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_TransactionRequestType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCORETransactionRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Optional element 'rngList' of XSD type 'ns1:TransactionMTCIdRangeListType'
        ns1__TransactionMTCIdRangeListType *rngList;
        /// Optional element 'rng' of XSD type 'ns1:TransactionMTCIdRangeType'
        ns1__TransactionMTCIdRangeType *rng;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCORETransactionRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCORETransactionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCORETransactionRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCORETransactionRequestType() : rngList(), rng() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCORETransactionRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCORETransactionRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:335 */
#ifndef SOAP_TYPE_ns1__SrvStateRequestType
#define SOAP_TYPE_ns1__SrvStateRequestType (61)
/* Type ns1__SrvStateRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvStateRequestType': */
class SOAP_CMAC ns1__SrvStateRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvStateRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvStateRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvStateRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvStateRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvStateRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvStateRequestType() { }
        virtual ~ns1__SrvStateRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvStateRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvStateRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvStateRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:338 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREAlarmRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREAlarmRequestType (62)
/* Type ns1__SrvMTC_USCOREAlarmRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_AlarmRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCOREAlarmRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREAlarmRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREAlarmRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREAlarmRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREAlarmRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREAlarmRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREAlarmRequestType() { }
        virtual ~ns1__SrvMTC_USCOREAlarmRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREAlarmRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREAlarmRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREAlarmRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:341 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREStatusRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREStatusRequestType (63)
/* Type ns1__SrvMTC_USCOREStatusRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_StatusRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCOREStatusRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREStatusRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREStatusRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREStatusRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREStatusRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREStatusRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREStatusRequestType() { }
        virtual ~ns1__SrvMTC_USCOREStatusRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREStatusRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREStatusRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREStatusRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:344 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticRequestType (64)
/* Type ns1__SrvMTC_USCOREDiagnosticRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_DiagnosticRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCOREDiagnosticRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREDiagnosticRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREDiagnosticRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREDiagnosticRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREDiagnosticRequestType() { }
        virtual ~ns1__SrvMTC_USCOREDiagnosticRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREDiagnosticRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREDiagnosticRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREDiagnosticRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:347 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREVersionRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREVersionRequestType (65)
/* Type ns1__SrvMTC_USCOREVersionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_VersionRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCOREVersionRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREVersionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREVersionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREVersionRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREVersionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREVersionRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREVersionRequestType() { }
        virtual ~ns1__SrvMTC_USCOREVersionRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREVersionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREVersionRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREVersionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:350 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementRequestType (66)
/* Type ns1__SrvMTC_USCOREConfigElementRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_ConfigElementRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCOREConfigElementRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREConfigElementRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREConfigElementRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREConfigElementRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREConfigElementRequestType() { }
        virtual ~ns1__SrvMTC_USCOREConfigElementRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREConfigElementRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREConfigElementRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREConfigElementRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:353 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeRequestType (67)
/* Type ns1__SrvMTC_USCOREConfigElementChangeRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_ConfigElementChangeRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCOREConfigElementChangeRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Required element 'configElemList' of XSD type 'ns1:ConfigElementCCTIUListType'
        ns1__ConfigElementCCTIUListType *configElemList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREConfigElementChangeRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREConfigElementChangeRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREConfigElementChangeRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREConfigElementChangeRequestType() : configElemList() { }
        virtual ~ns1__SrvMTC_USCOREConfigElementChangeRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREConfigElementChangeRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREConfigElementChangeRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREConfigElementChangeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:365 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORECommandExecRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCORECommandExecRequestType (71)
/* Type ns1__SrvMTC_USCORECommandExecRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_CommandExecRequestType': */
class SOAP_CMAC ns1__SrvMTC_USCORECommandExecRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Required element 'command' of XSD type 'ns1:CommandCCTIUType'
        ns1__CommandCCTIUType *command;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORECommandExecRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORECommandExecRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORECommandExecRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORECommandExecRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORECommandExecRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORECommandExecRequestType() : command() { }
        virtual ~ns1__SrvMTC_USCORECommandExecRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORECommandExecRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORECommandExecRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORECommandExecRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:377 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType (75)
/* Type ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_AlarmRequestType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:380 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType (76)
/* Type ns1__SrvFE_USCOREMTC_USCOREStatusRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_StatusRequestType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREStatusRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREStatusRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREStatusRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREStatusRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREStatusRequestType() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREStatusRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREStatusRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:383 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType (77)
/* Type ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_DiagnosticRequestType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:386 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType (78)
/* Type ns1__SrvFE_USCOREMTC_USCOREVersionRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_VersionRequestType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREVersionRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREVersionRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREVersionRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREVersionRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREVersionRequestType() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREVersionRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREVersionRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:389 */
#ifndef SOAP_TYPE_ns1__SrvConfigurationContentRequestType
#define SOAP_TYPE_ns1__SrvConfigurationContentRequestType (79)
/* Type ns1__SrvConfigurationContentRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvConfigurationContentRequestType': */
class SOAP_CMAC ns1__SrvConfigurationContentRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Required element 'file' of XSD type 'ns1:FileConfigVersionType'
        ns1__FileConfigVersionType *file;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvConfigurationContentRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvConfigurationContentRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvConfigurationContentRequestType, default initialized and not managed by a soap context
        virtual ns1__SrvConfigurationContentRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvConfigurationContentRequestType); }
      public:
        /// Constructor with initializations
        ns1__SrvConfigurationContentRequestType() : file() { }
        virtual ~ns1__SrvConfigurationContentRequestType() { }
        /// Friend allocator used by soap_new_ns1__SrvConfigurationContentRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvConfigurationContentRequestType * SOAP_FMAC2 soap_instantiate_ns1__SrvConfigurationContentRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:395 */
#ifndef SOAP_TYPE_ns1__srvPresentationBaseRequestType
#define SOAP_TYPE_ns1__srvPresentationBaseRequestType (81)
/* Type ns1__srvPresentationBaseRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvPresentationBaseRequestType': */
class SOAP_CMAC ns1__srvPresentationBaseRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvPresentationBaseRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvPresentationBaseRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvPresentationBaseRequestType, default initialized and not managed by a soap context
        virtual ns1__srvPresentationBaseRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__srvPresentationBaseRequestType); }
      public:
        /// Constructor with initializations
        ns1__srvPresentationBaseRequestType() { }
        virtual ~ns1__srvPresentationBaseRequestType() { }
        /// Friend allocator used by soap_new_ns1__srvPresentationBaseRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvPresentationBaseRequestType * SOAP_FMAC2 soap_instantiate_ns1__srvPresentationBaseRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:401 */
#ifndef SOAP_TYPE_ns1__srvConfigurationBaseRequestType
#define SOAP_TYPE_ns1__srvConfigurationBaseRequestType (83)
/* Type ns1__srvConfigurationBaseRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvConfigurationBaseRequestType': */
class SOAP_CMAC ns1__srvConfigurationBaseRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvConfigurationBaseRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvConfigurationBaseRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvConfigurationBaseRequestType, default initialized and not managed by a soap context
        virtual ns1__srvConfigurationBaseRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__srvConfigurationBaseRequestType); }
      public:
        /// Constructor with initializations
        ns1__srvConfigurationBaseRequestType() { }
        virtual ~ns1__srvConfigurationBaseRequestType() { }
        /// Friend allocator used by soap_new_ns1__srvConfigurationBaseRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvConfigurationBaseRequestType * SOAP_FMAC2 soap_instantiate_ns1__srvConfigurationBaseRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:407 */
#ifndef SOAP_TYPE_ns1__srvCommandBaseRequestType
#define SOAP_TYPE_ns1__srvCommandBaseRequestType (85)
/* Type ns1__srvCommandBaseRequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvCommandBaseRequestType': */
class SOAP_CMAC ns1__srvCommandBaseRequestType : public ns1__PatternServiceRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvCommandBaseRequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvCommandBaseRequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvCommandBaseRequestType, default initialized and not managed by a soap context
        virtual ns1__srvCommandBaseRequestType *soap_alloc(void) const { return SOAP_NEW(ns1__srvCommandBaseRequestType); }
      public:
        /// Constructor with initializations
        ns1__srvCommandBaseRequestType() { }
        virtual ~ns1__srvCommandBaseRequestType() { }
        /// Friend allocator used by soap_new_ns1__srvCommandBaseRequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvCommandBaseRequestType * SOAP_FMAC2 soap_instantiate_ns1__srvCommandBaseRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:416 */
#ifndef SOAP_TYPE_ns1__SrvConfigurationInfoResponseType
#define SOAP_TYPE_ns1__SrvConfigurationInfoResponseType (88)
/* Type ns1__SrvConfigurationInfoResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvConfigurationInfoResponseType': */
class SOAP_CMAC ns1__SrvConfigurationInfoResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'pkgList' of XSD type 'ns1:PackageConfigVersionListType'
        ns1__PackageConfigVersionListType *pkgList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvConfigurationInfoResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvConfigurationInfoResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvConfigurationInfoResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvConfigurationInfoResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvConfigurationInfoResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvConfigurationInfoResponseType() : pkgList() { }
        virtual ~ns1__SrvConfigurationInfoResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvConfigurationInfoResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvConfigurationInfoResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvConfigurationInfoResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:431 */
#ifndef SOAP_TYPE_ns1__SrvRecordResponseType
#define SOAP_TYPE_ns1__SrvRecordResponseType (93)
/* Type ns1__SrvRecordResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvRecordResponseType': */
class SOAP_CMAC ns1__SrvRecordResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Optional element 'result' of XSD type 'ns1:ResultWS'
        ns1__ResultWS *result;
        /// Optional element 'recList' of XSD type 'ns1:RecordListType'
        ns1__RecordListType *recList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvRecordResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvRecordResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvRecordResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvRecordResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvRecordResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvRecordResponseType() : result(), recList() { }
        virtual ~ns1__SrvRecordResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvRecordResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvRecordResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvRecordResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:446 */
#ifndef SOAP_TYPE_ns1__StartUpRecordType
#define SOAP_TYPE_ns1__StartUpRecordType (98)
/* Type ns1__StartUpRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StartUpRecordType': */
class SOAP_CMAC ns1__StartUpRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'pL' of XSD type 'ns1:stPackageListType'
        ns1__stPackageListType *pL;
        /// required attribute 'hN' of XSD type 'xsd:string'
        char *hN;
        /// required attribute 'iAdd' of XSD type 'xsd:string'
        char *iAdd;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StartUpRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StartUpRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StartUpRecordType, default initialized and not managed by a soap context
        virtual ns1__StartUpRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__StartUpRecordType); }
      public:
        /// Constructor with initializations
        ns1__StartUpRecordType() : pL(), hN(), iAdd() { }
        virtual ~ns1__StartUpRecordType() { }
        /// Friend allocator used by soap_new_ns1__StartUpRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StartUpRecordType * SOAP_FMAC2 soap_instantiate_ns1__StartUpRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:479 */
#ifndef SOAP_TYPE_ns1__FixedLocation
#define SOAP_TYPE_ns1__FixedLocation (109)
/* Type ns1__FixedLocation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FixedLocation': */
class SOAP_CMAC ns1__FixedLocation : public ns1__EquipmentLocation {
      public:
        /// Required element 'area' of XSD type 'xsd:unsignedInt'
        unsigned int area;
        /// Required element 'pos' of XSD type 'xsd:unsignedInt'
        unsigned int pos;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FixedLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FixedLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FixedLocation, default initialized and not managed by a soap context
        virtual ns1__FixedLocation *soap_alloc(void) const { return SOAP_NEW(ns1__FixedLocation); }
      public:
        /// Constructor with initializations
        ns1__FixedLocation() : area(), pos() { }
        virtual ~ns1__FixedLocation() { }
        /// Friend allocator used by soap_new_ns1__FixedLocation(struct soap*, int)
        friend SOAP_FMAC1 ns1__FixedLocation * SOAP_FMAC2 soap_instantiate_ns1__FixedLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:485 */
#ifndef SOAP_TYPE_ns1__OnboardLocation
#define SOAP_TYPE_ns1__OnboardLocation (111)
/* Type ns1__OnboardLocation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OnboardLocation': */
class SOAP_CMAC ns1__OnboardLocation : public ns1__EquipmentLocation {
      public:
        /// Required element 'veh' of XSD type 'xsd:unsignedInt'
        unsigned int veh;
        /// Required element 'pos' of XSD type 'xsd:unsignedInt'
        unsigned int pos;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OnboardLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OnboardLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OnboardLocation, default initialized and not managed by a soap context
        virtual ns1__OnboardLocation *soap_alloc(void) const { return SOAP_NEW(ns1__OnboardLocation); }
      public:
        /// Constructor with initializations
        ns1__OnboardLocation() : veh(), pos() { }
        virtual ~ns1__OnboardLocation() { }
        /// Friend allocator used by soap_new_ns1__OnboardLocation(struct soap*, int)
        friend SOAP_FMAC1 ns1__OnboardLocation * SOAP_FMAC2 soap_instantiate_ns1__OnboardLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:488 */
#ifndef SOAP_TYPE_ns1__OperationalLocation
#define SOAP_TYPE_ns1__OperationalLocation (112)
/* Type ns1__OperationalLocation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OperationalLocation': */
class SOAP_CMAC ns1__OperationalLocation : public ns1__OperationalLocationBase {
      public:
        /// Required element 'agn' of XSD type 'xsd:unsignedInt'
        unsigned int agn;
        /// Required element 'srv' of XSD type 'xsd:unsignedInt'
        unsigned int srv;
        /// Required element 'lin' of XSD type 'xsd:unsignedInt'
        unsigned int lin;
        /// Required element 'stn' of XSD type 'xsd:unsignedInt'
        unsigned int stn;
        /// Optional element 'dir' of XSD type 'xsd:unsignedInt'
        unsigned int *dir;
        /// Optional element 'veh' of XSD type 'xsd:unsignedInt'
        unsigned int *veh;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OperationalLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OperationalLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OperationalLocation, default initialized and not managed by a soap context
        virtual ns1__OperationalLocation *soap_alloc(void) const { return SOAP_NEW(ns1__OperationalLocation); }
      public:
        /// Constructor with initializations
        ns1__OperationalLocation() : agn(), srv(), lin(), stn(), dir(), veh() { }
        virtual ~ns1__OperationalLocation() { }
        /// Friend allocator used by soap_new_ns1__OperationalLocation(struct soap*, int)
        friend SOAP_FMAC1 ns1__OperationalLocation * SOAP_FMAC2 soap_instantiate_ns1__OperationalLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:494 */
#ifndef SOAP_TYPE_ns1__AVLocation
#define SOAP_TYPE_ns1__AVLocation (114)
/* Type ns1__AVLocation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AVLocation': */
class SOAP_CMAC ns1__AVLocation : public ns1__OperationalLocationBase {
      public:
        /// Required element 'route' of XSD type 'xsd:unsignedInt'
        unsigned int route;
        /// Required element 'stop' of XSD type 'xsd:unsignedInt'
        unsigned int stop;
        /// Required element 'dir' of XSD type 'xsd:unsignedInt'
        unsigned int dir;
        /// Optional element 'order' of XSD type 'xsd:unsignedInt'
        unsigned int *order;
        /// Optional element 'veh' of XSD type 'xsd:unsignedInt'
        unsigned int *veh;
        /// Optional element 'sched' of XSD type 'ns1:Schedule'
        ns1__Schedule *sched;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AVLocation
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AVLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AVLocation, default initialized and not managed by a soap context
        virtual ns1__AVLocation *soap_alloc(void) const { return SOAP_NEW(ns1__AVLocation); }
      public:
        /// Constructor with initializations
        ns1__AVLocation() : route(), stop(), dir(), order(), veh(), sched() { }
        virtual ~ns1__AVLocation() { }
        /// Friend allocator used by soap_new_ns1__AVLocation(struct soap*, int)
        friend SOAP_FMAC1 ns1__AVLocation * SOAP_FMAC2 soap_instantiate_ns1__AVLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:509 */
#ifndef SOAP_TYPE_ns1__ValidationRecordType
#define SOAP_TYPE_ns1__ValidationRecordType (119)
/* Type ns1__ValidationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ValidationRecordType': */
class SOAP_CMAC ns1__ValidationRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'sId' of XSD type 'xsd:long'
        LONG64 *sId;
        /// Optional element 'fare' of XSD type 'ns1:FareProductType'
        ns1__FareProductType *fare;
        /// Optional element 'fareInfo' of XSD type 'ns1:FareInfo'
        ns1__FareInfo *fareInfo;
        /// Optional element 'val' of XSD type 'ns1:ValidationOpType'
        ns1__ValidationOpType *val;
        /// Optional element 'valInfo' of XSD type 'ns1:ValidationInfo'
        ns1__ValidationInfo *valInfo;
        /// Optional element 'card' of XSD type 'ns1:cardIdentificationType'
        ns1__cardIdentificationType *card;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// Optional element 'relTrans' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *relTrans;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ValidationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ValidationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ValidationRecordType, default initialized and not managed by a soap context
        virtual ns1__ValidationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__ValidationRecordType); }
      public:
        /// Constructor with initializations
        ns1__ValidationRecordType() : shift(), sId(), fare(), fareInfo(), val(), valInfo(), card(), ctlInfo(), ctlData(), cData(), rawData(), relTrans() { }
        virtual ~ns1__ValidationRecordType() { }
        /// Friend allocator used by soap_new_ns1__ValidationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ValidationRecordType * SOAP_FMAC2 soap_instantiate_ns1__ValidationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:515 */
#ifndef SOAP_TYPE_ns1__FareProductType
#define SOAP_TYPE_ns1__FareProductType (121)
/* Type ns1__FareProductType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:FareProductType': */
class SOAP_CMAC ns1__FareProductType : public ns1__TitleCodeType {
      public:
        /// Required element 'f' of XSD type 'ns1:FareType'
        ns1__FareType *f;
      public:
        /// Return unique type id SOAP_TYPE_ns1__FareProductType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__FareProductType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__FareProductType, default initialized and not managed by a soap context
        virtual ns1__FareProductType *soap_alloc(void) const { return SOAP_NEW(ns1__FareProductType); }
      public:
        /// Constructor with initializations
        ns1__FareProductType() : f() { }
        virtual ~ns1__FareProductType() { }
        /// Friend allocator used by soap_new_ns1__FareProductType(struct soap*, int)
        friend SOAP_FMAC1 ns1__FareProductType * SOAP_FMAC2 soap_instantiate_ns1__FareProductType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:557 */
#ifndef SOAP_TYPE_ns1__PrintedInvoiceRecordType
#define SOAP_TYPE_ns1__PrintedInvoiceRecordType (135)
/* Type ns1__PrintedInvoiceRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PrintedInvoiceRecordType': */
class SOAP_CMAC ns1__PrintedInvoiceRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'receipt' of XSD type 'ns1:InvoiceReceiptType'
        ns1__InvoiceReceiptType *receipt;
        /// Required element 'hash' of XSD type 'xsd:string'
        char *hash;
        /// Optional element 'relTrans' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *relTrans;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PrintedInvoiceRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PrintedInvoiceRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PrintedInvoiceRecordType, default initialized and not managed by a soap context
        virtual ns1__PrintedInvoiceRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__PrintedInvoiceRecordType); }
      public:
        /// Constructor with initializations
        ns1__PrintedInvoiceRecordType() : shift(), receipt(), hash(), relTrans() { }
        virtual ~ns1__PrintedInvoiceRecordType() { }
        /// Friend allocator used by soap_new_ns1__PrintedInvoiceRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PrintedInvoiceRecordType * SOAP_FMAC2 soap_instantiate_ns1__PrintedInvoiceRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:566 */
#ifndef SOAP_TYPE_ns1__ReceiptItem
#define SOAP_TYPE_ns1__ReceiptItem (138)
/* Type ns1__ReceiptItem is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:ReceiptItem': */
class SOAP_CMAC ns1__ReceiptItem : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        char *__item;
        /// optional attribute 'type' of XSD type 'xsd:unsignedInt'
        unsigned int *type;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ReceiptItem
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ReceiptItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ReceiptItem, default initialized and not managed by a soap context
        virtual ns1__ReceiptItem *soap_alloc(void) const { return SOAP_NEW(ns1__ReceiptItem); }
      public:
        /// Constructor with initializations
        ns1__ReceiptItem() : __item(), type() { }
        virtual ~ns1__ReceiptItem() { }
        /// Friend allocator used by soap_new_ns1__ReceiptItem(struct soap*, int)
        friend SOAP_FMAC1 ns1__ReceiptItem * SOAP_FMAC2 soap_instantiate_ns1__ReceiptItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:569 */
#ifndef SOAP_TYPE_ns1__AccountingOperationRecordType
#define SOAP_TYPE_ns1__AccountingOperationRecordType (139)
/* Type ns1__AccountingOperationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AccountingOperationRecordType': */
class SOAP_CMAC ns1__AccountingOperationRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'acop' of XSD type 'ns1:AccountingOpType'
        ns1__AccountingOpType *acop;
        /// Optional element 'accinfo' of XSD type 'ns1:AccountingOperationInfo'
        ns1__AccountingOperationInfo *accinfo;
        /// Optional element 'units' of XSD type 'ns1:AccountingUnitListType'
        ns1__AccountingUnitListType *units;
        /// Optional element 'failures' of XSD type 'ns1:AccountingFailureListType'
        ns1__AccountingFailureListType *failures;
        /// Required element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
        /// Optional element 'cnil' of XSD type 'ns1:CoinNoteInsertedListType'
        ns1__CoinNoteInsertedListType *cnil;
        /// Optional element 'cnrl' of XSD type 'ns1:CoinNoteReturnedListType'
        ns1__CoinNoteReturnedListType *cnrl;
        /// Optional element 'receipt' of XSD type 'ns1:AccountingReceiptType'
        ns1__AccountingReceiptType *receipt;
        /// Optional element 'relTrans' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *relTrans;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AccountingOperationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AccountingOperationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AccountingOperationRecordType, default initialized and not managed by a soap context
        virtual ns1__AccountingOperationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__AccountingOperationRecordType); }
      public:
        /// Constructor with initializations
        ns1__AccountingOperationRecordType() : shift(), acop(), accinfo(), units(), failures(), payments(), awards(), cnil(), cnrl(), receipt(), relTrans() { }
        virtual ~ns1__AccountingOperationRecordType() { }
        /// Friend allocator used by soap_new_ns1__AccountingOperationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AccountingOperationRecordType * SOAP_FMAC2 soap_instantiate_ns1__AccountingOperationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:635 */
#ifndef SOAP_TYPE_ns1__IdentificationRecordType
#define SOAP_TYPE_ns1__IdentificationRecordType (161)
/* Type ns1__IdentificationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:IdentificationRecordType': */
class SOAP_CMAC ns1__IdentificationRecordType : public ns1__BaseRecordType {
      public:
        /// required attribute 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// required attribute 'prof' of XSD type 'xsd:long'
        LONG64 prof;
        /// required attribute 'rst' of XSD type 'xsd:int'
        int rst;
        /// required attribute 'mth' of XSD type 'xsd:int'
        int mth;
      public:
        /// Return unique type id SOAP_TYPE_ns1__IdentificationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__IdentificationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__IdentificationRecordType, default initialized and not managed by a soap context
        virtual ns1__IdentificationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__IdentificationRecordType); }
      public:
        /// Constructor with initializations
        ns1__IdentificationRecordType() : userId(), prof(), rst(), mth() { }
        virtual ~ns1__IdentificationRecordType() { }
        /// Friend allocator used by soap_new_ns1__IdentificationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__IdentificationRecordType * SOAP_FMAC2 soap_instantiate_ns1__IdentificationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:638 */
#ifndef SOAP_TYPE_ns1__StartOfSessionRecordType
#define SOAP_TYPE_ns1__StartOfSessionRecordType (162)
/* Type ns1__StartOfSessionRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StartOfSessionRecordType': */
class SOAP_CMAC ns1__StartOfSessionRecordType : public ns1__BaseRecordType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__StartOfSessionRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StartOfSessionRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StartOfSessionRecordType, default initialized and not managed by a soap context
        virtual ns1__StartOfSessionRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__StartOfSessionRecordType); }
      public:
        /// Constructor with initializations
        ns1__StartOfSessionRecordType() { }
        virtual ~ns1__StartOfSessionRecordType() { }
        /// Friend allocator used by soap_new_ns1__StartOfSessionRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StartOfSessionRecordType * SOAP_FMAC2 soap_instantiate_ns1__StartOfSessionRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:641 */
#ifndef SOAP_TYPE_ns1__EndOfSessionRecordType
#define SOAP_TYPE_ns1__EndOfSessionRecordType (163)
/* Type ns1__EndOfSessionRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:EndOfSessionRecordType': */
class SOAP_CMAC ns1__EndOfSessionRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'drL' of XSD type 'ns1:dataReportListType'
        ns1__dataReportListType *drL;
        /// Optional element 'slaveReports' of XSD type 'ns1:SlaveDataReportListType'
        ns1__SlaveDataReportListType *slaveReports;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EndOfSessionRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EndOfSessionRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EndOfSessionRecordType, default initialized and not managed by a soap context
        virtual ns1__EndOfSessionRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__EndOfSessionRecordType); }
      public:
        /// Constructor with initializations
        ns1__EndOfSessionRecordType() : drL(), slaveReports() { }
        virtual ~ns1__EndOfSessionRecordType() { }
        /// Friend allocator used by soap_new_ns1__EndOfSessionRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__EndOfSessionRecordType * SOAP_FMAC2 soap_instantiate_ns1__EndOfSessionRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:656 */
#ifndef SOAP_TYPE_ns1__OpEndOfSessionRecordType
#define SOAP_TYPE_ns1__OpEndOfSessionRecordType (168)
/* Type ns1__OpEndOfSessionRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OpEndOfSessionRecordType': */
class SOAP_CMAC ns1__OpEndOfSessionRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'drL' of XSD type 'ns1:dataReportListType'
        ns1__dataReportListType *drL;
        /// Required element 'mdL' of XSD type 'ns1:missingDataListType'
        ns1__missingDataListType *mdL;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OpEndOfSessionRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OpEndOfSessionRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OpEndOfSessionRecordType, default initialized and not managed by a soap context
        virtual ns1__OpEndOfSessionRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__OpEndOfSessionRecordType); }
      public:
        /// Constructor with initializations
        ns1__OpEndOfSessionRecordType() : drL(), mdL() { }
        virtual ~ns1__OpEndOfSessionRecordType() { }
        /// Friend allocator used by soap_new_ns1__OpEndOfSessionRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OpEndOfSessionRecordType * SOAP_FMAC2 soap_instantiate_ns1__OpEndOfSessionRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:665 */
#ifndef SOAP_TYPE_ns1__BeginShiftRecordType
#define SOAP_TYPE_ns1__BeginShiftRecordType (171)
/* Type ns1__BeginShiftRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:BeginShiftRecordType': */
class SOAP_CMAC ns1__BeginShiftRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// required attribute 'idfT' of XSD type 'xsd:int'
        int idfT;
      public:
        /// Return unique type id SOAP_TYPE_ns1__BeginShiftRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__BeginShiftRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__BeginShiftRecordType, default initialized and not managed by a soap context
        virtual ns1__BeginShiftRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__BeginShiftRecordType); }
      public:
        /// Constructor with initializations
        ns1__BeginShiftRecordType() : shift(), idfT() { }
        virtual ~ns1__BeginShiftRecordType() { }
        /// Friend allocator used by soap_new_ns1__BeginShiftRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__BeginShiftRecordType * SOAP_FMAC2 soap_instantiate_ns1__BeginShiftRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:668 */
#ifndef SOAP_TYPE_ns1__EndShiftRecordType
#define SOAP_TYPE_ns1__EndShiftRecordType (172)
/* Type ns1__EndShiftRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:EndShiftRecordType': */
class SOAP_CMAC ns1__EndShiftRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'sNum' of XSD type 'xsd:long'
        LONG64 sNum;
        /// Optional element 'moL' of XSD type 'ns1:MediaOperationListType'
        ns1__MediaOperationListType *moL;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'eST' of XSD type 'xsd:int'
        int eST;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EndShiftRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EndShiftRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EndShiftRecordType, default initialized and not managed by a soap context
        virtual ns1__EndShiftRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__EndShiftRecordType); }
      public:
        /// Constructor with initializations
        ns1__EndShiftRecordType() : sNum(), moL(), userId(), eST() { }
        virtual ~ns1__EndShiftRecordType() { }
        /// Friend allocator used by soap_new_ns1__EndShiftRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__EndShiftRecordType * SOAP_FMAC2 soap_instantiate_ns1__EndShiftRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:683 */
#ifndef SOAP_TYPE_ns1__LockShiftRecordType
#define SOAP_TYPE_ns1__LockShiftRecordType (177)
/* Type ns1__LockShiftRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:LockShiftRecordType': */
class SOAP_CMAC ns1__LockShiftRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// required attribute 'lock' of XSD type 'xsd:int'
        int lock;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LockShiftRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LockShiftRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LockShiftRecordType, default initialized and not managed by a soap context
        virtual ns1__LockShiftRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__LockShiftRecordType); }
      public:
        /// Constructor with initializations
        ns1__LockShiftRecordType() : shift(), lock() { }
        virtual ~ns1__LockShiftRecordType() { }
        /// Friend allocator used by soap_new_ns1__LockShiftRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LockShiftRecordType * SOAP_FMAC2 soap_instantiate_ns1__LockShiftRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:686 */
#ifndef SOAP_TYPE_ns1__UnlockShiftRecordType
#define SOAP_TYPE_ns1__UnlockShiftRecordType (178)
/* Type ns1__UnlockShiftRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:UnlockShiftRecordType': */
class SOAP_CMAC ns1__UnlockShiftRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// required attribute 'idfT' of XSD type 'xsd:int'
        int idfT;
      public:
        /// Return unique type id SOAP_TYPE_ns1__UnlockShiftRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__UnlockShiftRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__UnlockShiftRecordType, default initialized and not managed by a soap context
        virtual ns1__UnlockShiftRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__UnlockShiftRecordType); }
      public:
        /// Constructor with initializations
        ns1__UnlockShiftRecordType() : shift(), idfT() { }
        virtual ~ns1__UnlockShiftRecordType() { }
        /// Friend allocator used by soap_new_ns1__UnlockShiftRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__UnlockShiftRecordType * SOAP_FMAC2 soap_instantiate_ns1__UnlockShiftRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:689 */
#ifndef SOAP_TYPE_ns1__InternalFailureRecordType
#define SOAP_TYPE_ns1__InternalFailureRecordType (179)
/* Type ns1__InternalFailureRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InternalFailureRecordType': */
class SOAP_CMAC ns1__InternalFailureRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// optional attribute 'pAdd' of XSD type 'xsd:long'
        LONG64 *pAdd;
        /// optional attribute 'eT' of XSD type 'xsd:long'
        LONG64 *eT;
        /// optional attribute 'dAdd' of XSD type 'xsd:long'
        LONG64 *dAdd;
        /// optional attribute 'swV' of XSD type 'xsd:long'
        LONG64 *swV;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InternalFailureRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InternalFailureRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InternalFailureRecordType, default initialized and not managed by a soap context
        virtual ns1__InternalFailureRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__InternalFailureRecordType); }
      public:
        /// Constructor with initializations
        ns1__InternalFailureRecordType() : shift(), pAdd(), eT(), dAdd(), swV() { }
        virtual ~ns1__InternalFailureRecordType() { }
        /// Friend allocator used by soap_new_ns1__InternalFailureRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InternalFailureRecordType * SOAP_FMAC2 soap_instantiate_ns1__InternalFailureRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:692 */
#ifndef SOAP_TYPE_ns1__InspectionRecordType
#define SOAP_TYPE_ns1__InspectionRecordType (180)
/* Type ns1__InspectionRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InspectionRecordType': */
class SOAP_CMAC ns1__InspectionRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Optional element 'profileId' of XSD type 'xsd:unsignedInt'
        unsigned int *profileId;
        /// Optional element 'card' of XSD type 'ns1:cardIdentificationType'
        ns1__cardIdentificationType *card;
        /// Required element 'prd' of XSD type 'ns1:TitleCodeType'
        ns1__TitleCodeType *prd;
        /// Required element 'vT' of XSD type 'xsd:long'
        LONG64 vT;
        /// Required element 'RT' of XSD type 'xsd:long'
        LONG64 RT;
        /// Optional element 'counter' of XSD type 'xsd:long'
        LONG64 *counter;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InspectionRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InspectionRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InspectionRecordType, default initialized and not managed by a soap context
        virtual ns1__InspectionRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__InspectionRecordType); }
      public:
        /// Constructor with initializations
        ns1__InspectionRecordType() : shift(), mT(), profileId(), card(), prd(), vT(), RT(), counter(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__InspectionRecordType() { }
        /// Friend allocator used by soap_new_ns1__InspectionRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InspectionRecordType * SOAP_FMAC2 soap_instantiate_ns1__InspectionRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:695 */
#ifndef SOAP_TYPE_ns1__MediaUpdateStatusRecordType
#define SOAP_TYPE_ns1__MediaUpdateStatusRecordType (181)
/* Type ns1__MediaUpdateStatusRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaUpdateStatusRecordType': */
class SOAP_CMAC ns1__MediaUpdateStatusRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'opType' of XSD type 'xsd:unsignedInt'
        unsigned int *opType;
        /// Optional element 'mT' of XSD type 'xsd:long'
        LONG64 *mT;
        /// Optional element 'mediaId' of XSD type 'xsd:long'
        LONG64 *mediaId;
        /// Optional element 'swSerialNumber' of XSD type 'xsd:long'
        LONG64 *swSerialNumber;
        /// Optional element 'hwSerialNumber' of XSD type 'xsd:long'
        LONG64 *hwSerialNumber;
        /// Optional element 'result' of XSD type 'xsd:int'
        int *result;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaUpdateStatusRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaUpdateStatusRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaUpdateStatusRecordType, default initialized and not managed by a soap context
        virtual ns1__MediaUpdateStatusRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaUpdateStatusRecordType); }
      public:
        /// Constructor with initializations
        ns1__MediaUpdateStatusRecordType() : shift(), opType(), mT(), mediaId(), swSerialNumber(), hwSerialNumber(), result(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__MediaUpdateStatusRecordType() { }
        /// Friend allocator used by soap_new_ns1__MediaUpdateStatusRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaUpdateStatusRecordType * SOAP_FMAC2 soap_instantiate_ns1__MediaUpdateStatusRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:698 */
#ifndef SOAP_TYPE_ns1__CscPersonalizationRecordType
#define SOAP_TYPE_ns1__CscPersonalizationRecordType (182)
/* Type ns1__CscPersonalizationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CscPersonalizationRecordType': */
class SOAP_CMAC ns1__CscPersonalizationRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'mT' of XSD type 'xsd:long'
        LONG64 *mT;
        /// Optional element 'mediaId' of XSD type 'xsd:long'
        LONG64 *mediaId;
        /// Optional element 'usrProfile' of XSD type 'xsd:long'
        LONG64 *usrProfile;
        /// Optional element 'swSerialNumber' of XSD type 'xsd:long'
        LONG64 *swSerialNumber;
        /// Optional element 'hwSerialNumber' of XSD type 'xsd:long'
        LONG64 *hwSerialNumber;
        /// Optional element 'cliId' of XSD type 'xsd:long'
        LONG64 *cliId;
        /// Optional element 'empId' of XSD type 'xsd:long'
        LONG64 *empId;
        /// Optional element 'prePersId' of XSD type 'xsd:long'
        LONG64 *prePersId;
        /// Optional element 'result' of XSD type 'xsd:int'
        int *result;
        /// Optional element 'opType' of XSD type 'xsd:unsignedInt'
        unsigned int *opType;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CscPersonalizationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CscPersonalizationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CscPersonalizationRecordType, default initialized and not managed by a soap context
        virtual ns1__CscPersonalizationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CscPersonalizationRecordType); }
      public:
        /// Constructor with initializations
        ns1__CscPersonalizationRecordType() : shift(), mT(), mediaId(), usrProfile(), swSerialNumber(), hwSerialNumber(), cliId(), empId(), prePersId(), result(), opType(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__CscPersonalizationRecordType() { }
        /// Friend allocator used by soap_new_ns1__CscPersonalizationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CscPersonalizationRecordType * SOAP_FMAC2 soap_instantiate_ns1__CscPersonalizationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:701 */
#ifndef SOAP_TYPE_ns1__CscKeyUpdateRecordType
#define SOAP_TYPE_ns1__CscKeyUpdateRecordType (183)
/* Type ns1__CscKeyUpdateRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CscKeyUpdateRecordType': */
class SOAP_CMAC ns1__CscKeyUpdateRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// optional attribute 'sN' of XSD type 'xsd:long'
        LONG64 *sN;
        /// optional attribute 'kI' of XSD type 'xsd:long'
        LONG64 *kI;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CscKeyUpdateRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CscKeyUpdateRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CscKeyUpdateRecordType, default initialized and not managed by a soap context
        virtual ns1__CscKeyUpdateRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CscKeyUpdateRecordType); }
      public:
        /// Constructor with initializations
        ns1__CscKeyUpdateRecordType() : shift(), sN(), kI() { }
        virtual ~ns1__CscKeyUpdateRecordType() { }
        /// Friend allocator used by soap_new_ns1__CscKeyUpdateRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CscKeyUpdateRecordType * SOAP_FMAC2 soap_instantiate_ns1__CscKeyUpdateRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:704 */
#ifndef SOAP_TYPE_ns1__CscDeliveryRecordType
#define SOAP_TYPE_ns1__CscDeliveryRecordType (184)
/* Type ns1__CscDeliveryRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CscDeliveryRecordType': */
class SOAP_CMAC ns1__CscDeliveryRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// optional attribute 'mSN' of XSD type 'xsd:long'
        LONG64 *mSN;
        /// optional attribute 'pCod' of XSD type 'xsd:long'
        LONG64 *pCod;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CscDeliveryRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CscDeliveryRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CscDeliveryRecordType, default initialized and not managed by a soap context
        virtual ns1__CscDeliveryRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CscDeliveryRecordType); }
      public:
        /// Constructor with initializations
        ns1__CscDeliveryRecordType() : shift(), mSN(), pCod() { }
        virtual ~ns1__CscDeliveryRecordType() { }
        /// Friend allocator used by soap_new_ns1__CscDeliveryRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CscDeliveryRecordType * SOAP_FMAC2 soap_instantiate_ns1__CscDeliveryRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:707 */
#ifndef SOAP_TYPE_ns1__CscRefundRecordType
#define SOAP_TYPE_ns1__CscRefundRecordType (185)
/* Type ns1__CscRefundRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CscRefundRecordType': */
class SOAP_CMAC ns1__CscRefundRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'reason' of XSD type 'xsd:unsignedShort'
        unsigned short reason;
        /// Required element 'refunded' of XSD type 'xsd:long'
        LONG64 refunded;
        /// Required element 'oSN' of XSD type 'xsd:long'
        LONG64 oSN;
        /// Required element 'captured' of XSD type 'xsd:int'
        int captured;
        /// Optional element 'acc' of XSD type 'ns1:AccountingOperationInfo'
        ns1__AccountingOperationInfo *acc;
        /// Optional element 'accUnit' of XSD type 'ns1:AccountingUnit'
        ns1__AccountingUnit *accUnit;
        /// Required element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CscRefundRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CscRefundRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CscRefundRecordType, default initialized and not managed by a soap context
        virtual ns1__CscRefundRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CscRefundRecordType); }
      public:
        /// Constructor with initializations
        ns1__CscRefundRecordType() : shift(), reason(), refunded(), oSN(), captured(), acc(), accUnit(), payments(), awards() { }
        virtual ~ns1__CscRefundRecordType() { }
        /// Friend allocator used by soap_new_ns1__CscRefundRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CscRefundRecordType * SOAP_FMAC2 soap_instantiate_ns1__CscRefundRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:710 */
#ifndef SOAP_TYPE_ns1__CscReplacementRecordType
#define SOAP_TYPE_ns1__CscReplacementRecordType (186)
/* Type ns1__CscReplacementRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CscReplacementRecordType': */
class SOAP_CMAC ns1__CscReplacementRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'reason' of XSD type 'xsd:int'
        int reason;
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// Optional element 'oSN' of XSD type 'xsd:long'
        LONG64 *oSN;
        /// Optional element 'oSW' of XSD type 'xsd:long'
        LONG64 *oSW;
        /// Optional element 'nSN' of XSD type 'xsd:long'
        LONG64 *nSN;
        /// Optional element 'nSW' of XSD type 'xsd:long'
        LONG64 *nSW;
        /// Optional element 'rplcmntAmnt' of XSD type 'xsd:long'
        LONG64 *rplcmntAmnt;
        /// Optional element 'dpstAmnt' of XSD type 'xsd:long'
        LONG64 *dpstAmnt;
        /// Required element 'expDate' of XSD type 'xsd:dateTime'
        time_t expDate;
        /// Required element 'suppAmnt' of XSD type 'xsd:long'
        LONG64 suppAmnt;
        /// Optional element 'acc' of XSD type 'ns1:AccountingOperationInfo'
        ns1__AccountingOperationInfo *acc;
        /// Optional element 'accUnit' of XSD type 'ns1:AccountingUnit'
        ns1__AccountingUnit *accUnit;
        /// Required element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CscReplacementRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CscReplacementRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CscReplacementRecordType, default initialized and not managed by a soap context
        virtual ns1__CscReplacementRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CscReplacementRecordType); }
      public:
        /// Constructor with initializations
        ns1__CscReplacementRecordType() : shift(), reason(), mT(), ctlInfo(), ctlData(), cData(), rawData(), oSN(), oSW(), nSN(), nSW(), rplcmntAmnt(), dpstAmnt(), expDate(), suppAmnt(), acc(), accUnit(), payments(), awards() { }
        virtual ~ns1__CscReplacementRecordType() { }
        /// Friend allocator used by soap_new_ns1__CscReplacementRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CscReplacementRecordType * SOAP_FMAC2 soap_instantiate_ns1__CscReplacementRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:713 */
#ifndef SOAP_TYPE_ns1__IssueOperationRecordType
#define SOAP_TYPE_ns1__IssueOperationRecordType (187)
/* Type ns1__IssueOperationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:IssueOperationRecordType': */
class SOAP_CMAC ns1__IssueOperationRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'mediaType' of XSD type 'xsd:long'
        LONG64 *mediaType;
        /// Optional element 'mediaId' of XSD type 'xsd:long'
        LONG64 *mediaId;
        /// Optional element 'swSerialNumber' of XSD type 'xsd:long'
        LONG64 *swSerialNumber;
        /// Optional element 'hwSerialNumber' of XSD type 'xsd:long'
        LONG64 *hwSerialNumber;
        /// Optional element 'unit' of XSD type 'ns1:AccountingUnitType'
        ns1__AccountingUnitType *unit;
        /// Optional element 'tp' of XSD type 'xsd:long'
        LONG64 *tp;
        /// Optional element 'pd' of XSD type 'xsd:long'
        LONG64 *pd;
        /// Optional element 'returned' of XSD type 'xsd:long'
        LONG64 *returned;
        /// Optional element 'tR' of XSD type 'xsd:long'
        LONG64 *tR;
        /// Optional element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
        /// Optional element 'issueDate' of XSD type 'xsd:dateTime'
        time_t *issueDate;
        /// Optional element 'sam' of XSD type 'ns1:SamType'
        ns1__SamType *sam;
        /// Optional element 'result' of XSD type 'xsd:int'
        int *result;
        /// Optional element 'opType' of XSD type 'xsd:unsignedInt'
        unsigned int *opType;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__IssueOperationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__IssueOperationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__IssueOperationRecordType, default initialized and not managed by a soap context
        virtual ns1__IssueOperationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__IssueOperationRecordType); }
      public:
        /// Constructor with initializations
        ns1__IssueOperationRecordType() : shift(), mediaType(), mediaId(), swSerialNumber(), hwSerialNumber(), unit(), tp(), pd(), returned(), tR(), payments(), awards(), issueDate(), sam(), result(), opType(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__IssueOperationRecordType() { }
        /// Friend allocator used by soap_new_ns1__IssueOperationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__IssueOperationRecordType * SOAP_FMAC2 soap_instantiate_ns1__IssueOperationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:719 */
#ifndef SOAP_TYPE_ns1__TicketExchangeRecordType
#define SOAP_TYPE_ns1__TicketExchangeRecordType (189)
/* Type ns1__TicketExchangeRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:TicketExchangeRecordType': */
class SOAP_CMAC ns1__TicketExchangeRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'origPassCod' of XSD type 'xsd:long'
        LONG64 origPassCod;
        /// Required element 'origZVal' of XSD type 'xsd:long'
        LONG64 origZVal;
        /// Required element 'origNOfTrips' of XSD type 'xsd:long'
        LONG64 origNOfTrips;
        /// Required element 'origEOfVal' of XSD type 'xsd:dateTime'
        time_t origEOfVal;
        /// Required element 'origAmnt' of XSD type 'xsd:long'
        LONG64 origAmnt;
        /// Required element 'newPassCod' of XSD type 'xsd:long'
        LONG64 newPassCod;
        /// Required element 'newZVal' of XSD type 'xsd:long'
        LONG64 newZVal;
        /// Required element 'newNOfTrips' of XSD type 'xsd:long'
        LONG64 newNOfTrips;
        /// Required element 'newEOfVal' of XSD type 'xsd:dateTime'
        time_t newEOfVal;
        /// Required element 'newAmnt' of XSD type 'xsd:long'
        LONG64 newAmnt;
        /// Required element 'finalAmntToPaid' of XSD type 'xsd:long'
        LONG64 finalAmntToPaid;
        /// Optional element 'origCtlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *origCtlData;
        /// Optional element 'origCData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *origCData;
        /// Optional element 'origRawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *origRawData;
        /// Optional element 'newCtlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *newCtlData;
        /// Optional element 'newCData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *newCData;
        /// Optional element 'newRawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *newRawData;
        /// Required element 'result' of XSD type 'xsd:long'
        LONG64 result;
        /// Required element 'tp' of XSD type 'xsd:long'
        LONG64 tp;
        /// Required element 'pd' of XSD type 'xsd:long'
        LONG64 pd;
        /// Required element 'returned' of XSD type 'xsd:long'
        LONG64 returned;
        /// Required element 'tR' of XSD type 'xsd:long'
        LONG64 tR;
        /// Required element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
      public:
        /// Return unique type id SOAP_TYPE_ns1__TicketExchangeRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__TicketExchangeRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__TicketExchangeRecordType, default initialized and not managed by a soap context
        virtual ns1__TicketExchangeRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__TicketExchangeRecordType); }
      public:
        /// Constructor with initializations
        ns1__TicketExchangeRecordType() : shift(), origPassCod(), origZVal(), origNOfTrips(), origEOfVal(), origAmnt(), newPassCod(), newZVal(), newNOfTrips(), newEOfVal(), newAmnt(), finalAmntToPaid(), origCtlData(), origCData(), origRawData(), newCtlData(), newCData(), newRawData(), result(), tp(), pd(), returned(), tR(), payments(), awards() { }
        virtual ~ns1__TicketExchangeRecordType() { }
        /// Friend allocator used by soap_new_ns1__TicketExchangeRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__TicketExchangeRecordType * SOAP_FMAC2 soap_instantiate_ns1__TicketExchangeRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:722 */
#ifndef SOAP_TYPE_ns1__CashCountingAdjustRecordType
#define SOAP_TYPE_ns1__CashCountingAdjustRecordType (190)
/* Type ns1__CashCountingAdjustRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CashCountingAdjustRecordType': */
class SOAP_CMAC ns1__CashCountingAdjustRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'cashContNum' of XSD type 'xsd:long'
        LONG64 cashContNum;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'opT' of XSD type 'xsd:int'
        int opT;
        /// Optional element 'units' of XSD type 'ns1:monetaryUnitListType'
        ns1__monetaryUnitListType *units;
        /// Required element 'totAmnt' of XSD type 'xsd:long'
        LONG64 totAmnt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashCountingAdjustRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CashCountingAdjustRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashCountingAdjustRecordType, default initialized and not managed by a soap context
        virtual ns1__CashCountingAdjustRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CashCountingAdjustRecordType); }
      public:
        /// Constructor with initializations
        ns1__CashCountingAdjustRecordType() : shift(), cashContNum(), userId(), opT(), units(), totAmnt() { }
        virtual ~ns1__CashCountingAdjustRecordType() { }
        /// Friend allocator used by soap_new_ns1__CashCountingAdjustRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashCountingAdjustRecordType * SOAP_FMAC2 soap_instantiate_ns1__CashCountingAdjustRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:731 */
#ifndef SOAP_TYPE_ns1__CashCountingRecordType
#define SOAP_TYPE_ns1__CashCountingRecordType (193)
/* Type ns1__CashCountingRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CashCountingRecordType': */
class SOAP_CMAC ns1__CashCountingRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'cashContNum' of XSD type 'xsd:long'
        LONG64 cashContNum;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'opT' of XSD type 'xsd:int'
        int opT;
        /// Optional element 'units' of XSD type 'ns1:monetaryUnitListType'
        ns1__monetaryUnitListType *units;
        /// Required element 'totAmnt' of XSD type 'xsd:long'
        LONG64 totAmnt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashCountingRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CashCountingRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashCountingRecordType, default initialized and not managed by a soap context
        virtual ns1__CashCountingRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CashCountingRecordType); }
      public:
        /// Constructor with initializations
        ns1__CashCountingRecordType() : shift(), cashContNum(), userId(), opT(), units(), totAmnt() { }
        virtual ~ns1__CashCountingRecordType() { }
        /// Friend allocator used by soap_new_ns1__CashCountingRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashCountingRecordType * SOAP_FMAC2 soap_instantiate_ns1__CashCountingRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:734 */
#ifndef SOAP_TYPE_ns1__CashMaintenanceRecordType
#define SOAP_TYPE_ns1__CashMaintenanceRecordType (194)
/* Type ns1__CashMaintenanceRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CashMaintenanceRecordType': */
class SOAP_CMAC ns1__CashMaintenanceRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'bN' of XSD type 'xsd:long'
        LONG64 bN;
        /// Required element 'bT' of XSD type 'xsd:unsignedShort'
        unsigned short bT;
        /// Required element 'val' of XSD type 'xsd:long'
        LONG64 val;
        /// Required element 'qtt' of XSD type 'xsd:long'
        LONG64 qtt;
        /// Required element 'cash' of XSD type 'xsd:long'
        LONG64 cash;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CashMaintenanceRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CashMaintenanceRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CashMaintenanceRecordType, default initialized and not managed by a soap context
        virtual ns1__CashMaintenanceRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CashMaintenanceRecordType); }
      public:
        /// Constructor with initializations
        ns1__CashMaintenanceRecordType() : userId(), bN(), bT(), val(), qtt(), cash() { }
        virtual ~ns1__CashMaintenanceRecordType() { }
        /// Friend allocator used by soap_new_ns1__CashMaintenanceRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CashMaintenanceRecordType * SOAP_FMAC2 soap_instantiate_ns1__CashMaintenanceRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:737 */
#ifndef SOAP_TYPE_ns1__CollectionRecordType
#define SOAP_TYPE_ns1__CollectionRecordType (195)
/* Type ns1__CollectionRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CollectionRecordType': */
class SOAP_CMAC ns1__CollectionRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'collectNum' of XSD type 'xsd:long'
        LONG64 collectNum;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'bN' of XSD type 'xsd:long'
        LONG64 bN;
        /// Required element 'bT' of XSD type 'xsd:unsignedShort'
        unsigned short bT;
        /// Required element 'sN' of XSD type 'xsd:long'
        LONG64 sN;
        /// Optional element 'Units' of XSD type 'ns1:monetaryUnitListType'
        ns1__monetaryUnitListType *Units;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CollectionRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CollectionRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CollectionRecordType, default initialized and not managed by a soap context
        virtual ns1__CollectionRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CollectionRecordType); }
      public:
        /// Constructor with initializations
        ns1__CollectionRecordType() : collectNum(), userId(), bN(), bT(), sN(), Units() { }
        virtual ~ns1__CollectionRecordType() { }
        /// Friend allocator used by soap_new_ns1__CollectionRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CollectionRecordType * SOAP_FMAC2 soap_instantiate_ns1__CollectionRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:740 */
#ifndef SOAP_TYPE_ns1__CoinsAndNotesCollectionRecordType
#define SOAP_TYPE_ns1__CoinsAndNotesCollectionRecordType (196)
/* Type ns1__CoinsAndNotesCollectionRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CoinsAndNotesCollectionRecordType': */
class SOAP_CMAC ns1__CoinsAndNotesCollectionRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'units' of XSD type 'ns1:monetaryUnitListType'
        ns1__monetaryUnitListType *units;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CoinsAndNotesCollectionRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CoinsAndNotesCollectionRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CoinsAndNotesCollectionRecordType, default initialized and not managed by a soap context
        virtual ns1__CoinsAndNotesCollectionRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CoinsAndNotesCollectionRecordType); }
      public:
        /// Constructor with initializations
        ns1__CoinsAndNotesCollectionRecordType() : shift(), units() { }
        virtual ~ns1__CoinsAndNotesCollectionRecordType() { }
        /// Friend allocator used by soap_new_ns1__CoinsAndNotesCollectionRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CoinsAndNotesCollectionRecordType * SOAP_FMAC2 soap_instantiate_ns1__CoinsAndNotesCollectionRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:743 */
#ifndef SOAP_TYPE_ns1__MediaStockUpdateRecordType
#define SOAP_TYPE_ns1__MediaStockUpdateRecordType (197)
/* Type ns1__MediaStockUpdateRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaStockUpdateRecordType': */
class SOAP_CMAC ns1__MediaStockUpdateRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'Stocks' of XSD type 'ns1:MediaStockListType'
        ns1__MediaStockListType *Stocks;
        /// optional attribute 'updNum' of XSD type 'xsd:long'
        LONG64 *updNum;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaStockUpdateRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaStockUpdateRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaStockUpdateRecordType, default initialized and not managed by a soap context
        virtual ns1__MediaStockUpdateRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaStockUpdateRecordType); }
      public:
        /// Constructor with initializations
        ns1__MediaStockUpdateRecordType() : shift(), Stocks(), updNum() { }
        virtual ~ns1__MediaStockUpdateRecordType() { }
        /// Friend allocator used by soap_new_ns1__MediaStockUpdateRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaStockUpdateRecordType * SOAP_FMAC2 soap_instantiate_ns1__MediaStockUpdateRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:752 */
#ifndef SOAP_TYPE_ns1__MediaStockAdjustRecordType
#define SOAP_TYPE_ns1__MediaStockAdjustRecordType (200)
/* Type ns1__MediaStockAdjustRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MediaStockAdjustRecordType': */
class SOAP_CMAC ns1__MediaStockAdjustRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'Stock' of XSD type 'ns1:mediaStockType'
        ns1__mediaStockType *Stock;
        /// optional attribute 'updNum' of XSD type 'xsd:long'
        LONG64 *updNum;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MediaStockAdjustRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MediaStockAdjustRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MediaStockAdjustRecordType, default initialized and not managed by a soap context
        virtual ns1__MediaStockAdjustRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__MediaStockAdjustRecordType); }
      public:
        /// Constructor with initializations
        ns1__MediaStockAdjustRecordType() : shift(), Stock(), updNum() { }
        virtual ~ns1__MediaStockAdjustRecordType() { }
        /// Friend allocator used by soap_new_ns1__MediaStockAdjustRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MediaStockAdjustRecordType * SOAP_FMAC2 soap_instantiate_ns1__MediaStockAdjustRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:755 */
#ifndef SOAP_TYPE_ns1__CoinNoteRefillRecordType
#define SOAP_TYPE_ns1__CoinNoteRefillRecordType (201)
/* Type ns1__CoinNoteRefillRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CoinNoteRefillRecordType': */
class SOAP_CMAC ns1__CoinNoteRefillRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'refillNum' of XSD type 'xsd:long'
        LONG64 refillNum;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'bN' of XSD type 'xsd:long'
        LONG64 bN;
        /// Required element 'bT' of XSD type 'xsd:unsignedShort'
        unsigned short bT;
        /// Required element 'val' of XSD type 'xsd:long'
        LONG64 val;
        /// Required element 'qtt' of XSD type 'xsd:long'
        LONG64 qtt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CoinNoteRefillRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CoinNoteRefillRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CoinNoteRefillRecordType, default initialized and not managed by a soap context
        virtual ns1__CoinNoteRefillRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CoinNoteRefillRecordType); }
      public:
        /// Constructor with initializations
        ns1__CoinNoteRefillRecordType() : refillNum(), userId(), bN(), bT(), val(), qtt() { }
        virtual ~ns1__CoinNoteRefillRecordType() { }
        /// Friend allocator used by soap_new_ns1__CoinNoteRefillRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CoinNoteRefillRecordType * SOAP_FMAC2 soap_instantiate_ns1__CoinNoteRefillRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:758 */
#ifndef SOAP_TYPE_ns1__CoinNoteRefillAdjustmentRecordType
#define SOAP_TYPE_ns1__CoinNoteRefillAdjustmentRecordType (202)
/* Type ns1__CoinNoteRefillAdjustmentRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CoinNoteRefillAdjustmentRecordType': */
class SOAP_CMAC ns1__CoinNoteRefillAdjustmentRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'refillNum' of XSD type 'xsd:long'
        LONG64 refillNum;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'bN' of XSD type 'xsd:long'
        LONG64 bN;
        /// Required element 'bT' of XSD type 'xsd:unsignedShort'
        unsigned short bT;
        /// Required element 'date' of XSD type 'xsd:date'
        char *date;
        /// Required element 'val' of XSD type 'xsd:long'
        LONG64 val;
        /// Required element 'qtt' of XSD type 'xsd:long'
        LONG64 qtt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CoinNoteRefillAdjustmentRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CoinNoteRefillAdjustmentRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CoinNoteRefillAdjustmentRecordType, default initialized and not managed by a soap context
        virtual ns1__CoinNoteRefillAdjustmentRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CoinNoteRefillAdjustmentRecordType); }
      public:
        /// Constructor with initializations
        ns1__CoinNoteRefillAdjustmentRecordType() : refillNum(), userId(), bN(), bT(), date(), val(), qtt() { }
        virtual ~ns1__CoinNoteRefillAdjustmentRecordType() { }
        /// Friend allocator used by soap_new_ns1__CoinNoteRefillAdjustmentRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CoinNoteRefillAdjustmentRecordType * SOAP_FMAC2 soap_instantiate_ns1__CoinNoteRefillAdjustmentRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:761 */
#ifndef SOAP_TYPE_ns1__InternalCoinFlowRecordType
#define SOAP_TYPE_ns1__InternalCoinFlowRecordType (203)
/* Type ns1__InternalCoinFlowRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:InternalCoinFlowRecordType': */
class SOAP_CMAC ns1__InternalCoinFlowRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'bN' of XSD type 'xsd:long'
        LONG64 bN;
        /// Required element 'bT' of XSD type 'xsd:unsignedShort'
        unsigned short bT;
        /// Required element 'val' of XSD type 'xsd:long'
        LONG64 val;
        /// Required element 'qtt' of XSD type 'xsd:long'
        LONG64 qtt;
      public:
        /// Return unique type id SOAP_TYPE_ns1__InternalCoinFlowRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__InternalCoinFlowRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__InternalCoinFlowRecordType, default initialized and not managed by a soap context
        virtual ns1__InternalCoinFlowRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__InternalCoinFlowRecordType); }
      public:
        /// Constructor with initializations
        ns1__InternalCoinFlowRecordType() : bN(), bT(), val(), qtt() { }
        virtual ~ns1__InternalCoinFlowRecordType() { }
        /// Friend allocator used by soap_new_ns1__InternalCoinFlowRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__InternalCoinFlowRecordType * SOAP_FMAC2 soap_instantiate_ns1__InternalCoinFlowRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:764 */
#ifndef SOAP_TYPE_ns1__PenaltyRecordType
#define SOAP_TYPE_ns1__PenaltyRecordType (204)
/* Type ns1__PenaltyRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:PenaltyRecordType': */
class SOAP_CMAC ns1__PenaltyRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'penalty' of XSD type 'ns1:Penalty'
        ns1__Penalty *penalty;
        /// Optional element 'reason' of XSD type 'xsd:long'
        LONG64 *reason;
        /// Optional element 'desc' of XSD type 'xsd:string'
        char *desc;
        /// Optional element 'amount' of XSD type 'xsd:long'
        LONG64 *amount;
        /// Optional element 'mT' of XSD type 'xsd:long'
        LONG64 *mT;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// Optional element 'invoiceNum' of XSD type 'xsd:string'
        char *invoiceNum;
        /// Optional element 'acc' of XSD type 'ns1:AccountingOperationInfo'
        ns1__AccountingOperationInfo *acc;
        /// Optional element 'accUnit' of XSD type 'ns1:AccountingUnit'
        ns1__AccountingUnit *accUnit;
        /// Optional element 'unit' of XSD type 'ns1:AccountingUnitType'
        ns1__AccountingUnitType *unit;
        /// Optional element 'tp' of XSD type 'xsd:long'
        LONG64 *tp;
        /// Optional element 'pd' of XSD type 'xsd:long'
        LONG64 *pd;
        /// Optional element 'returned' of XSD type 'xsd:long'
        LONG64 *returned;
        /// Optional element 'tR' of XSD type 'xsd:long'
        LONG64 *tR;
        /// Optional element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
        /// Optional element 'pendingPayment' of XSD type 'ns1:PendingPaymentType'
        ns1__PendingPaymentType *pendingPayment;
      public:
        /// Return unique type id SOAP_TYPE_ns1__PenaltyRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__PenaltyRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__PenaltyRecordType, default initialized and not managed by a soap context
        virtual ns1__PenaltyRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__PenaltyRecordType); }
      public:
        /// Constructor with initializations
        ns1__PenaltyRecordType() : shift(), penalty(), reason(), desc(), amount(), mT(), ctlInfo(), ctlData(), cData(), rawData(), invoiceNum(), acc(), accUnit(), unit(), tp(), pd(), returned(), tR(), payments(), awards(), pendingPayment() { }
        virtual ~ns1__PenaltyRecordType() { }
        /// Friend allocator used by soap_new_ns1__PenaltyRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__PenaltyRecordType * SOAP_FMAC2 soap_instantiate_ns1__PenaltyRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:779 */
#ifndef SOAP_TYPE_ns1__GateRejectionAnalysisRecordType
#define SOAP_TYPE_ns1__GateRejectionAnalysisRecordType (209)
/* Type ns1__GateRejectionAnalysisRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:GateRejectionAnalysisRecordType': */
class SOAP_CMAC ns1__GateRejectionAnalysisRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Optional element 'iniCtlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *iniCtlData;
        /// Optional element 'iniCData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *iniCData;
        /// Optional element 'iniRawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *iniRawData;
        /// Optional element 'updCtlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *updCtlData;
        /// Optional element 'updCData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *updCData;
        /// Optional element 'updRawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *updRawData;
        /// Required element 'amount' of XSD type 'xsd:long'
        LONG64 amount;
        /// Required element 'reason' of XSD type 'xsd:long'
        LONG64 reason;
        /// Required element 'unit' of XSD type 'ns1:AccountingUnitType'
        ns1__AccountingUnitType *unit;
        /// Required element 'penalty' of XSD type 'ns1:PenaltyType'
        ns1__PenaltyType *penalty;
        /// Required element 'tp' of XSD type 'xsd:long'
        LONG64 tp;
        /// Required element 'pd' of XSD type 'xsd:long'
        LONG64 pd;
        /// Required element 'returned' of XSD type 'xsd:long'
        LONG64 returned;
        /// Required element 'tR' of XSD type 'xsd:long'
        LONG64 tR;
        /// Required element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
      public:
        /// Return unique type id SOAP_TYPE_ns1__GateRejectionAnalysisRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__GateRejectionAnalysisRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__GateRejectionAnalysisRecordType, default initialized and not managed by a soap context
        virtual ns1__GateRejectionAnalysisRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__GateRejectionAnalysisRecordType); }
      public:
        /// Constructor with initializations
        ns1__GateRejectionAnalysisRecordType() : shift(), mT(), iniCtlData(), iniCData(), iniRawData(), updCtlData(), updCData(), updRawData(), amount(), reason(), unit(), penalty(), tp(), pd(), returned(), tR(), payments(), awards() { }
        virtual ~ns1__GateRejectionAnalysisRecordType() { }
        /// Friend allocator used by soap_new_ns1__GateRejectionAnalysisRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__GateRejectionAnalysisRecordType * SOAP_FMAC2 soap_instantiate_ns1__GateRejectionAnalysisRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:785 */
#ifndef SOAP_TYPE_ns1__MaintenanceOperationRecordType
#define SOAP_TYPE_ns1__MaintenanceOperationRecordType (211)
/* Type ns1__MaintenanceOperationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MaintenanceOperationRecordType': */
class SOAP_CMAC ns1__MaintenanceOperationRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'testCode' of XSD type 'xsd:long'
        LONG64 testCode;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MaintenanceOperationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MaintenanceOperationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MaintenanceOperationRecordType, default initialized and not managed by a soap context
        virtual ns1__MaintenanceOperationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__MaintenanceOperationRecordType); }
      public:
        /// Constructor with initializations
        ns1__MaintenanceOperationRecordType() : shift(), testCode() { }
        virtual ~ns1__MaintenanceOperationRecordType() { }
        /// Friend allocator used by soap_new_ns1__MaintenanceOperationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MaintenanceOperationRecordType * SOAP_FMAC2 soap_instantiate_ns1__MaintenanceOperationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:788 */
#ifndef SOAP_TYPE_ns1__AdvancedPurchaseRecordType
#define SOAP_TYPE_ns1__AdvancedPurchaseRecordType (212)
/* Type ns1__AdvancedPurchaseRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:AdvancedPurchaseRecordType': */
class SOAP_CMAC ns1__AdvancedPurchaseRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'mSN' of XSD type 'xsd:long'
        LONG64 mSN;
        /// Required element 'pCod' of XSD type 'xsd:string'
        char *pCod;
        /// Required element 'Units' of XSD type 'ns1:AccountingUnitListType'
        ns1__AccountingUnitListType *Units;
        /// Required element 'tp' of XSD type 'xsd:long'
        LONG64 tp;
        /// Required element 'pd' of XSD type 'xsd:long'
        LONG64 pd;
        /// Required element 'returned' of XSD type 'xsd:long'
        LONG64 returned;
        /// Required element 'tR' of XSD type 'xsd:long'
        LONG64 tR;
        /// Optional element 'nReq' of XSD type 'xsd:long'
        LONG64 *nReq;
        /// Optional element 'nSucc' of XSD type 'xsd:long'
        LONG64 *nSucc;
        /// Required element 'payments' of XSD type 'ns1:PaymentModeListType'
        ns1__PaymentModeListType *payments;
        /// Optional element 'awards' of XSD type 'ns1:AwardListType'
        ns1__AwardListType *awards;
        /// Optional element 'coinNoteIns' of XSD type 'ns1:CoinNoteInsertedListType'
        ns1__CoinNoteInsertedListType *coinNoteIns;
        /// Optional element 'coinNoteRet' of XSD type 'ns1:CoinNoteReturnedListType'
        ns1__CoinNoteReturnedListType *coinNoteRet;
      public:
        /// Return unique type id SOAP_TYPE_ns1__AdvancedPurchaseRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__AdvancedPurchaseRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__AdvancedPurchaseRecordType, default initialized and not managed by a soap context
        virtual ns1__AdvancedPurchaseRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__AdvancedPurchaseRecordType); }
      public:
        /// Constructor with initializations
        ns1__AdvancedPurchaseRecordType() : shift(), mSN(), pCod(), Units(), tp(), pd(), returned(), tR(), nReq(), nSucc(), payments(), awards(), coinNoteIns(), coinNoteRet() { }
        virtual ~ns1__AdvancedPurchaseRecordType() { }
        /// Friend allocator used by soap_new_ns1__AdvancedPurchaseRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__AdvancedPurchaseRecordType * SOAP_FMAC2 soap_instantiate_ns1__AdvancedPurchaseRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:791 */
#ifndef SOAP_TYPE_ns1__OpenGatePsmRecordType
#define SOAP_TYPE_ns1__OpenGatePsmRecordType (213)
/* Type ns1__OpenGatePsmRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OpenGatePsmRecordType': */
class SOAP_CMAC ns1__OpenGatePsmRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'psmId' of XSD type 'xsd:long'
        LONG64 psmId;
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'command' of XSD type 'xsd:int'
        int command;
        /// Required element 'result' of XSD type 'xsd:int'
        int result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OpenGatePsmRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OpenGatePsmRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OpenGatePsmRecordType, default initialized and not managed by a soap context
        virtual ns1__OpenGatePsmRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__OpenGatePsmRecordType); }
      public:
        /// Constructor with initializations
        ns1__OpenGatePsmRecordType() : psmId(), shift(), command(), result() { }
        virtual ~ns1__OpenGatePsmRecordType() { }
        /// Friend allocator used by soap_new_ns1__OpenGatePsmRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OpenGatePsmRecordType * SOAP_FMAC2 soap_instantiate_ns1__OpenGatePsmRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:794 */
#ifndef SOAP_TYPE_ns1__OpenWideAisleGateRecordType
#define SOAP_TYPE_ns1__OpenWideAisleGateRecordType (214)
/* Type ns1__OpenWideAisleGateRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:OpenWideAisleGateRecordType': */
class SOAP_CMAC ns1__OpenWideAisleGateRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'gateId' of XSD type 'xsd:long'
        LONG64 gateId;
        /// Required element 'command' of XSD type 'xsd:int'
        int command;
        /// Required element 'result' of XSD type 'xsd:int'
        int result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__OpenWideAisleGateRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__OpenWideAisleGateRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__OpenWideAisleGateRecordType, default initialized and not managed by a soap context
        virtual ns1__OpenWideAisleGateRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__OpenWideAisleGateRecordType); }
      public:
        /// Constructor with initializations
        ns1__OpenWideAisleGateRecordType() : shift(), gateId(), command(), result() { }
        virtual ~ns1__OpenWideAisleGateRecordType() { }
        /// Friend allocator used by soap_new_ns1__OpenWideAisleGateRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__OpenWideAisleGateRecordType * SOAP_FMAC2 soap_instantiate_ns1__OpenWideAisleGateRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:797 */
#ifndef SOAP_TYPE_ns1__ActionListRecordType
#define SOAP_TYPE_ns1__ActionListRecordType (215)
/* Type ns1__ActionListRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ActionListRecordType': */
class SOAP_CMAC ns1__ActionListRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'actionList' of XSD type 'ns1:ActionListType'
        ns1__ActionListType *actionList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ActionListRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ActionListRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ActionListRecordType, default initialized and not managed by a soap context
        virtual ns1__ActionListRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__ActionListRecordType); }
      public:
        /// Constructor with initializations
        ns1__ActionListRecordType() : actionList() { }
        virtual ~ns1__ActionListRecordType() { }
        /// Friend allocator used by soap_new_ns1__ActionListRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__ActionListRecordType * SOAP_FMAC2 soap_instantiate_ns1__ActionListRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:806 */
#ifndef SOAP_TYPE_ns1__CommandReportRecordType
#define SOAP_TYPE_ns1__CommandReportRecordType (218)
/* Type ns1__CommandReportRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CommandReportRecordType': */
class SOAP_CMAC ns1__CommandReportRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'idR' of XSD type 'xsd:long'
        LONG64 idR;
        /// Required element 'ct' of XSD type 'xsd:int'
        int ct;
        /// Required element 'dc' of XSD type 'xsd:long'
        LONG64 dc;
        /// Required element 'cc' of XSD type 'xsd:long'
        LONG64 cc;
        /// Required element 'sendE' of XSD type 'xsd:int'
        int sendE;
        /// Required element 'sd' of XSD type 'xsd:dateTime'
        time_t sd;
        /// Required element 'rd' of XSD type 'xsd:dateTime'
        time_t rd;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
        /// Required element 'uv' of XSD type 'xsd:long'
        LONG64 uv;
        /// Required element 'r' of XSD type 'xsd:int'
        int r;
        /// Required element 'dest' of XSD type 'ns1:EquipmentReferenceType'
        ns1__EquipmentReferenceType *dest;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CommandReportRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CommandReportRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CommandReportRecordType, default initialized and not managed by a soap context
        virtual ns1__CommandReportRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CommandReportRecordType); }
      public:
        /// Constructor with initializations
        ns1__CommandReportRecordType() : idR(), ct(), dc(), cc(), sendE(), sd(), rd(), userId(), uv(), r(), dest() { }
        virtual ~ns1__CommandReportRecordType() { }
        /// Friend allocator used by soap_new_ns1__CommandReportRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CommandReportRecordType * SOAP_FMAC2 soap_instantiate_ns1__CommandReportRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:809 */
#ifndef SOAP_TYPE_ns1__CsmBlockingRecordType
#define SOAP_TYPE_ns1__CsmBlockingRecordType (219)
/* Type ns1__CsmBlockingRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CsmBlockingRecordType': */
class SOAP_CMAC ns1__CsmBlockingRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'csmSN' of XSD type 'xsd:long'
        LONG64 csmSN;
        /// Required element 'reason' of XSD type 'xsd:unsignedShort'
        unsigned short reason;
        /// Optional element 'blR' of XSD type 'xsd:unsignedShort'
        unsigned short *blR;
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Optional element 'sam' of XSD type 'ns1:SamType'
        ns1__SamType *sam;
        /// Optional element 'opType' of XSD type 'xsd:unsignedInt'
        unsigned int *opType;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CsmBlockingRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CsmBlockingRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CsmBlockingRecordType, default initialized and not managed by a soap context
        virtual ns1__CsmBlockingRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CsmBlockingRecordType); }
      public:
        /// Constructor with initializations
        ns1__CsmBlockingRecordType() : csmSN(), reason(), blR(), mT(), sam(), opType(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__CsmBlockingRecordType() { }
        /// Friend allocator used by soap_new_ns1__CsmBlockingRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CsmBlockingRecordType * SOAP_FMAC2 soap_instantiate_ns1__CsmBlockingRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:812 */
#ifndef SOAP_TYPE_ns1__CsmUnblockingRecordType
#define SOAP_TYPE_ns1__CsmUnblockingRecordType (220)
/* Type ns1__CsmUnblockingRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CsmUnblockingRecordType': */
class SOAP_CMAC ns1__CsmUnblockingRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'csmSN' of XSD type 'xsd:long'
        LONG64 csmSN;
        /// Required element 'reason' of XSD type 'xsd:unsignedShort'
        unsigned short reason;
        /// Required element 'mT' of XSD type 'xsd:long'
        LONG64 mT;
        /// Optional element 'sam' of XSD type 'ns1:SamType'
        ns1__SamType *sam;
        /// Optional element 'opType' of XSD type 'xsd:unsignedInt'
        unsigned int *opType;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CsmUnblockingRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CsmUnblockingRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CsmUnblockingRecordType, default initialized and not managed by a soap context
        virtual ns1__CsmUnblockingRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CsmUnblockingRecordType); }
      public:
        /// Constructor with initializations
        ns1__CsmUnblockingRecordType() : csmSN(), reason(), mT(), sam(), opType(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__CsmUnblockingRecordType() { }
        /// Friend allocator used by soap_new_ns1__CsmUnblockingRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CsmUnblockingRecordType * SOAP_FMAC2 soap_instantiate_ns1__CsmUnblockingRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:815 */
#ifndef SOAP_TYPE_ns1__CsmInitializationRecordType
#define SOAP_TYPE_ns1__CsmInitializationRecordType (221)
/* Type ns1__CsmInitializationRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:CsmInitializationRecordType': */
class SOAP_CMAC ns1__CsmInitializationRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'mediaType' of XSD type 'xsd:long'
        LONG64 *mediaType;
        /// Optional element 'mediaId' of XSD type 'xsd:long'
        LONG64 *mediaId;
        /// Optional element 'swSerialNumber' of XSD type 'xsd:long'
        LONG64 *swSerialNumber;
        /// Optional element 'hwSerialNumber' of XSD type 'xsd:long'
        LONG64 *hwSerialNumber;
        /// Optional element 'sam' of XSD type 'ns1:SamType'
        ns1__SamType *sam;
        /// Optional element 'result' of XSD type 'xsd:int'
        int *result;
        /// Optional element 'opType' of XSD type 'xsd:unsignedInt'
        unsigned int *opType;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__CsmInitializationRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__CsmInitializationRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__CsmInitializationRecordType, default initialized and not managed by a soap context
        virtual ns1__CsmInitializationRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__CsmInitializationRecordType); }
      public:
        /// Constructor with initializations
        ns1__CsmInitializationRecordType() : shift(), mediaType(), mediaId(), swSerialNumber(), hwSerialNumber(), sam(), result(), opType(), ctlInfo(), ctlData(), cData(), rawData() { }
        virtual ~ns1__CsmInitializationRecordType() { }
        /// Friend allocator used by soap_new_ns1__CsmInitializationRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__CsmInitializationRecordType * SOAP_FMAC2 soap_instantiate_ns1__CsmInitializationRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:818 */
#ifndef SOAP_TYPE_ns1__LocationChangeRecordType
#define SOAP_TYPE_ns1__LocationChangeRecordType (222)
/* Type ns1__LocationChangeRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:LocationChangeRecordType': */
class SOAP_CMAC ns1__LocationChangeRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'pS' of XSD type 'xsd:long'
        LONG64 pS;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LocationChangeRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LocationChangeRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LocationChangeRecordType, default initialized and not managed by a soap context
        virtual ns1__LocationChangeRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__LocationChangeRecordType); }
      public:
        /// Constructor with initializations
        ns1__LocationChangeRecordType() : shift(), pS() { }
        virtual ~ns1__LocationChangeRecordType() { }
        /// Friend allocator used by soap_new_ns1__LocationChangeRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LocationChangeRecordType * SOAP_FMAC2 soap_instantiate_ns1__LocationChangeRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:821 */
#ifndef SOAP_TYPE_ns1__LoginFailureRecordType
#define SOAP_TYPE_ns1__LoginFailureRecordType (223)
/* Type ns1__LoginFailureRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:LoginFailureRecordType': */
class SOAP_CMAC ns1__LoginFailureRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'login' of XSD type 'xsd:string'
        char *login;
        /// Optional element 'userId' of XSD type 'xsd:long'
        LONG64 *userId;
        /// Required element 'idT' of XSD type 'xsd:int'
        int idT;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LoginFailureRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LoginFailureRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LoginFailureRecordType, default initialized and not managed by a soap context
        virtual ns1__LoginFailureRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__LoginFailureRecordType); }
      public:
        /// Constructor with initializations
        ns1__LoginFailureRecordType() : login(), userId(), idT() { }
        virtual ~ns1__LoginFailureRecordType() { }
        /// Friend allocator used by soap_new_ns1__LoginFailureRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__LoginFailureRecordType * SOAP_FMAC2 soap_instantiate_ns1__LoginFailureRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:824 */
#ifndef SOAP_TYPE_ns1__MaintenanceAccessRecordType
#define SOAP_TYPE_ns1__MaintenanceAccessRecordType (224)
/* Type ns1__MaintenanceAccessRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MaintenanceAccessRecordType': */
class SOAP_CMAC ns1__MaintenanceAccessRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'idT' of XSD type 'xsd:int'
        int idT;
        /// Required element 'op' of XSD type 'xsd:int'
        int op;
        /// Required element 'mainteUser' of XSD type 'xsd:long'
        LONG64 mainteUser;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MaintenanceAccessRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MaintenanceAccessRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MaintenanceAccessRecordType, default initialized and not managed by a soap context
        virtual ns1__MaintenanceAccessRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__MaintenanceAccessRecordType); }
      public:
        /// Constructor with initializations
        ns1__MaintenanceAccessRecordType() : shift(), idT(), op(), mainteUser() { }
        virtual ~ns1__MaintenanceAccessRecordType() { }
        /// Friend allocator used by soap_new_ns1__MaintenanceAccessRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MaintenanceAccessRecordType * SOAP_FMAC2 soap_instantiate_ns1__MaintenanceAccessRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:827 */
#ifndef SOAP_TYPE_ns1__StationModeChangeRecordType
#define SOAP_TYPE_ns1__StationModeChangeRecordType (225)
/* Type ns1__StationModeChangeRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StationModeChangeRecordType': */
class SOAP_CMAC ns1__StationModeChangeRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'cs' of XSD type 'xsd:long'
        LONG64 cs;
        /// Required element 'h' of XSD type 'xsd:long'
        LONG64 h;
        /// Required element 'sm' of XSD type 'xsd:long'
        LONG64 sm;
        /// Required element 'osm' of XSD type 'xsd:long'
        LONG64 osm;
        /// Required element 'userId' of XSD type 'xsd:long'
        LONG64 userId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StationModeChangeRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StationModeChangeRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StationModeChangeRecordType, default initialized and not managed by a soap context
        virtual ns1__StationModeChangeRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__StationModeChangeRecordType); }
      public:
        /// Constructor with initializations
        ns1__StationModeChangeRecordType() : cs(), h(), sm(), osm(), userId() { }
        virtual ~ns1__StationModeChangeRecordType() { }
        /// Friend allocator used by soap_new_ns1__StationModeChangeRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StationModeChangeRecordType * SOAP_FMAC2 soap_instantiate_ns1__StationModeChangeRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:830 */
#ifndef SOAP_TYPE_ns1__StartTripRecordType
#define SOAP_TYPE_ns1__StartTripRecordType (226)
/* Type ns1__StartTripRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:StartTripRecordType': */
class SOAP_CMAC ns1__StartTripRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'effortNum' of XSD type 'xsd:long'
        LONG64 effortNum;
        /// Required element 'thExitTime' of XSD type 'xsd:dateTime'
        time_t thExitTime;
        /// Required element 'realExitTime' of XSD type 'xsd:dateTime'
        time_t realExitTime;
      public:
        /// Return unique type id SOAP_TYPE_ns1__StartTripRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__StartTripRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__StartTripRecordType, default initialized and not managed by a soap context
        virtual ns1__StartTripRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__StartTripRecordType); }
      public:
        /// Constructor with initializations
        ns1__StartTripRecordType() : shift(), effortNum(), thExitTime(), realExitTime() { }
        virtual ~ns1__StartTripRecordType() { }
        /// Friend allocator used by soap_new_ns1__StartTripRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__StartTripRecordType * SOAP_FMAC2 soap_instantiate_ns1__StartTripRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:833 */
#ifndef SOAP_TYPE_ns1__EndTripRecordType
#define SOAP_TYPE_ns1__EndTripRecordType (227)
/* Type ns1__EndTripRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:EndTripRecordType': */
class SOAP_CMAC ns1__EndTripRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'realEndTime' of XSD type 'xsd:dateTime'
        time_t realEndTime;
        /// Required element 'totalAmount' of XSD type 'xsd:long'
        LONG64 totalAmount;
        /// Required element 'drL' of XSD type 'ns1:dataReportListType'
        ns1__dataReportListType *drL;
      public:
        /// Return unique type id SOAP_TYPE_ns1__EndTripRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__EndTripRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__EndTripRecordType, default initialized and not managed by a soap context
        virtual ns1__EndTripRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__EndTripRecordType); }
      public:
        /// Constructor with initializations
        ns1__EndTripRecordType() : shift(), realEndTime(), totalAmount(), drL() { }
        virtual ~ns1__EndTripRecordType() { }
        /// Friend allocator used by soap_new_ns1__EndTripRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__EndTripRecordType * SOAP_FMAC2 soap_instantiate_ns1__EndTripRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:836 */
#ifndef SOAP_TYPE_ns1__IncidenceRecordType
#define SOAP_TYPE_ns1__IncidenceRecordType (228)
/* Type ns1__IncidenceRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:IncidenceRecordType': */
class SOAP_CMAC ns1__IncidenceRecordType : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Required element 'incidenceId' of XSD type 'xsd:int'
        int incidenceId;
        /// Optional element 'outComeId' of XSD type 'xsd:int'
        int *outComeId;
        /// Optional element 'desc' of XSD type 'xsd:string'
        char *desc;
      public:
        /// Return unique type id SOAP_TYPE_ns1__IncidenceRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__IncidenceRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__IncidenceRecordType, default initialized and not managed by a soap context
        virtual ns1__IncidenceRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__IncidenceRecordType); }
      public:
        /// Constructor with initializations
        ns1__IncidenceRecordType() : shift(), incidenceId(), outComeId(), desc() { }
        virtual ~ns1__IncidenceRecordType() { }
        /// Friend allocator used by soap_new_ns1__IncidenceRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__IncidenceRecordType * SOAP_FMAC2 soap_instantiate_ns1__IncidenceRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:839 */
#ifndef SOAP_TYPE_ns1__ParkingValidationRecord
#define SOAP_TYPE_ns1__ParkingValidationRecord (229)
/* Type ns1__ParkingValidationRecord is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ParkingValidationRecord': */
class SOAP_CMAC ns1__ParkingValidationRecord : public ns1__BaseRecordType {
      public:
        /// Optional element 'shift' of XSD type 'ns1:shiftType'
        ns1__shiftType *shift;
        /// Optional element 'fareInfo' of XSD type 'ns1:FareInfo'
        ns1__FareInfo *fareInfo;
        /// Required element 'valInfo' of XSD type 'ns1:ParkingValidationInfo'
        ns1__ParkingValidationInfo *valInfo;
        /// Optional element 'sam' of XSD type 'xsd:unsignedLong'
        ULONG64 *sam;
        /// Optional element 'card' of XSD type 'ns1:cardIdentificationType'
        ns1__cardIdentificationType *card;
        /// Optional element 'ctlInfo' of XSD type 'ns1:CardDataInfoType'
        ns1__CardDataInfoType *ctlInfo;
        /// Optional element 'ctlData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *ctlData;
        /// Optional element 'cData' of XSD type 'ns1:CardDataMagType'
        ns1__CardDataMagType *cData;
        /// Optional element 'rawData' of XSD type 'xsd:base64Binary'
        xsd__base64Binary *rawData;
        /// Optional element 'relTrans' of XSD type 'ns1:RecordIdType'
        ns1__RecordIdType *relTrans;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ParkingValidationRecord
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ParkingValidationRecord; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ParkingValidationRecord, default initialized and not managed by a soap context
        virtual ns1__ParkingValidationRecord *soap_alloc(void) const { return SOAP_NEW(ns1__ParkingValidationRecord); }
      public:
        /// Constructor with initializations
        ns1__ParkingValidationRecord() : shift(), fareInfo(), valInfo(), sam(), card(), ctlInfo(), ctlData(), cData(), rawData(), relTrans() { }
        virtual ~ns1__ParkingValidationRecord() { }
        /// Friend allocator used by soap_new_ns1__ParkingValidationRecord(struct soap*, int)
        friend SOAP_FMAC1 ns1__ParkingValidationRecord * SOAP_FMAC2 soap_instantiate_ns1__ParkingValidationRecord(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:848 */
#ifndef SOAP_TYPE_ns1__SamQuotaUpdateRecordType
#define SOAP_TYPE_ns1__SamQuotaUpdateRecordType (232)
/* Type ns1__SamQuotaUpdateRecordType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SamQuotaUpdateRecordType': */
class SOAP_CMAC ns1__SamQuotaUpdateRecordType : public ns1__BaseRecordType {
      public:
        /// Required element 'samId' of XSD type 'xsd:long'
        LONG64 samId;
        /// Required element 'quota' of XSD type 'xsd:long'
        LONG64 quota;
        /// Required element 'oldQuota' of XSD type 'xsd:long'
        LONG64 oldQuota;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SamQuotaUpdateRecordType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SamQuotaUpdateRecordType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SamQuotaUpdateRecordType, default initialized and not managed by a soap context
        virtual ns1__SamQuotaUpdateRecordType *soap_alloc(void) const { return SOAP_NEW(ns1__SamQuotaUpdateRecordType); }
      public:
        /// Constructor with initializations
        ns1__SamQuotaUpdateRecordType() : samId(), quota(), oldQuota() { }
        virtual ~ns1__SamQuotaUpdateRecordType() { }
        /// Friend allocator used by soap_new_ns1__SamQuotaUpdateRecordType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SamQuotaUpdateRecordType * SOAP_FMAC2 soap_instantiate_ns1__SamQuotaUpdateRecordType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:854 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionResponseType (234)
/* Type ns1__SrvMTC_USCORETransactionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_TransactionResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCORETransactionResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'transacList' of XSD type 'ns1:TransactionMTCRegTypeList'
        ns1__TransactionMTCRegTypeList *transacList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORETransactionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORETransactionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORETransactionResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORETransactionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORETransactionResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORETransactionResponseType() : transacList() { }
        virtual ~ns1__SrvMTC_USCORETransactionResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORETransactionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORETransactionResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORETransactionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:866 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREFabricationSusContentType
#define SOAP_TYPE_ns1__MTC_USCOREFabricationSusContentType (238)
/* Type ns1__MTC_USCOREFabricationSusContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_FabricationSusContentType': */
class SOAP_CMAC ns1__MTC_USCOREFabricationSusContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'susType' of XSD type 'xsd:unsignedShort'
        unsigned short susType;
        /// Required element 'hsn' of XSD type 'xsd:unsignedInt'
        unsigned int hsn;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREFabricationSusContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREFabricationSusContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREFabricationSusContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREFabricationSusContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREFabricationSusContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREFabricationSusContentType() : susId(), susType(), hsn() { }
        virtual ~ns1__MTC_USCOREFabricationSusContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREFabricationSusContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREFabricationSusContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREFabricationSusContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:905 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInitializationSusContentType
#define SOAP_TYPE_ns1__MTC_USCOREInitializationSusContentType (251)
/* Type ns1__MTC_USCOREInitializationSusContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_InitializationSusContentType': */
class SOAP_CMAC ns1__MTC_USCOREInitializationSusContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREInitializationSusContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREInitializationSusContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREInitializationSusContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREInitializationSusContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREInitializationSusContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREInitializationSusContentType() : susId() { }
        virtual ~ns1__MTC_USCOREInitializationSusContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREInitializationSusContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREInitializationSusContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREInitializationSusContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:908 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInstanceAppContentType
#define SOAP_TYPE_ns1__MTC_USCOREInstanceAppContentType (252)
/* Type ns1__MTC_USCOREInstanceAppContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_InstanceAppContentType': */
class SOAP_CMAC ns1__MTC_USCOREInstanceAppContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREInstanceAppContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREInstanceAppContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREInstanceAppContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREInstanceAppContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREInstanceAppContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREInstanceAppContentType() : susId(), appId(), appInfo(), action() { }
        virtual ~ns1__MTC_USCOREInstanceAppContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREInstanceAppContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREInstanceAppContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREInstanceAppContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:920 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEditAppContentType
#define SOAP_TYPE_ns1__MTC_USCOREEditAppContentType (256)
/* Type ns1__MTC_USCOREEditAppContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_EditAppContentType': */
class SOAP_CMAC ns1__MTC_USCOREEditAppContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Optional element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short *status;
        /// Optional element 'userType' of XSD type 'xsd:unsignedShort'
        unsigned short *userType;
        /// Optional element 'validity' of XSD type 'ns1:MTC_RangeDateType'
        ns1__MTC_USCORERangeDateType *validity;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREEditAppContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREEditAppContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREEditAppContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREEditAppContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREEditAppContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREEditAppContentType() : susId(), appId(), appInfo(), status(), userType(), validity(), action() { }
        virtual ~ns1__MTC_USCOREEditAppContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREEditAppContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREEditAppContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREEditAppContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:923 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInstanceProfileContentType
#define SOAP_TYPE_ns1__MTC_USCOREInstanceProfileContentType (257)
/* Type ns1__MTC_USCOREInstanceProfileContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_InstanceProfileContentType': */
class SOAP_CMAC ns1__MTC_USCOREInstanceProfileContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'profileId' of XSD type 'xsd:unsignedInt'
        unsigned int profileId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'profileInfo' of XSD type 'ns1:MTC_ProfileInfoType'
        ns1__MTC_USCOREProfileInfoType *profileInfo;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREInstanceProfileContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREInstanceProfileContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREInstanceProfileContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREInstanceProfileContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREInstanceProfileContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREInstanceProfileContentType() : susId(), appId(), profileId(), appInfo(), profileInfo(), action() { }
        virtual ~ns1__MTC_USCOREInstanceProfileContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREInstanceProfileContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREInstanceProfileContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREInstanceProfileContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:929 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEditProfileContentType
#define SOAP_TYPE_ns1__MTC_USCOREEditProfileContentType (259)
/* Type ns1__MTC_USCOREEditProfileContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_EditProfileContentType': */
class SOAP_CMAC ns1__MTC_USCOREEditProfileContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'profileId' of XSD type 'xsd:unsignedInt'
        unsigned int profileId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'profileInfo' of XSD type 'ns1:MTC_ProfileInfoType'
        ns1__MTC_USCOREProfileInfoType *profileInfo;
        /// Optional element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short *status;
        /// Optional element 'validity' of XSD type 'ns1:MTC_RangeDateType'
        ns1__MTC_USCORERangeDateType *validity;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREEditProfileContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREEditProfileContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREEditProfileContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREEditProfileContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREEditProfileContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREEditProfileContentType() : susId(), appId(), profileId(), appInfo(), profileInfo(), status(), validity(), action() { }
        virtual ~ns1__MTC_USCOREEditProfileContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREEditProfileContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREEditProfileContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREEditProfileContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:932 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREDeleteProfileContentType
#define SOAP_TYPE_ns1__MTC_USCOREDeleteProfileContentType (260)
/* Type ns1__MTC_USCOREDeleteProfileContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_DeleteProfileContentType': */
class SOAP_CMAC ns1__MTC_USCOREDeleteProfileContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'profileId' of XSD type 'xsd:unsignedInt'
        unsigned int profileId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREDeleteProfileContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREDeleteProfileContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREDeleteProfileContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREDeleteProfileContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREDeleteProfileContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREDeleteProfileContentType() : susId(), appId(), profileId(), appInfo(), action() { }
        virtual ~ns1__MTC_USCOREDeleteProfileContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREDeleteProfileContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREDeleteProfileContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREDeleteProfileContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:935 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInstanceTitleContentType
#define SOAP_TYPE_ns1__MTC_USCOREInstanceTitleContentType (261)
/* Type ns1__MTC_USCOREInstanceTitleContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_InstanceTitleContentType': */
class SOAP_CMAC ns1__MTC_USCOREInstanceTitleContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'titleId' of XSD type 'ns1:ProductIdType'
        ns1__ProductIdType *titleId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'titleInfo' of XSD type 'ns1:MTC_TitleInfoType'
        ns1__MTC_USCORETitleInfoType *titleInfo;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREInstanceTitleContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREInstanceTitleContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREInstanceTitleContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREInstanceTitleContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREInstanceTitleContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREInstanceTitleContentType() : susId(), appId(), titleId(), appInfo(), titleInfo(), action() { }
        virtual ~ns1__MTC_USCOREInstanceTitleContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREInstanceTitleContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREInstanceTitleContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREInstanceTitleContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:953 */
#ifndef SOAP_TYPE_ns1__MTC_USCORERechargeTitleContentType
#define SOAP_TYPE_ns1__MTC_USCORERechargeTitleContentType (267)
/* Type ns1__MTC_USCORERechargeTitleContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_RechargeTitleContentType': */
class SOAP_CMAC ns1__MTC_USCORERechargeTitleContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'titleId' of XSD type 'ns1:ProductIdType'
        ns1__ProductIdType *titleId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'titleInfo' of XSD type 'ns1:MTC_TitleInfoType'
        ns1__MTC_USCORETitleInfoType *titleInfo;
        /// Sequence of at least 1 elements 'quantity' of XSD type 'ns1:MTC_QuantityType' stored in dynamic array quantity of length __sizequantity
        int __sizequantity;
        ns1__MTC_USCOREQuantityType **quantity;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORERechargeTitleContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORERechargeTitleContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORERechargeTitleContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORERechargeTitleContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORERechargeTitleContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORERechargeTitleContentType() : susId(), appId(), titleId(), appInfo(), titleInfo(), __sizequantity(), quantity(), action() { }
        virtual ~ns1__MTC_USCORERechargeTitleContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORERechargeTitleContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORERechargeTitleContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORERechargeTitleContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:956 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREValidationTitleContentType
#define SOAP_TYPE_ns1__MTC_USCOREValidationTitleContentType (268)
/* Type ns1__MTC_USCOREValidationTitleContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_ValidationTitleContentType': */
class SOAP_CMAC ns1__MTC_USCOREValidationTitleContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'titleId' of XSD type 'ns1:ProductIdType'
        ns1__ProductIdType *titleId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'titleInfo' of XSD type 'ns1:MTC_TitleInfoType'
        ns1__MTC_USCORETitleInfoType *titleInfo;
        /// Required element 'valType' of XSD type 'xsd:unsignedInt'
        unsigned int valType;
        /// Required element 'valResult' of XSD type 'xsd:unsignedInt'
        unsigned int valResult;
        /// Required element 'fareId' of XSD type 'xsd:unsignedInt'
        unsigned int fareId;
        /// Sequence of at least 1 elements 'quantity' of XSD type 'ns1:MTC_QuantityType' stored in dynamic array quantity of length __sizequantity
        int __sizequantity;
        ns1__MTC_USCOREQuantityType **quantity;
        /// Required element 'passInStageInProcess' of XSD type 'xsd:unsignedInt'
        unsigned int passInStageInProcess;
        /// Required element 'passOutStageInProcess' of XSD type 'xsd:unsignedInt'
        unsigned int passOutStageInProcess;
        /// Required element 'passInPrevStage' of XSD type 'xsd:unsignedInt'
        unsigned int passInPrevStage;
        /// Required element 'passOutPrevStage' of XSD type 'xsd:unsignedInt'
        unsigned int passOutPrevStage;
        /// Required element 'curve' of XSD type 'ns1:MTC_TMobilitatCurveType'
        ns1__MTC_USCORETMobilitatCurveType *curve;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREValidationTitleContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREValidationTitleContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREValidationTitleContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREValidationTitleContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREValidationTitleContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREValidationTitleContentType() : susId(), appId(), titleId(), appInfo(), titleInfo(), valType(), valResult(), fareId(), __sizequantity(), quantity(), passInStageInProcess(), passOutStageInProcess(), passInPrevStage(), passOutPrevStage(), curve() { }
        virtual ~ns1__MTC_USCOREValidationTitleContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREValidationTitleContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREValidationTitleContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREValidationTitleContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:962 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEditTitleContentType
#define SOAP_TYPE_ns1__MTC_USCOREEditTitleContentType (270)
/* Type ns1__MTC_USCOREEditTitleContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_EditTitleContentType': */
class SOAP_CMAC ns1__MTC_USCOREEditTitleContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'titleId' of XSD type 'ns1:ProductIdType'
        ns1__ProductIdType *titleId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'titleInfo' of XSD type 'ns1:MTC_TitleInfoType'
        ns1__MTC_USCORETitleInfoType *titleInfo;
        /// Required element 'status' of XSD type 'xsd:unsignedShort'
        unsigned short status;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREEditTitleContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREEditTitleContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREEditTitleContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREEditTitleContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREEditTitleContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREEditTitleContentType() : susId(), appId(), titleId(), appInfo(), titleInfo(), status(), action() { }
        virtual ~ns1__MTC_USCOREEditTitleContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREEditTitleContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREEditTitleContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREEditTitleContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:965 */
#ifndef SOAP_TYPE_ns1__MTC_USCORERestitutionTitleContentType
#define SOAP_TYPE_ns1__MTC_USCORERestitutionTitleContentType (271)
/* Type ns1__MTC_USCORERestitutionTitleContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_RestitutionTitleContentType': */
class SOAP_CMAC ns1__MTC_USCORERestitutionTitleContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'susId' of XSD type 'xsd:unsignedLong'
        ULONG64 susId;
        /// Required element 'appId' of XSD type 'xsd:unsignedInt'
        unsigned int appId;
        /// Required element 'titleId' of XSD type 'ns1:ProductIdType'
        ns1__ProductIdType *titleId;
        /// Required element 'appInfo' of XSD type 'ns1:MTC_ApplicationInfoType'
        ns1__MTC_USCOREApplicationInfoType *appInfo;
        /// Required element 'titleInfo' of XSD type 'ns1:MTC_TitleInfoType'
        ns1__MTC_USCORETitleInfoType *titleInfo;
        /// Sequence of at least 1 elements 'quantity' of XSD type 'ns1:MTC_QuantityType' stored in dynamic array quantity of length __sizequantity
        int __sizequantity;
        ns1__MTC_USCOREQuantityType **quantity;
        /// Optional element 'action' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *action;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCORERestitutionTitleContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCORERestitutionTitleContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCORERestitutionTitleContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCORERestitutionTitleContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCORERestitutionTitleContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCORERestitutionTitleContentType() : susId(), appId(), titleId(), appInfo(), titleInfo(), __sizequantity(), quantity(), action() { }
        virtual ~ns1__MTC_USCORERestitutionTitleContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCORERestitutionTitleContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCORERestitutionTitleContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCORERestitutionTitleContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:968 */
#ifndef SOAP_TYPE_ns1__MTC_USCOREActionExecutedContentType
#define SOAP_TYPE_ns1__MTC_USCOREActionExecutedContentType (272)
/* Type ns1__MTC_USCOREActionExecutedContentType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MTC_ActionExecutedContentType': */
class SOAP_CMAC ns1__MTC_USCOREActionExecutedContentType : public ns1__MTC_USCOREBaseTransactionType {
      public:
        /// Required element 'actionId' of XSD type 'ns1:ActionIdType'
        ns1__ActionIdType *actionId;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MTC_USCOREActionExecutedContentType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MTC_USCOREActionExecutedContentType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MTC_USCOREActionExecutedContentType, default initialized and not managed by a soap context
        virtual ns1__MTC_USCOREActionExecutedContentType *soap_alloc(void) const { return SOAP_NEW(ns1__MTC_USCOREActionExecutedContentType); }
      public:
        /// Constructor with initializations
        ns1__MTC_USCOREActionExecutedContentType() : actionId() { }
        virtual ~ns1__MTC_USCOREActionExecutedContentType() { }
        /// Friend allocator used by soap_new_ns1__MTC_USCOREActionExecutedContentType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MTC_USCOREActionExecutedContentType * SOAP_FMAC2 soap_instantiate_ns1__MTC_USCOREActionExecutedContentType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:974 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType (274)
/* Type ns1__SrvFE_USCOREMTC_USCORETransactionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_TransactionResponseType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCORETransactionResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFERecordMTCType'
        ns1__InfoFERecordMTCType *base;
        /// Required element 'transacList' of XSD type 'ns1:TransactionMTCRegTypeList'
        ns1__TransactionMTCRegTypeList *transacList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCORETransactionResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCORETransactionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCORETransactionResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCORETransactionResponseType() : base(), transacList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCORETransactionResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCORETransactionResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:980 */
#ifndef SOAP_TYPE_ns1__SrvStateResponseType
#define SOAP_TYPE_ns1__SrvStateResponseType (276)
/* Type ns1__SrvStateResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvStateResponseType': */
class SOAP_CMAC ns1__SrvStateResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'state' of XSD type 'ns1:stateType'
        ns1__stateType *state;
        /// Optional element 'slavesState' of XSD type 'ns1:SlaveStateListType'
        ns1__SlaveStateListType *slavesState;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvStateResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvStateResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvStateResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvStateResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvStateResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvStateResponseType() : state(), slavesState() { }
        virtual ~ns1__SrvStateResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvStateResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvStateResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvStateResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:995 */
#ifndef SOAP_TYPE_ns1__MeasureType
#define SOAP_TYPE_ns1__MeasureType (281)
/* Type ns1__MeasureType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XSD type 'ns1:MeasureType': */
class SOAP_CMAC ns1__MeasureType : public xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        char *__item;
        /// optional attribute 'name' of XSD type 'xsd:string'
        char *name;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MeasureType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MeasureType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MeasureType, default initialized and not managed by a soap context
        virtual ns1__MeasureType *soap_alloc(void) const { return SOAP_NEW(ns1__MeasureType); }
      public:
        /// Constructor with initializations
        ns1__MeasureType() : __item(), name() { }
        virtual ~ns1__MeasureType() { }
        /// Friend allocator used by soap_new_ns1__MeasureType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MeasureType * SOAP_FMAC2 soap_instantiate_ns1__MeasureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1004 */
#ifndef SOAP_TYPE_ns1__SlaveStateType
#define SOAP_TYPE_ns1__SlaveStateType (284)
/* Type ns1__SlaveStateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SlaveStateType': */
class SOAP_CMAC ns1__SlaveStateType : public ns1__stateType {
      public:
        /// optional attribute 'id' of XSD type 'xsd:unsignedInt'
        unsigned int *id;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SlaveStateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SlaveStateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SlaveStateType, default initialized and not managed by a soap context
        virtual ns1__SlaveStateType *soap_alloc(void) const { return SOAP_NEW(ns1__SlaveStateType); }
      public:
        /// Constructor with initializations
        ns1__SlaveStateType() : id() { }
        virtual ~ns1__SlaveStateType() { }
        /// Friend allocator used by soap_new_ns1__SlaveStateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SlaveStateType * SOAP_FMAC2 soap_instantiate_ns1__SlaveStateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1010 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREAlarmResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREAlarmResponseType (286)
/* Type ns1__SrvMTC_USCOREAlarmResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_AlarmResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCOREAlarmResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'alarmList' of XSD type 'ns1:AlarmCCTIUListType'
        ns1__AlarmCCTIUListType *alarmList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREAlarmResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREAlarmResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREAlarmResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREAlarmResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREAlarmResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREAlarmResponseType() : alarmList() { }
        virtual ~ns1__SrvMTC_USCOREAlarmResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREAlarmResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREAlarmResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREAlarmResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1019 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREStatusResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREStatusResponseType (289)
/* Type ns1__SrvMTC_USCOREStatusResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_StatusResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCOREStatusResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'statusList' of XSD type 'ns1:StatusCCTIUListType'
        ns1__StatusCCTIUListType *statusList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREStatusResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREStatusResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREStatusResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREStatusResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREStatusResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREStatusResponseType() : statusList() { }
        virtual ~ns1__SrvMTC_USCOREStatusResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREStatusResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREStatusResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREStatusResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1028 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticResponseType (292)
/* Type ns1__SrvMTC_USCOREDiagnosticResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_DiagnosticResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCOREDiagnosticResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'diagnosticList' of XSD type 'ns1:DiagnosticCCTIUListType'
        ns1__DiagnosticCCTIUListType *diagnosticList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREDiagnosticResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREDiagnosticResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREDiagnosticResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREDiagnosticResponseType() : diagnosticList() { }
        virtual ~ns1__SrvMTC_USCOREDiagnosticResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREDiagnosticResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREDiagnosticResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREDiagnosticResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1037 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREVersionResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREVersionResponseType (295)
/* Type ns1__SrvMTC_USCOREVersionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_VersionResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCOREVersionResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'versionList' of XSD type 'ns1:VersionsCCTIUType'
        ns1__VersionsCCTIUType *versionList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREVersionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREVersionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREVersionResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREVersionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREVersionResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREVersionResponseType() : versionList() { }
        virtual ~ns1__SrvMTC_USCOREVersionResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREVersionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREVersionResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREVersionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1061 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementResponseType (303)
/* Type ns1__SrvMTC_USCOREConfigElementResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_ConfigElementResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCOREConfigElementResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'configElemList' of XSD type 'ns1:ConfigElementCCTIUListType'
        ns1__ConfigElementCCTIUListType *configElemList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREConfigElementResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREConfigElementResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREConfigElementResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREConfigElementResponseType() : configElemList() { }
        virtual ~ns1__SrvMTC_USCOREConfigElementResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREConfigElementResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREConfigElementResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREConfigElementResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1064 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeResponseType (304)
/* Type ns1__SrvMTC_USCOREConfigElementChangeResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_ConfigElementChangeResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCOREConfigElementChangeResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREConfigElementChangeResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREConfigElementChangeResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREConfigElementChangeResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREConfigElementChangeResponseType() { }
        virtual ~ns1__SrvMTC_USCOREConfigElementChangeResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREConfigElementChangeResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREConfigElementChangeResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREConfigElementChangeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1067 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORECommandExecResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCORECommandExecResponseType (305)
/* Type ns1__SrvMTC_USCORECommandExecResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_CommandExecResponseType': */
class SOAP_CMAC ns1__SrvMTC_USCORECommandExecResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'status' of XSD type 'xsd:unsignedInt'
        unsigned int status;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORECommandExecResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORECommandExecResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORECommandExecResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORECommandExecResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORECommandExecResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORECommandExecResponseType() : status() { }
        virtual ~ns1__SrvMTC_USCORECommandExecResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORECommandExecResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORECommandExecResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORECommandExecResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1070 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType (306)
/* Type ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_AlarmResponseType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFEMonitorCCTIUType'
        ns1__InfoFEMonitorCCTIUType *base;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmCCTIUListType'
        ns1__AlarmCCTIUListType *alarmList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType() : base(), alarmList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1076 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType (308)
/* Type ns1__SrvFE_USCOREMTC_USCOREStatusResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_StatusResponseType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREStatusResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFEMonitorCCTIUType'
        ns1__InfoFEMonitorCCTIUType *base;
        /// Required element 'statusList' of XSD type 'ns1:StatusCCTIUListType'
        ns1__StatusCCTIUListType *statusList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREStatusResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREStatusResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREStatusResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREStatusResponseType() : base(), statusList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREStatusResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREStatusResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1079 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType (309)
/* Type ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_DiagnosticResponseType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFEMonitorCCTIUType'
        ns1__InfoFEMonitorCCTIUType *base;
        /// Required element 'diagnosticList' of XSD type 'ns1:DiagnosticCCTIUListType'
        ns1__DiagnosticCCTIUListType *diagnosticList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType() : base(), diagnosticList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1082 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType (310)
/* Type ns1__SrvFE_USCOREMTC_USCOREVersionResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_VersionResponseType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREVersionResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFEMonitorCCTIUType'
        ns1__InfoFEMonitorCCTIUType *base;
        /// Required element 'versionList' of XSD type 'ns1:VersionsCCTIUType'
        ns1__VersionsCCTIUType *versionList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREVersionResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREVersionResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREVersionResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREVersionResponseType() : base(), versionList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREVersionResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREVersionResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1085 */
#ifndef SOAP_TYPE_ns1__SrvConfigurationContentResponseType
#define SOAP_TYPE_ns1__SrvConfigurationContentResponseType (311)
/* Type ns1__SrvConfigurationContentResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvConfigurationContentResponseType': */
class SOAP_CMAC ns1__SrvConfigurationContentResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Optional element 'file' of XSD type 'ns2:ConfigurationDocument'
        ns2__ConfigurationDocument *file;
        /// Optional element 'pkg' of XSD type 'ns1:PackageConfigVersionType'
        ns1__PackageConfigVersionType *pkg;
        /// Required element 'askForMore' of XSD type 'xsd:boolean'
        bool askForMore;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvConfigurationContentResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvConfigurationContentResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvConfigurationContentResponseType, default initialized and not managed by a soap context
        virtual ns1__SrvConfigurationContentResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvConfigurationContentResponseType); }
      public:
        /// Constructor with initializations
        ns1__SrvConfigurationContentResponseType() : file(), pkg(), askForMore() { }
        virtual ~ns1__SrvConfigurationContentResponseType() { }
        /// Friend allocator used by soap_new_ns1__SrvConfigurationContentResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvConfigurationContentResponseType * SOAP_FMAC2 soap_instantiate_ns1__SrvConfigurationContentResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1088 */
#ifndef SOAP_TYPE_ns1__versionList
#define SOAP_TYPE_ns1__versionList (312)
/* Type ns1__versionList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:versionList': */
class SOAP_CMAC ns1__versionList : public ns1__PatternServiceResponseType {
      public:
        /// Required element 'pkgList' of XSD type 'ns1:PackageConfigVersionListType'
        ns1__PackageConfigVersionListType *pkgList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__versionList
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__versionList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__versionList, default initialized and not managed by a soap context
        virtual ns1__versionList *soap_alloc(void) const { return SOAP_NEW(ns1__versionList); }
      public:
        /// Constructor with initializations
        ns1__versionList() : pkgList() { }
        virtual ~ns1__versionList() { }
        /// Friend allocator used by soap_new_ns1__versionList(struct soap*, int)
        friend SOAP_FMAC1 ns1__versionList * SOAP_FMAC2 soap_instantiate_ns1__versionList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1091 */
#ifndef SOAP_TYPE_ns1__srvPresentationBaseResponseType
#define SOAP_TYPE_ns1__srvPresentationBaseResponseType (313)
/* Type ns1__srvPresentationBaseResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvPresentationBaseResponseType': */
class SOAP_CMAC ns1__srvPresentationBaseResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvPresentationBaseResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvPresentationBaseResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvPresentationBaseResponseType, default initialized and not managed by a soap context
        virtual ns1__srvPresentationBaseResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__srvPresentationBaseResponseType); }
      public:
        /// Constructor with initializations
        ns1__srvPresentationBaseResponseType() { }
        virtual ~ns1__srvPresentationBaseResponseType() { }
        /// Friend allocator used by soap_new_ns1__srvPresentationBaseResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvPresentationBaseResponseType * SOAP_FMAC2 soap_instantiate_ns1__srvPresentationBaseResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1106 */
#ifndef SOAP_TYPE_ns1__srvConfigurationBaseResponseType
#define SOAP_TYPE_ns1__srvConfigurationBaseResponseType (318)
/* Type ns1__srvConfigurationBaseResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvConfigurationBaseResponseType': */
class SOAP_CMAC ns1__srvConfigurationBaseResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvConfigurationBaseResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvConfigurationBaseResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvConfigurationBaseResponseType, default initialized and not managed by a soap context
        virtual ns1__srvConfigurationBaseResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__srvConfigurationBaseResponseType); }
      public:
        /// Constructor with initializations
        ns1__srvConfigurationBaseResponseType() { }
        virtual ~ns1__srvConfigurationBaseResponseType() { }
        /// Friend allocator used by soap_new_ns1__srvConfigurationBaseResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvConfigurationBaseResponseType * SOAP_FMAC2 soap_instantiate_ns1__srvConfigurationBaseResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1124 */
#ifndef SOAP_TYPE_ns1__srvCommandBaseResponseType
#define SOAP_TYPE_ns1__srvCommandBaseResponseType (324)
/* Type ns1__srvCommandBaseResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvCommandBaseResponseType': */
class SOAP_CMAC ns1__srvCommandBaseResponseType : public ns1__PatternServiceResponseType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvCommandBaseResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvCommandBaseResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvCommandBaseResponseType, default initialized and not managed by a soap context
        virtual ns1__srvCommandBaseResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__srvCommandBaseResponseType); }
      public:
        /// Constructor with initializations
        ns1__srvCommandBaseResponseType() { }
        virtual ~ns1__srvCommandBaseResponseType() { }
        /// Friend allocator used by soap_new_ns1__srvCommandBaseResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvCommandBaseResponseType * SOAP_FMAC2 soap_instantiate_ns1__srvCommandBaseResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1133 */
#ifndef SOAP_TYPE_ns1__MtvmExtStateType
#define SOAP_TYPE_ns1__MtvmExtStateType (327)
/* Type ns1__MtvmExtStateType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:MtvmExtStateType': */
class SOAP_CMAC ns1__MtvmExtStateType : public ns1__ExtStateType {
      public:
        /// Optional element 'dispenserData' of XSD type 'ns1:MediaDispenserListType'
        ns1__MediaDispenserListType *dispenserData;
      public:
        /// Return unique type id SOAP_TYPE_ns1__MtvmExtStateType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__MtvmExtStateType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__MtvmExtStateType, default initialized and not managed by a soap context
        virtual ns1__MtvmExtStateType *soap_alloc(void) const { return SOAP_NEW(ns1__MtvmExtStateType); }
      public:
        /// Constructor with initializations
        ns1__MtvmExtStateType() : dispenserData() { }
        virtual ~ns1__MtvmExtStateType() { }
        /// Friend allocator used by soap_new_ns1__MtvmExtStateType(struct soap*, int)
        friend SOAP_FMAC1 ns1__MtvmExtStateType * SOAP_FMAC2 soap_instantiate_ns1__MtvmExtStateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1211 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionConfirmationType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionConfirmationType (353)
/* Type ns1__SrvMTC_USCORETransactionConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_TransactionConfirmationType': */
class SOAP_CMAC ns1__SrvMTC_USCORETransactionConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Required element 'confList' of XSD type 'ns1:TransactionMTCConfTypeList'
        ns1__TransactionMTCConfTypeList *confList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORETransactionConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORETransactionConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORETransactionConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORETransactionConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORETransactionConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORETransactionConfirmationType() : confList() { }
        virtual ~ns1__SrvMTC_USCORETransactionConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORETransactionConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORETransactionConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORETransactionConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1217 */
#ifndef SOAP_TYPE_ns1__SrvRecordConfirmationType
#define SOAP_TYPE_ns1__SrvRecordConfirmationType (355)
/* Type ns1__SrvRecordConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvRecordConfirmationType': */
class SOAP_CMAC ns1__SrvRecordConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Required element 'confList' of XSD type 'ns1:RecordConfirmationListType'
        ns1__RecordConfirmationListType *confList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvRecordConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvRecordConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvRecordConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvRecordConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvRecordConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvRecordConfirmationType() : confList() { }
        virtual ~ns1__SrvRecordConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvRecordConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvRecordConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvRecordConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1226 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType (358)
/* Type ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_TransactionConfirmationType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Required element 'confList' of XSD type 'ns1:TransactionMTCConfTypeList'
        ns1__TransactionMTCConfTypeList *confList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType() : confList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1229 */
#ifndef SOAP_TYPE_ns1__SrvStateConfirmationType
#define SOAP_TYPE_ns1__SrvStateConfirmationType (359)
/* Type ns1__SrvStateConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvStateConfirmationType': */
class SOAP_CMAC ns1__SrvStateConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvStateConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvStateConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvStateConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvStateConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvStateConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvStateConfirmationType() { }
        virtual ~ns1__SrvStateConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvStateConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvStateConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvStateConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1232 */
#ifndef SOAP_TYPE_ns1__SrvAlarmConfirmationType
#define SOAP_TYPE_ns1__SrvAlarmConfirmationType (360)
/* Type ns1__SrvAlarmConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvAlarmConfirmationType': */
class SOAP_CMAC ns1__SrvAlarmConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvAlarmConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvAlarmConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvAlarmConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvAlarmConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvAlarmConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvAlarmConfirmationType() { }
        virtual ~ns1__SrvAlarmConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvAlarmConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvAlarmConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvAlarmConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1235 */
#ifndef SOAP_TYPE_ns1__SrvNewConfigurationConfirmationType
#define SOAP_TYPE_ns1__SrvNewConfigurationConfirmationType (361)
/* Type ns1__SrvNewConfigurationConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvNewConfigurationConfirmationType': */
class SOAP_CMAC ns1__SrvNewConfigurationConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Required element 'pkgList' of XSD type 'ns1:PackageConfigVersionListType'
        ns1__PackageConfigVersionListType *pkgList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvNewConfigurationConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvNewConfigurationConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvNewConfigurationConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvNewConfigurationConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvNewConfigurationConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvNewConfigurationConfirmationType() : pkgList() { }
        virtual ~ns1__SrvNewConfigurationConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvNewConfigurationConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvNewConfigurationConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvNewConfigurationConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1238 */
#ifndef SOAP_TYPE_ns1__SrvFileConfirmationType
#define SOAP_TYPE_ns1__SrvFileConfirmationType (362)
/* Type ns1__SrvFileConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFileConfirmationType': */
class SOAP_CMAC ns1__SrvFileConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Required element 'result' of XSD type 'xsd:unsignedInt'
        unsigned int result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFileConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFileConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFileConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvFileConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFileConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvFileConfirmationType() : result() { }
        virtual ~ns1__SrvFileConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvFileConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFileConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvFileConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1241 */
#ifndef SOAP_TYPE_ns1__SrvOrderConfirmationType
#define SOAP_TYPE_ns1__SrvOrderConfirmationType (363)
/* Type ns1__SrvOrderConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvOrderConfirmationType': */
class SOAP_CMAC ns1__SrvOrderConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Required element 'params' of XSD type 'xsd:string'
        char *params;
        /// Required element 'orderType' of XSD type 'xsd:int'
        int orderType;
        /// Required element 'result' of XSD type 'xsd:int'
        int result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvOrderConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvOrderConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvOrderConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvOrderConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvOrderConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvOrderConfirmationType() : params(), orderType(), result() { }
        virtual ~ns1__SrvOrderConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvOrderConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvOrderConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvOrderConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1244 */
#ifndef SOAP_TYPE_ns1__SrvTvmExtendedStateConfirmationType
#define SOAP_TYPE_ns1__SrvTvmExtendedStateConfirmationType (364)
/* Type ns1__SrvTvmExtendedStateConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvTvmExtendedStateConfirmationType': */
class SOAP_CMAC ns1__SrvTvmExtendedStateConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvTvmExtendedStateConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvTvmExtendedStateConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvTvmExtendedStateConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvTvmExtendedStateConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvTvmExtendedStateConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvTvmExtendedStateConfirmationType() { }
        virtual ~ns1__SrvTvmExtendedStateConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvTvmExtendedStateConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvTvmExtendedStateConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvTvmExtendedStateConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1247 */
#ifndef SOAP_TYPE_ns1__SrvMtvmExtendedStateConfirmationType
#define SOAP_TYPE_ns1__SrvMtvmExtendedStateConfirmationType (365)
/* Type ns1__SrvMtvmExtendedStateConfirmationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMtvmExtendedStateConfirmationType': */
class SOAP_CMAC ns1__SrvMtvmExtendedStateConfirmationType : public ns1__PatternServiceConfirmationType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMtvmExtendedStateConfirmationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMtvmExtendedStateConfirmationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMtvmExtendedStateConfirmationType, default initialized and not managed by a soap context
        virtual ns1__SrvMtvmExtendedStateConfirmationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMtvmExtendedStateConfirmationType); }
      public:
        /// Constructor with initializations
        ns1__SrvMtvmExtendedStateConfirmationType() { }
        virtual ~ns1__SrvMtvmExtendedStateConfirmationType() { }
        /// Friend allocator used by soap_new_ns1__SrvMtvmExtendedStateConfirmationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMtvmExtendedStateConfirmationType * SOAP_FMAC2 soap_instantiate_ns1__SrvMtvmExtendedStateConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1250 */
#ifndef SOAP_TYPE_ns1__SrvAgExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvAgExtendedStateNotificationType (366)
/* Type ns1__SrvAgExtendedStateNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvAgExtendedStateNotificationType': */
class SOAP_CMAC ns1__SrvAgExtendedStateNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'ags' of XSD type 'ns1:AgExtStateType'
        ns1__AgExtStateType *ags;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvAgExtendedStateNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvAgExtendedStateNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvAgExtendedStateNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvAgExtendedStateNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvAgExtendedStateNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvAgExtendedStateNotificationType() : ags() { }
        virtual ~ns1__SrvAgExtendedStateNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvAgExtendedStateNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvAgExtendedStateNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvAgExtendedStateNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1256 */
#ifndef SOAP_TYPE_ns1__SrvRecordNotificationType
#define SOAP_TYPE_ns1__SrvRecordNotificationType (368)
/* Type ns1__SrvRecordNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvRecordNotificationType': */
class SOAP_CMAC ns1__SrvRecordNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'recList' of XSD type 'ns1:RecordListType'
        ns1__RecordListType *recList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvRecordNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvRecordNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvRecordNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvRecordNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvRecordNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvRecordNotificationType() : recList() { }
        virtual ~ns1__SrvRecordNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvRecordNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvRecordNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvRecordNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1259 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionNotificationType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionNotificationType (369)
/* Type ns1__SrvMTC_USCORETransactionNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_TransactionNotificationType': */
class SOAP_CMAC ns1__SrvMTC_USCORETransactionNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'transacList' of XSD type 'ns1:TransactionMTCRegTypeList'
        ns1__TransactionMTCRegTypeList *transacList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORETransactionNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORETransactionNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORETransactionNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORETransactionNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORETransactionNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORETransactionNotificationType() : transacList() { }
        virtual ~ns1__SrvMTC_USCORETransactionNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORETransactionNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORETransactionNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORETransactionNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1262 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType (370)
/* Type ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_TransactionNotificationType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFERecordMTCType'
        ns1__InfoFERecordMTCType *base;
        /// Required element 'transacList' of XSD type 'ns1:TransactionMTCRegTypeList'
        ns1__TransactionMTCRegTypeList *transacList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType() : base(), transacList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1265 */
#ifndef SOAP_TYPE_ns1__SrvStateNotificationType
#define SOAP_TYPE_ns1__SrvStateNotificationType (371)
/* Type ns1__SrvStateNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvStateNotificationType': */
class SOAP_CMAC ns1__SrvStateNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'state' of XSD type 'ns1:stateType'
        ns1__stateType *state;
        /// Optional element 'slavesState' of XSD type 'ns1:SlaveStateListType'
        ns1__SlaveStateListType *slavesState;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvStateNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvStateNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvStateNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvStateNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvStateNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvStateNotificationType() : state(), slavesState() { }
        virtual ~ns1__SrvStateNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvStateNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvStateNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvStateNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1268 */
#ifndef SOAP_TYPE_ns1__SrvAlarmNotificationType
#define SOAP_TYPE_ns1__SrvAlarmNotificationType (372)
/* Type ns1__SrvAlarmNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvAlarmNotificationType': */
class SOAP_CMAC ns1__SrvAlarmNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'alarmList' of XSD type 'ns1:AlarmListType'
        ns1__AlarmListType *alarmList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvAlarmNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvAlarmNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvAlarmNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvAlarmNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvAlarmNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvAlarmNotificationType() : alarmList() { }
        virtual ~ns1__SrvAlarmNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvAlarmNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvAlarmNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvAlarmNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1271 */
#ifndef SOAP_TYPE_ns1__SrvConfigurationNotificationType
#define SOAP_TYPE_ns1__SrvConfigurationNotificationType (373)
/* Type ns1__SrvConfigurationNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvConfigurationNotificationType': */
class SOAP_CMAC ns1__SrvConfigurationNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'pl' of XSD type 'ns1:confPackageListType'
        ns1__confPackageListType *pl;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvConfigurationNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvConfigurationNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvConfigurationNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvConfigurationNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvConfigurationNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvConfigurationNotificationType() : pl() { }
        virtual ~ns1__SrvConfigurationNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvConfigurationNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvConfigurationNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvConfigurationNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1274 */
#ifndef SOAP_TYPE_ns1__SrvDiagnosticNotificationType
#define SOAP_TYPE_ns1__SrvDiagnosticNotificationType (374)
/* Type ns1__SrvDiagnosticNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvDiagnosticNotificationType': */
class SOAP_CMAC ns1__SrvDiagnosticNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'diagnosticList' of XSD type 'ns1:diagnosticListType'
        ns1__diagnosticListType *diagnosticList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvDiagnosticNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvDiagnosticNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvDiagnosticNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvDiagnosticNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvDiagnosticNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvDiagnosticNotificationType() : diagnosticList() { }
        virtual ~ns1__SrvDiagnosticNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvDiagnosticNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvDiagnosticNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvDiagnosticNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1277 */
#ifndef SOAP_TYPE_ns1__SrvVersionNotificationType
#define SOAP_TYPE_ns1__SrvVersionNotificationType (375)
/* Type ns1__SrvVersionNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvVersionNotificationType': */
class SOAP_CMAC ns1__SrvVersionNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'versionList' of XSD type 'ns1:versionListType'
        ns1__versionListType *versionList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvVersionNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvVersionNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvVersionNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvVersionNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvVersionNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvVersionNotificationType() : versionList() { }
        virtual ~ns1__SrvVersionNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvVersionNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvVersionNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvVersionNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1280 */
#ifndef SOAP_TYPE_ns1__SrvStateConfigInstallationNotificationType
#define SOAP_TYPE_ns1__SrvStateConfigInstallationNotificationType (376)
/* Type ns1__SrvStateConfigInstallationNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvStateConfigInstallationNotificationType': */
class SOAP_CMAC ns1__SrvStateConfigInstallationNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'pl' of XSD type 'ns1:StateConfigInstallationListType'
        ns1__StateConfigInstallationListType *pl;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvStateConfigInstallationNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvStateConfigInstallationNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvStateConfigInstallationNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvStateConfigInstallationNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvStateConfigInstallationNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvStateConfigInstallationNotificationType() : pl() { }
        virtual ~ns1__SrvStateConfigInstallationNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvStateConfigInstallationNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvStateConfigInstallationNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvStateConfigInstallationNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1289 */
#ifndef SOAP_TYPE_ns1__SrvStateSceqnNotificationType
#define SOAP_TYPE_ns1__SrvStateSceqnNotificationType (379)
/* Type ns1__SrvStateSceqnNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvStateSceqnNotificationType': */
class SOAP_CMAC ns1__SrvStateSceqnNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'scL' of XSD type 'ns1:SceqExtStateType'
        ns1__SceqExtStateType *scL;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvStateSceqnNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvStateSceqnNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvStateSceqnNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvStateSceqnNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvStateSceqnNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvStateSceqnNotificationType() : scL() { }
        virtual ~ns1__SrvStateSceqnNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvStateSceqnNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvStateSceqnNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvStateSceqnNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1292 */
#ifndef SOAP_TYPE_ns1__SrvTvmExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvTvmExtendedStateNotificationType (380)
/* Type ns1__SrvTvmExtendedStateNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvTvmExtendedStateNotificationType': */
class SOAP_CMAC ns1__SrvTvmExtendedStateNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'tvms' of XSD type 'ns1:TvmExtStateType'
        ns1__TvmExtStateType *tvms;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvTvmExtendedStateNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvTvmExtendedStateNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvTvmExtendedStateNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvTvmExtendedStateNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvTvmExtendedStateNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvTvmExtendedStateNotificationType() : tvms() { }
        virtual ~ns1__SrvTvmExtendedStateNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvTvmExtendedStateNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvTvmExtendedStateNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvTvmExtendedStateNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1295 */
#ifndef SOAP_TYPE_ns1__SrvExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvExtendedStateNotificationType (381)
/* Type ns1__SrvExtendedStateNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvExtendedStateNotificationType': */
class SOAP_CMAC ns1__SrvExtendedStateNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'ee' of XSD type 'ns1:ExtStateType'
        ns1__ExtStateType *ee;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvExtendedStateNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvExtendedStateNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvExtendedStateNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvExtendedStateNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvExtendedStateNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvExtendedStateNotificationType() : ee() { }
        virtual ~ns1__SrvExtendedStateNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvExtendedStateNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvExtendedStateNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvExtendedStateNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1298 */
#ifndef SOAP_TYPE_ns1__SrvMtvmExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvMtvmExtendedStateNotificationType (382)
/* Type ns1__SrvMtvmExtendedStateNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMtvmExtendedStateNotificationType': */
class SOAP_CMAC ns1__SrvMtvmExtendedStateNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'extState' of XSD type 'ns1:MtvmExtStateType'
        ns1__MtvmExtStateType *extState;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMtvmExtendedStateNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMtvmExtendedStateNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMtvmExtendedStateNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvMtvmExtendedStateNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMtvmExtendedStateNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvMtvmExtendedStateNotificationType() : extState() { }
        virtual ~ns1__SrvMtvmExtendedStateNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvMtvmExtendedStateNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMtvmExtendedStateNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvMtvmExtendedStateNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1301 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREAlarmNotificationType
#define SOAP_TYPE_ns1__SrvMTC_USCOREAlarmNotificationType (383)
/* Type ns1__SrvMTC_USCOREAlarmNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_AlarmNotificationType': */
class SOAP_CMAC ns1__SrvMTC_USCOREAlarmNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'alarmList' of XSD type 'ns1:AlarmCCTIUListType'
        ns1__AlarmCCTIUListType *alarmList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREAlarmNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREAlarmNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREAlarmNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREAlarmNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREAlarmNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREAlarmNotificationType() : alarmList() { }
        virtual ~ns1__SrvMTC_USCOREAlarmNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREAlarmNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREAlarmNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREAlarmNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1304 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREStatusNotificationType
#define SOAP_TYPE_ns1__SrvMTC_USCOREStatusNotificationType (384)
/* Type ns1__SrvMTC_USCOREStatusNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_StatusNotificationType': */
class SOAP_CMAC ns1__SrvMTC_USCOREStatusNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'statusList' of XSD type 'ns1:StatusCCTIUListType'
        ns1__StatusCCTIUListType *statusList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCOREStatusNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCOREStatusNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCOREStatusNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCOREStatusNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCOREStatusNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCOREStatusNotificationType() : statusList() { }
        virtual ~ns1__SrvMTC_USCOREStatusNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCOREStatusNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCOREStatusNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCOREStatusNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1307 */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORECommandExecNotifyType
#define SOAP_TYPE_ns1__SrvMTC_USCORECommandExecNotifyType (385)
/* Type ns1__SrvMTC_USCORECommandExecNotifyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvMTC_CommandExecNotifyType': */
class SOAP_CMAC ns1__SrvMTC_USCORECommandExecNotifyType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'status' of XSD type 'xsd:unsignedInt'
        unsigned int status;
        /// Optional element 'endInError' of XSD type 'xsd:boolean'
        bool *endInError;
        /// Optional element 'errorCode' of XSD type 'xsd:unsignedInt'
        unsigned int *errorCode;
        /// Optional element 'errorDesc' of XSD type 'xsd:string'
        char *errorDesc;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvMTC_USCORECommandExecNotifyType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvMTC_USCORECommandExecNotifyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvMTC_USCORECommandExecNotifyType, default initialized and not managed by a soap context
        virtual ns1__SrvMTC_USCORECommandExecNotifyType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvMTC_USCORECommandExecNotifyType); }
      public:
        /// Constructor with initializations
        ns1__SrvMTC_USCORECommandExecNotifyType() : status(), endInError(), errorCode(), errorDesc() { }
        virtual ~ns1__SrvMTC_USCORECommandExecNotifyType() { }
        /// Friend allocator used by soap_new_ns1__SrvMTC_USCORECommandExecNotifyType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvMTC_USCORECommandExecNotifyType * SOAP_FMAC2 soap_instantiate_ns1__SrvMTC_USCORECommandExecNotifyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1310 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType (386)
/* Type ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_AlarmNotificationType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFEMonitorCCTIUType'
        ns1__InfoFEMonitorCCTIUType *base;
        /// Required element 'alarmList' of XSD type 'ns1:AlarmCCTIUListType'
        ns1__AlarmCCTIUListType *alarmList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType() : base(), alarmList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1313 */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType (387)
/* Type ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFE_MTC_StatusNotificationType': */
class SOAP_CMAC ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'base' of XSD type 'ns1:InfoFEMonitorCCTIUType'
        ns1__InfoFEMonitorCCTIUType *base;
        /// Required element 'statusList' of XSD type 'ns1:StatusCCTIUListType'
        ns1__StatusCCTIUListType *statusList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType() : base(), statusList() { }
        virtual ~ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1316 */
#ifndef SOAP_TYPE_ns1__SrvNewConfigurationNotificationType
#define SOAP_TYPE_ns1__SrvNewConfigurationNotificationType (388)
/* Type ns1__SrvNewConfigurationNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvNewConfigurationNotificationType': */
class SOAP_CMAC ns1__SrvNewConfigurationNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'pkgList' of XSD type 'ns1:PackageConfigVersionListType'
        ns1__PackageConfigVersionListType *pkgList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvNewConfigurationNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvNewConfigurationNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvNewConfigurationNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvNewConfigurationNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvNewConfigurationNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvNewConfigurationNotificationType() : pkgList() { }
        virtual ~ns1__SrvNewConfigurationNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvNewConfigurationNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvNewConfigurationNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvNewConfigurationNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1319 */
#ifndef SOAP_TYPE_ns1__SrvFileNotificationType
#define SOAP_TYPE_ns1__SrvFileNotificationType (389)
/* Type ns1__SrvFileNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvFileNotificationType': */
class SOAP_CMAC ns1__SrvFileNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'filePath' of XSD type 'xsd:string'
        char *filePath;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvFileNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvFileNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvFileNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvFileNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvFileNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvFileNotificationType() : filePath() { }
        virtual ~ns1__SrvFileNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvFileNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvFileNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvFileNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1322 */
#ifndef SOAP_TYPE_ns1__SrvOrderNotificationType
#define SOAP_TYPE_ns1__SrvOrderNotificationType (390)
/* Type ns1__SrvOrderNotificationType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:SrvOrderNotificationType': */
class SOAP_CMAC ns1__SrvOrderNotificationType : public ns1__PatternServiceNotificationType {
      public:
        /// Required element 'params' of XSD type 'xsd:string'
        char *params;
        /// Required element 'orderType' of XSD type 'xsd:int'
        int orderType;
      public:
        /// Return unique type id SOAP_TYPE_ns1__SrvOrderNotificationType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__SrvOrderNotificationType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__SrvOrderNotificationType, default initialized and not managed by a soap context
        virtual ns1__SrvOrderNotificationType *soap_alloc(void) const { return SOAP_NEW(ns1__SrvOrderNotificationType); }
      public:
        /// Constructor with initializations
        ns1__SrvOrderNotificationType() : params(), orderType() { }
        virtual ~ns1__SrvOrderNotificationType() { }
        /// Friend allocator used by soap_new_ns1__SrvOrderNotificationType(struct soap*, int)
        friend SOAP_FMAC1 ns1__SrvOrderNotificationType * SOAP_FMAC2 soap_instantiate_ns1__SrvOrderNotificationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:398 */
#ifndef SOAP_TYPE_ns1__srvPresentationV1RequestType
#define SOAP_TYPE_ns1__srvPresentationV1RequestType (82)
/* Type ns1__srvPresentationV1RequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvPresentationV1RequestType': */
class SOAP_CMAC ns1__srvPresentationV1RequestType : public ns1__srvPresentationBaseRequestType {
      public:
        /// Required element 'hostName' of XSD type 'xsd:string'
        char *hostName;
        /// Required element 'ipAddress' of XSD type 'xsd:string'
        char *ipAddress;
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvPresentationV1RequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvPresentationV1RequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvPresentationV1RequestType, default initialized and not managed by a soap context
        virtual ns1__srvPresentationV1RequestType *soap_alloc(void) const { return SOAP_NEW(ns1__srvPresentationV1RequestType); }
      public:
        /// Constructor with initializations
        ns1__srvPresentationV1RequestType() : hostName(), ipAddress() { }
        virtual ~ns1__srvPresentationV1RequestType() { }
        /// Friend allocator used by soap_new_ns1__srvPresentationV1RequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvPresentationV1RequestType * SOAP_FMAC2 soap_instantiate_ns1__srvPresentationV1RequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:404 */
#ifndef SOAP_TYPE_ns1__srvConfigurationV1RequestType
#define SOAP_TYPE_ns1__srvConfigurationV1RequestType (84)
/* Type ns1__srvConfigurationV1RequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvConfigurationV1RequestType': */
class SOAP_CMAC ns1__srvConfigurationV1RequestType : public ns1__srvConfigurationBaseRequestType {
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvConfigurationV1RequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvConfigurationV1RequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvConfigurationV1RequestType, default initialized and not managed by a soap context
        virtual ns1__srvConfigurationV1RequestType *soap_alloc(void) const { return SOAP_NEW(ns1__srvConfigurationV1RequestType); }
      public:
        /// Constructor with initializations
        ns1__srvConfigurationV1RequestType() { }
        virtual ~ns1__srvConfigurationV1RequestType() { }
        /// Friend allocator used by soap_new_ns1__srvConfigurationV1RequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvConfigurationV1RequestType * SOAP_FMAC2 soap_instantiate_ns1__srvConfigurationV1RequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:410 */
#ifndef SOAP_TYPE_ns1__srvCommandV1RequestType
#define SOAP_TYPE_ns1__srvCommandV1RequestType (86)
/* Type ns1__srvCommandV1RequestType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvCommandV1RequestType': */
class SOAP_CMAC ns1__srvCommandV1RequestType : public ns1__srvCommandBaseRequestType {
      public:
        /// Required element 'commandId' of XSD type 'xsd:long'
        LONG64 commandId;
        /// Required element 'commandType' of XSD type 'xsd:int'
        int commandType;
        /// Optional element 'deviceCode' of XSD type 'xsd:long'
        LONG64 *deviceCode;
        /// Required element 'commandCode' of XSD type 'xsd:long'
        LONG64 commandCode;
        /// Optional element 'executionDate' of XSD type 'xsd:dateTime'
        time_t *executionDate;
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvCommandV1RequestType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvCommandV1RequestType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvCommandV1RequestType, default initialized and not managed by a soap context
        virtual ns1__srvCommandV1RequestType *soap_alloc(void) const { return SOAP_NEW(ns1__srvCommandV1RequestType); }
      public:
        /// Constructor with initializations
        ns1__srvCommandV1RequestType() : commandId(), commandType(), deviceCode(), commandCode(), executionDate() { }
        virtual ~ns1__srvCommandV1RequestType() { }
        /// Friend allocator used by soap_new_ns1__srvCommandV1RequestType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvCommandV1RequestType * SOAP_FMAC2 soap_instantiate_ns1__srvCommandV1RequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1094 */
#ifndef SOAP_TYPE_ns1__srvPresentationV1ResponseType
#define SOAP_TYPE_ns1__srvPresentationV1ResponseType (314)
/* Type ns1__srvPresentationV1ResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvPresentationV1ResponseType': */
class SOAP_CMAC ns1__srvPresentationV1ResponseType : public ns1__srvPresentationBaseResponseType {
      public:
        /// Required element 'result' of XSD type 'xsd:unsignedShort'
        unsigned short result;
        /// Optional element 'slavesResponse' of XSD type 'ns1:SlavePresentationResponseListType'
        ns1__SlavePresentationResponseListType *slavesResponse;
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvPresentationV1ResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvPresentationV1ResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvPresentationV1ResponseType, default initialized and not managed by a soap context
        virtual ns1__srvPresentationV1ResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__srvPresentationV1ResponseType); }
      public:
        /// Constructor with initializations
        ns1__srvPresentationV1ResponseType() : result(), slavesResponse() { }
        virtual ~ns1__srvPresentationV1ResponseType() { }
        /// Friend allocator used by soap_new_ns1__srvPresentationV1ResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvPresentationV1ResponseType * SOAP_FMAC2 soap_instantiate_ns1__srvPresentationV1ResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1109 */
#ifndef SOAP_TYPE_ns1__srvConfigurationV1ResponseType
#define SOAP_TYPE_ns1__srvConfigurationV1ResponseType (319)
/* Type ns1__srvConfigurationV1ResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvConfigurationV1ResponseType': */
class SOAP_CMAC ns1__srvConfigurationV1ResponseType : public ns1__srvConfigurationBaseResponseType {
      public:
        /// Required element 'packageList' of XSD type 'ns1:confPackageListType'
        ns1__confPackageListType *packageList;
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvConfigurationV1ResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvConfigurationV1ResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvConfigurationV1ResponseType, default initialized and not managed by a soap context
        virtual ns1__srvConfigurationV1ResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__srvConfigurationV1ResponseType); }
      public:
        /// Constructor with initializations
        ns1__srvConfigurationV1ResponseType() : packageList() { }
        virtual ~ns1__srvConfigurationV1ResponseType() { }
        /// Friend allocator used by soap_new_ns1__srvConfigurationV1ResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvConfigurationV1ResponseType * SOAP_FMAC2 soap_instantiate_ns1__srvConfigurationV1ResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:1127 */
#ifndef SOAP_TYPE_ns1__srvCommandV1ResponseType
#define SOAP_TYPE_ns1__srvCommandV1ResponseType (325)
/* Type ns1__srvCommandV1ResponseType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:srvCommandV1ResponseType': */
class SOAP_CMAC ns1__srvCommandV1ResponseType : public ns1__srvCommandBaseResponseType {
      public:
        /// Required element 'result' of XSD type 'xsd:int'
        int result;
      public:
        /// Return unique type id SOAP_TYPE_ns1__srvCommandV1ResponseType
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__srvCommandV1ResponseType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__srvCommandV1ResponseType, default initialized and not managed by a soap context
        virtual ns1__srvCommandV1ResponseType *soap_alloc(void) const { return SOAP_NEW(ns1__srvCommandV1ResponseType); }
      public:
        /// Constructor with initializations
        ns1__srvCommandV1ResponseType() : result() { }
        virtual ~ns1__srvCommandV1ResponseType() { }
        /// Friend allocator used by soap_new_ns1__srvCommandV1ResponseType(struct soap*, int)
        friend SOAP_FMAC1 ns1__srvCommandV1ResponseType * SOAP_FMAC2 soap_instantiate_ns1__srvCommandV1ResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:12597 */
#ifndef SOAP_TYPE___ns1__getProtoVersionList
#define SOAP_TYPE___ns1__getProtoVersionList (826)
/* Wrapper: */
struct SOAP_CMAC __ns1__getProtoVersionList {
      public:
        /** Optional element 'ns1:getProtoVersionList' of XSD type 'ns1:getProtoVersionList' */
        ns1__getProtoVersionList *ns1__getProtoVersionList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getProtoVersionList */
        int soap_type() const { return SOAP_TYPE___ns1__getProtoVersionList; }
        /** Constructor with member initializations */
        __ns1__getProtoVersionList() : ns1__getProtoVersionList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getProtoVersionList * SOAP_FMAC2 soap_instantiate___ns1__getProtoVersionList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:12664 */
#ifndef SOAP_TYPE___ns1__getVersionList
#define SOAP_TYPE___ns1__getVersionList (830)
/* Wrapper: */
struct SOAP_CMAC __ns1__getVersionList {
      public:
        /** Optional element 'ns1:getVersionList' of XSD type 'ns1:getVersionList' */
        ns1__getVersionList *ns1__getVersionList_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getVersionList */
        int soap_type() const { return SOAP_TYPE___ns1__getVersionList; }
        /** Constructor with member initializations */
        __ns1__getVersionList() : ns1__getVersionList_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getVersionList * SOAP_FMAC2 soap_instantiate___ns1__getVersionList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* sopa.h:12750 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (831)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* sopa.h:12750 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (832)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* sopa.h:12750 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (834)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* sopa.h:12750 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (837)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* sopa.h:12750 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (838)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* sopa.h:160 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (17)
typedef char *xsd__date;
#endif

/* sopa.h:205 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (27)
typedef char *xsd__integer;
#endif

/* sopa.h:215 */
#ifndef SOAP_TYPE_xsd__language
#define SOAP_TYPE_xsd__language (29)
typedef char *xsd__language;
#endif

/* sopa.h:232 */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (33)
typedef char *xsd__positiveInteger;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (40)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (32)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (24)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (22)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (11)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (41)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (10)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (38)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (20)
#endif

/* enum ns1__QuantityUnitsType has binding name 'ns1__QuantityUnitsType' for type 'ns1:QuantityUnitsType' */
#ifndef SOAP_TYPE_ns1__QuantityUnitsType
#define SOAP_TYPE_ns1__QuantityUnitsType (405)
#endif

/* enum ns1__AlarmCCTIUValueType has binding name 'ns1__AlarmCCTIUValueType' for type 'ns1:AlarmCCTIUValueType' */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUValueType
#define SOAP_TYPE_ns1__AlarmCCTIUValueType (403)
#endif

/* enum ns1__MTC_USCOREQuantityUnitsType has binding name 'ns1__MTC_USCOREQuantityUnitsType' for type 'ns1:MTC_QuantityUnitsType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType
#define SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType (401)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (16)
#endif

/* _ns1__eqList_eq has binding name '_ns1__eqList_eq' for type '' */
#ifndef SOAP_TYPE__ns1__eqList_eq
#define SOAP_TYPE__ns1__eqList_eq (674)
#endif

/* _ns1__AccountingUnitType_purse has binding name '_ns1__AccountingUnitType_purse' for type '' */
#ifndef SOAP_TYPE__ns1__AccountingUnitType_purse
#define SOAP_TYPE__ns1__AccountingUnitType_purse (534)
#endif

/* _ns1__AccountingUnitType_mda has binding name '_ns1__AccountingUnitType_mda' for type '' */
#ifndef SOAP_TYPE__ns1__AccountingUnitType_mda
#define SOAP_TYPE__ns1__AccountingUnitType_mda (532)
#endif

/* _ns1__AccountingUnitType_doc has binding name '_ns1__AccountingUnitType_doc' for type '' */
#ifndef SOAP_TYPE__ns1__AccountingUnitType_doc
#define SOAP_TYPE__ns1__AccountingUnitType_doc (531)
#endif

/* ns1__QuantityUnitsType_ has binding name 'ns1__QuantityUnitsType_' for type 'ns1:QuantityUnitsType' */
#ifndef SOAP_TYPE_ns1__QuantityUnitsType_
#define SOAP_TYPE_ns1__QuantityUnitsType_ (406)
#endif

/* ns1__AlarmCCTIUValueType_ has binding name 'ns1__AlarmCCTIUValueType_' for type 'ns1:AlarmCCTIUValueType' */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUValueType_
#define SOAP_TYPE_ns1__AlarmCCTIUValueType_ (404)
#endif

/* ns1__MTC_USCOREQuantityUnitsType_ has binding name 'ns1__MTC_USCOREQuantityUnitsType_' for type 'ns1:MTC_QuantityUnitsType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType_
#define SOAP_TYPE_ns1__MTC_USCOREQuantityUnitsType_ (402)
#endif

/* ns2__Distance has binding name 'ns2__Distance' for type 'ns2:Distance' */
#ifndef SOAP_TYPE_ns2__Distance
#define SOAP_TYPE_ns2__Distance (400)
#endif

/* ns2__DistanceList has binding name 'ns2__DistanceList' for type 'ns2:DistanceList' */
#ifndef SOAP_TYPE_ns2__DistanceList
#define SOAP_TYPE_ns2__DistanceList (399)
#endif

/* ns2__DistanceMatrixElement has binding name 'ns2__DistanceMatrixElement' for type 'ns2:DistanceMatrixElement' */
#ifndef SOAP_TYPE_ns2__DistanceMatrixElement
#define SOAP_TYPE_ns2__DistanceMatrixElement (398)
#endif

/* ns2__NameSet has binding name 'ns2__NameSet' for type 'ns2:NameSet' */
#ifndef SOAP_TYPE_ns2__NameSet
#define SOAP_TYPE_ns2__NameSet (397)
#endif

/* ns2__NameSetList has binding name 'ns2__NameSetList' for type 'ns2:NameSetList' */
#ifndef SOAP_TYPE_ns2__NameSetList
#define SOAP_TYPE_ns2__NameSetList (396)
#endif

/* ns2__Header has binding name 'ns2__Header' for type 'ns2:Header' */
#ifndef SOAP_TYPE_ns2__Header
#define SOAP_TYPE_ns2__Header (395)
#endif

/* ns2__ConfigurationDocument has binding name 'ns2__ConfigurationDocument' for type 'ns2:ConfigurationDocument' */
#ifndef SOAP_TYPE_ns2__ConfigurationDocument
#define SOAP_TYPE_ns2__ConfigurationDocument (394)
#endif

/* _ns1__protocol has binding name '_ns1__protocol' for type '' */
#ifndef SOAP_TYPE__ns1__protocol
#define SOAP_TYPE__ns1__protocol (393)
#endif

/* ns1__AccountingProductType has binding name 'ns1__AccountingProductType' for type 'ns1:AccountingProductType' */
#ifndef SOAP_TYPE_ns1__AccountingProductType
#define SOAP_TYPE_ns1__AccountingProductType (392)
#endif

/* ns1__SrvRecordNotificationListType has binding name 'ns1__SrvRecordNotificationListType' for type 'ns1:SrvRecordNotificationListType' */
#ifndef SOAP_TYPE_ns1__SrvRecordNotificationListType
#define SOAP_TYPE_ns1__SrvRecordNotificationListType (391)
#endif

/* ns1__SrvOrderNotificationType has binding name 'ns1__SrvOrderNotificationType' for type 'ns1:SrvOrderNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvOrderNotificationType
#define SOAP_TYPE_ns1__SrvOrderNotificationType (390)
#endif

/* ns1__SrvFileNotificationType has binding name 'ns1__SrvFileNotificationType' for type 'ns1:SrvFileNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvFileNotificationType
#define SOAP_TYPE_ns1__SrvFileNotificationType (389)
#endif

/* ns1__SrvNewConfigurationNotificationType has binding name 'ns1__SrvNewConfigurationNotificationType' for type 'ns1:SrvNewConfigurationNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvNewConfigurationNotificationType
#define SOAP_TYPE_ns1__SrvNewConfigurationNotificationType (388)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType has binding name 'ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType' for type 'ns1:SrvFE_MTC_StatusNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType (387)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType has binding name 'ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType' for type 'ns1:SrvFE_MTC_AlarmNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType (386)
#endif

/* ns1__SrvMTC_USCORECommandExecNotifyType has binding name 'ns1__SrvMTC_USCORECommandExecNotifyType' for type 'ns1:SrvMTC_CommandExecNotifyType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORECommandExecNotifyType
#define SOAP_TYPE_ns1__SrvMTC_USCORECommandExecNotifyType (385)
#endif

/* ns1__SrvMTC_USCOREStatusNotificationType has binding name 'ns1__SrvMTC_USCOREStatusNotificationType' for type 'ns1:SrvMTC_StatusNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREStatusNotificationType
#define SOAP_TYPE_ns1__SrvMTC_USCOREStatusNotificationType (384)
#endif

/* ns1__SrvMTC_USCOREAlarmNotificationType has binding name 'ns1__SrvMTC_USCOREAlarmNotificationType' for type 'ns1:SrvMTC_AlarmNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREAlarmNotificationType
#define SOAP_TYPE_ns1__SrvMTC_USCOREAlarmNotificationType (383)
#endif

/* ns1__SrvMtvmExtendedStateNotificationType has binding name 'ns1__SrvMtvmExtendedStateNotificationType' for type 'ns1:SrvMtvmExtendedStateNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvMtvmExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvMtvmExtendedStateNotificationType (382)
#endif

/* ns1__SrvExtendedStateNotificationType has binding name 'ns1__SrvExtendedStateNotificationType' for type 'ns1:SrvExtendedStateNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvExtendedStateNotificationType (381)
#endif

/* ns1__SrvTvmExtendedStateNotificationType has binding name 'ns1__SrvTvmExtendedStateNotificationType' for type 'ns1:SrvTvmExtendedStateNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvTvmExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvTvmExtendedStateNotificationType (380)
#endif

/* ns1__SrvStateSceqnNotificationType has binding name 'ns1__SrvStateSceqnNotificationType' for type 'ns1:SrvStateSceqnNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvStateSceqnNotificationType
#define SOAP_TYPE_ns1__SrvStateSceqnNotificationType (379)
#endif

/* ns1__stateConfigInstallationType has binding name 'ns1__stateConfigInstallationType' for type 'ns1:stateConfigInstallationType' */
#ifndef SOAP_TYPE_ns1__stateConfigInstallationType
#define SOAP_TYPE_ns1__stateConfigInstallationType (378)
#endif

/* ns1__StateConfigInstallationListType has binding name 'ns1__StateConfigInstallationListType' for type 'ns1:StateConfigInstallationListType' */
#ifndef SOAP_TYPE_ns1__StateConfigInstallationListType
#define SOAP_TYPE_ns1__StateConfigInstallationListType (377)
#endif

/* ns1__SrvStateConfigInstallationNotificationType has binding name 'ns1__SrvStateConfigInstallationNotificationType' for type 'ns1:SrvStateConfigInstallationNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvStateConfigInstallationNotificationType
#define SOAP_TYPE_ns1__SrvStateConfigInstallationNotificationType (376)
#endif

/* ns1__SrvVersionNotificationType has binding name 'ns1__SrvVersionNotificationType' for type 'ns1:SrvVersionNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvVersionNotificationType
#define SOAP_TYPE_ns1__SrvVersionNotificationType (375)
#endif

/* ns1__SrvDiagnosticNotificationType has binding name 'ns1__SrvDiagnosticNotificationType' for type 'ns1:SrvDiagnosticNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvDiagnosticNotificationType
#define SOAP_TYPE_ns1__SrvDiagnosticNotificationType (374)
#endif

/* ns1__SrvConfigurationNotificationType has binding name 'ns1__SrvConfigurationNotificationType' for type 'ns1:SrvConfigurationNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvConfigurationNotificationType
#define SOAP_TYPE_ns1__SrvConfigurationNotificationType (373)
#endif

/* ns1__SrvAlarmNotificationType has binding name 'ns1__SrvAlarmNotificationType' for type 'ns1:SrvAlarmNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvAlarmNotificationType
#define SOAP_TYPE_ns1__SrvAlarmNotificationType (372)
#endif

/* ns1__SrvStateNotificationType has binding name 'ns1__SrvStateNotificationType' for type 'ns1:SrvStateNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvStateNotificationType
#define SOAP_TYPE_ns1__SrvStateNotificationType (371)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType has binding name 'ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType' for type 'ns1:SrvFE_MTC_TransactionNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType (370)
#endif

/* ns1__SrvMTC_USCORETransactionNotificationType has binding name 'ns1__SrvMTC_USCORETransactionNotificationType' for type 'ns1:SrvMTC_TransactionNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionNotificationType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionNotificationType (369)
#endif

/* ns1__SrvRecordNotificationType has binding name 'ns1__SrvRecordNotificationType' for type 'ns1:SrvRecordNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvRecordNotificationType
#define SOAP_TYPE_ns1__SrvRecordNotificationType (368)
#endif

/* ns1__PatternServiceNotificationType has binding name 'ns1__PatternServiceNotificationType' for type 'ns1:PatternServiceNotificationType' */
#ifndef SOAP_TYPE_ns1__PatternServiceNotificationType
#define SOAP_TYPE_ns1__PatternServiceNotificationType (367)
#endif

/* ns1__SrvAgExtendedStateNotificationType has binding name 'ns1__SrvAgExtendedStateNotificationType' for type 'ns1:SrvAgExtendedStateNotificationType' */
#ifndef SOAP_TYPE_ns1__SrvAgExtendedStateNotificationType
#define SOAP_TYPE_ns1__SrvAgExtendedStateNotificationType (366)
#endif

/* ns1__SrvMtvmExtendedStateConfirmationType has binding name 'ns1__SrvMtvmExtendedStateConfirmationType' for type 'ns1:SrvMtvmExtendedStateConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvMtvmExtendedStateConfirmationType
#define SOAP_TYPE_ns1__SrvMtvmExtendedStateConfirmationType (365)
#endif

/* ns1__SrvTvmExtendedStateConfirmationType has binding name 'ns1__SrvTvmExtendedStateConfirmationType' for type 'ns1:SrvTvmExtendedStateConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvTvmExtendedStateConfirmationType
#define SOAP_TYPE_ns1__SrvTvmExtendedStateConfirmationType (364)
#endif

/* ns1__SrvOrderConfirmationType has binding name 'ns1__SrvOrderConfirmationType' for type 'ns1:SrvOrderConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvOrderConfirmationType
#define SOAP_TYPE_ns1__SrvOrderConfirmationType (363)
#endif

/* ns1__SrvFileConfirmationType has binding name 'ns1__SrvFileConfirmationType' for type 'ns1:SrvFileConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvFileConfirmationType
#define SOAP_TYPE_ns1__SrvFileConfirmationType (362)
#endif

/* ns1__SrvNewConfigurationConfirmationType has binding name 'ns1__SrvNewConfigurationConfirmationType' for type 'ns1:SrvNewConfigurationConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvNewConfigurationConfirmationType
#define SOAP_TYPE_ns1__SrvNewConfigurationConfirmationType (361)
#endif

/* ns1__SrvAlarmConfirmationType has binding name 'ns1__SrvAlarmConfirmationType' for type 'ns1:SrvAlarmConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvAlarmConfirmationType
#define SOAP_TYPE_ns1__SrvAlarmConfirmationType (360)
#endif

/* ns1__SrvStateConfirmationType has binding name 'ns1__SrvStateConfirmationType' for type 'ns1:SrvStateConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvStateConfirmationType
#define SOAP_TYPE_ns1__SrvStateConfirmationType (359)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType has binding name 'ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType' for type 'ns1:SrvFE_MTC_TransactionConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType (358)
#endif

/* ns1__RecordConfirmationType has binding name 'ns1__RecordConfirmationType' for type 'ns1:RecordConfirmationType' */
#ifndef SOAP_TYPE_ns1__RecordConfirmationType
#define SOAP_TYPE_ns1__RecordConfirmationType (357)
#endif

/* ns1__RecordConfirmationListType has binding name 'ns1__RecordConfirmationListType' for type 'ns1:RecordConfirmationListType' */
#ifndef SOAP_TYPE_ns1__RecordConfirmationListType
#define SOAP_TYPE_ns1__RecordConfirmationListType (356)
#endif

/* ns1__SrvRecordConfirmationType has binding name 'ns1__SrvRecordConfirmationType' for type 'ns1:SrvRecordConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvRecordConfirmationType
#define SOAP_TYPE_ns1__SrvRecordConfirmationType (355)
#endif

/* ns1__PatternServiceConfirmationType has binding name 'ns1__PatternServiceConfirmationType' for type 'ns1:PatternServiceConfirmationType' */
#ifndef SOAP_TYPE_ns1__PatternServiceConfirmationType
#define SOAP_TYPE_ns1__PatternServiceConfirmationType (354)
#endif

/* ns1__SrvMTC_USCORETransactionConfirmationType has binding name 'ns1__SrvMTC_USCORETransactionConfirmationType' for type 'ns1:SrvMTC_TransactionConfirmationType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionConfirmationType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionConfirmationType (353)
#endif

/* ns1__SceqExtStateTypeList has binding name 'ns1__SceqExtStateTypeList' for type 'ns1:SceqExtStateTypeList' */
#ifndef SOAP_TYPE_ns1__SceqExtStateTypeList
#define SOAP_TYPE_ns1__SceqExtStateTypeList (352)
#endif

/* ns1__AgExtStateType has binding name 'ns1__AgExtStateType' for type 'ns1:AgExtStateType' */
#ifndef SOAP_TYPE_ns1__AgExtStateType
#define SOAP_TYPE_ns1__AgExtStateType (351)
#endif

/* ns1__diagnosticType has binding name 'ns1__diagnosticType' for type 'ns1:diagnosticType' */
#ifndef SOAP_TYPE_ns1__diagnosticType
#define SOAP_TYPE_ns1__diagnosticType (350)
#endif

/* ns1__diagnosticListType has binding name 'ns1__diagnosticListType' for type 'ns1:diagnosticListType' */
#ifndef SOAP_TYPE_ns1__diagnosticListType
#define SOAP_TYPE_ns1__diagnosticListType (349)
#endif

/* ns1__versionType has binding name 'ns1__versionType' for type 'ns1:versionType' */
#ifndef SOAP_TYPE_ns1__versionType
#define SOAP_TYPE_ns1__versionType (348)
#endif

/* ns1__versionListType has binding name 'ns1__versionListType' for type 'ns1:versionListType' */
#ifndef SOAP_TYPE_ns1__versionListType
#define SOAP_TYPE_ns1__versionListType (347)
#endif

/* ns1__eqList has binding name 'ns1__eqList' for type 'ns1:eqList' */
#ifndef SOAP_TYPE_ns1__eqList
#define SOAP_TYPE_ns1__eqList (346)
#endif

/* ns1__SceqExtStateType has binding name 'ns1__SceqExtStateType' for type 'ns1:SceqExtStateType' */
#ifndef SOAP_TYPE_ns1__SceqExtStateType
#define SOAP_TYPE_ns1__SceqExtStateType (345)
#endif

/* ns1__boxType has binding name 'ns1__boxType' for type 'ns1:boxType' */
#ifndef SOAP_TYPE_ns1__boxType
#define SOAP_TYPE_ns1__boxType (344)
#endif

/* ns1__BoxListType has binding name 'ns1__BoxListType' for type 'ns1:BoxListType' */
#ifndef SOAP_TYPE_ns1__BoxListType
#define SOAP_TYPE_ns1__BoxListType (343)
#endif

/* ns1__TvmExtStateType has binding name 'ns1__TvmExtStateType' for type 'ns1:TvmExtStateType' */
#ifndef SOAP_TYPE_ns1__TvmExtStateType
#define SOAP_TYPE_ns1__TvmExtStateType (342)
#endif

/* ns1__QuantityType has binding name 'ns1__QuantityType' for type 'ns1:QuantityType' */
#ifndef SOAP_TYPE_ns1__QuantityType
#define SOAP_TYPE_ns1__QuantityType (341)
#endif

/* ns1__TransactionMTCConfTypeList has binding name 'ns1__TransactionMTCConfTypeList' for type 'ns1:TransactionMTCConfTypeList' */
#ifndef SOAP_TYPE_ns1__TransactionMTCConfTypeList
#define SOAP_TYPE_ns1__TransactionMTCConfTypeList (340)
#endif

/* ns1__TransactionMTCConfType has binding name 'ns1__TransactionMTCConfType' for type 'ns1:TransactionMTCConfType' */
#ifndef SOAP_TYPE_ns1__TransactionMTCConfType
#define SOAP_TYPE_ns1__TransactionMTCConfType (339)
#endif

/* ns1__CashInfo has binding name 'ns1__CashInfo' for type 'ns1:CashInfo' */
#ifndef SOAP_TYPE_ns1__CashInfo
#define SOAP_TYPE_ns1__CashInfo (338)
#endif

/* ns1__CashInfoList has binding name 'ns1__CashInfoList' for type 'ns1:CashInfoList' */
#ifndef SOAP_TYPE_ns1__CashInfoList
#define SOAP_TYPE_ns1__CashInfoList (337)
#endif

/* ns1__samDeviceType has binding name 'ns1__samDeviceType' for type 'ns1:samDeviceType' */
#ifndef SOAP_TYPE_ns1__samDeviceType
#define SOAP_TYPE_ns1__samDeviceType (336)
#endif

/* ns1__samDeviceTypeList has binding name 'ns1__samDeviceTypeList' for type 'ns1:samDeviceTypeList' */
#ifndef SOAP_TYPE_ns1__samDeviceTypeList
#define SOAP_TYPE_ns1__samDeviceTypeList (335)
#endif

/* ns1__Shift has binding name 'ns1__Shift' for type 'ns1:Shift' */
#ifndef SOAP_TYPE_ns1__Shift
#define SOAP_TYPE_ns1__Shift (334)
#endif

/* ns1__ShiftList has binding name 'ns1__ShiftList' for type 'ns1:ShiftList' */
#ifndef SOAP_TYPE_ns1__ShiftList
#define SOAP_TYPE_ns1__ShiftList (333)
#endif

/* ns1__DispenserStockType has binding name 'ns1__DispenserStockType' for type 'ns1:DispenserStockType' */
#ifndef SOAP_TYPE_ns1__DispenserStockType
#define SOAP_TYPE_ns1__DispenserStockType (332)
#endif

/* ns1__DispenserStockListType has binding name 'ns1__DispenserStockListType' for type 'ns1:DispenserStockListType' */
#ifndef SOAP_TYPE_ns1__DispenserStockListType
#define SOAP_TYPE_ns1__DispenserStockListType (331)
#endif

/* ns1__MediaDispenserType has binding name 'ns1__MediaDispenserType' for type 'ns1:MediaDispenserType' */
#ifndef SOAP_TYPE_ns1__MediaDispenserType
#define SOAP_TYPE_ns1__MediaDispenserType (330)
#endif

/* ns1__MediaDispenserListType has binding name 'ns1__MediaDispenserListType' for type 'ns1:MediaDispenserListType' */
#ifndef SOAP_TYPE_ns1__MediaDispenserListType
#define SOAP_TYPE_ns1__MediaDispenserListType (329)
#endif

/* ns1__ExtStateType has binding name 'ns1__ExtStateType' for type 'ns1:ExtStateType' */
#ifndef SOAP_TYPE_ns1__ExtStateType
#define SOAP_TYPE_ns1__ExtStateType (328)
#endif

/* ns1__MtvmExtStateType has binding name 'ns1__MtvmExtStateType' for type 'ns1:MtvmExtStateType' */
#ifndef SOAP_TYPE_ns1__MtvmExtStateType
#define SOAP_TYPE_ns1__MtvmExtStateType (327)
#endif

/* ns1__MTC_USCORERangeDateTimeType has binding name 'ns1__MTC_USCORERangeDateTimeType' for type 'ns1:MTC_RangeDateTimeType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORERangeDateTimeType
#define SOAP_TYPE_ns1__MTC_USCORERangeDateTimeType (326)
#endif

/* ns1__srvCommandV1ResponseType has binding name 'ns1__srvCommandV1ResponseType' for type 'ns1:srvCommandV1ResponseType' */
#ifndef SOAP_TYPE_ns1__srvCommandV1ResponseType
#define SOAP_TYPE_ns1__srvCommandV1ResponseType (325)
#endif

/* ns1__srvCommandBaseResponseType has binding name 'ns1__srvCommandBaseResponseType' for type 'ns1:srvCommandBaseResponseType' */
#ifndef SOAP_TYPE_ns1__srvCommandBaseResponseType
#define SOAP_TYPE_ns1__srvCommandBaseResponseType (324)
#endif

/* ns1__configFileType has binding name 'ns1__configFileType' for type 'ns1:configFileType' */
#ifndef SOAP_TYPE_ns1__configFileType
#define SOAP_TYPE_ns1__configFileType (323)
#endif

/* ns1__configFileListType has binding name 'ns1__configFileListType' for type 'ns1:configFileListType' */
#ifndef SOAP_TYPE_ns1__configFileListType
#define SOAP_TYPE_ns1__configFileListType (322)
#endif

/* ns1__packageType has binding name 'ns1__packageType' for type 'ns1:packageType' */
#ifndef SOAP_TYPE_ns1__packageType
#define SOAP_TYPE_ns1__packageType (321)
#endif

/* ns1__confPackageListType has binding name 'ns1__confPackageListType' for type 'ns1:confPackageListType' */
#ifndef SOAP_TYPE_ns1__confPackageListType
#define SOAP_TYPE_ns1__confPackageListType (320)
#endif

/* ns1__srvConfigurationV1ResponseType has binding name 'ns1__srvConfigurationV1ResponseType' for type 'ns1:srvConfigurationV1ResponseType' */
#ifndef SOAP_TYPE_ns1__srvConfigurationV1ResponseType
#define SOAP_TYPE_ns1__srvConfigurationV1ResponseType (319)
#endif

/* ns1__srvConfigurationBaseResponseType has binding name 'ns1__srvConfigurationBaseResponseType' for type 'ns1:srvConfigurationBaseResponseType' */
#ifndef SOAP_TYPE_ns1__srvConfigurationBaseResponseType
#define SOAP_TYPE_ns1__srvConfigurationBaseResponseType (318)
#endif

/* ns1__MonitoringTypeId has binding name 'ns1__MonitoringTypeId' for type 'ns1:MonitoringTypeId' */
#ifndef SOAP_TYPE_ns1__MonitoringTypeId
#define SOAP_TYPE_ns1__MonitoringTypeId (317)
#endif

/* ns1__SlavePresentationResponseType has binding name 'ns1__SlavePresentationResponseType' for type 'ns1:SlavePresentationResponseType' */
#ifndef SOAP_TYPE_ns1__SlavePresentationResponseType
#define SOAP_TYPE_ns1__SlavePresentationResponseType (316)
#endif

/* ns1__SlavePresentationResponseListType has binding name 'ns1__SlavePresentationResponseListType' for type 'ns1:SlavePresentationResponseListType' */
#ifndef SOAP_TYPE_ns1__SlavePresentationResponseListType
#define SOAP_TYPE_ns1__SlavePresentationResponseListType (315)
#endif

/* ns1__srvPresentationV1ResponseType has binding name 'ns1__srvPresentationV1ResponseType' for type 'ns1:srvPresentationV1ResponseType' */
#ifndef SOAP_TYPE_ns1__srvPresentationV1ResponseType
#define SOAP_TYPE_ns1__srvPresentationV1ResponseType (314)
#endif

/* ns1__srvPresentationBaseResponseType has binding name 'ns1__srvPresentationBaseResponseType' for type 'ns1:srvPresentationBaseResponseType' */
#ifndef SOAP_TYPE_ns1__srvPresentationBaseResponseType
#define SOAP_TYPE_ns1__srvPresentationBaseResponseType (313)
#endif

/* ns1__versionList has binding name 'ns1__versionList' for type 'ns1:versionList' */
#ifndef SOAP_TYPE_ns1__versionList
#define SOAP_TYPE_ns1__versionList (312)
#endif

/* ns1__SrvConfigurationContentResponseType has binding name 'ns1__SrvConfigurationContentResponseType' for type 'ns1:SrvConfigurationContentResponseType' */
#ifndef SOAP_TYPE_ns1__SrvConfigurationContentResponseType
#define SOAP_TYPE_ns1__SrvConfigurationContentResponseType (311)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREVersionResponseType has binding name 'ns1__SrvFE_USCOREMTC_USCOREVersionResponseType' for type 'ns1:SrvFE_MTC_VersionResponseType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionResponseType (310)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType has binding name 'ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType' for type 'ns1:SrvFE_MTC_DiagnosticResponseType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType (309)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREStatusResponseType has binding name 'ns1__SrvFE_USCOREMTC_USCOREStatusResponseType' for type 'ns1:SrvFE_MTC_StatusResponseType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusResponseType (308)
#endif

/* ns1__InfoFEMonitorCCTIUType has binding name 'ns1__InfoFEMonitorCCTIUType' for type 'ns1:InfoFEMonitorCCTIUType' */
#ifndef SOAP_TYPE_ns1__InfoFEMonitorCCTIUType
#define SOAP_TYPE_ns1__InfoFEMonitorCCTIUType (307)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType has binding name 'ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType' for type 'ns1:SrvFE_MTC_AlarmResponseType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType (306)
#endif

/* ns1__SrvMTC_USCORECommandExecResponseType has binding name 'ns1__SrvMTC_USCORECommandExecResponseType' for type 'ns1:SrvMTC_CommandExecResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORECommandExecResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCORECommandExecResponseType (305)
#endif

/* ns1__SrvMTC_USCOREConfigElementChangeResponseType has binding name 'ns1__SrvMTC_USCOREConfigElementChangeResponseType' for type 'ns1:SrvMTC_ConfigElementChangeResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeResponseType (304)
#endif

/* ns1__SrvMTC_USCOREConfigElementResponseType has binding name 'ns1__SrvMTC_USCOREConfigElementResponseType' for type 'ns1:SrvMTC_ConfigElementResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementResponseType (303)
#endif

/* ns1__VersionElementCfgType has binding name 'ns1__VersionElementCfgType' for type 'ns1:VersionElementCfgType' */
#ifndef SOAP_TYPE_ns1__VersionElementCfgType
#define SOAP_TYPE_ns1__VersionElementCfgType (302)
#endif

/* ns1__VersionElementCfgListType has binding name 'ns1__VersionElementCfgListType' for type 'ns1:VersionElementCfgListType' */
#ifndef SOAP_TYPE_ns1__VersionElementCfgListType
#define SOAP_TYPE_ns1__VersionElementCfgListType (301)
#endif

/* ns1__VersionCfgType has binding name 'ns1__VersionCfgType' for type 'ns1:VersionCfgType' */
#ifndef SOAP_TYPE_ns1__VersionCfgType
#define SOAP_TYPE_ns1__VersionCfgType (300)
#endif

/* ns1__VersionCfgListType has binding name 'ns1__VersionCfgListType' for type 'ns1:VersionCfgListType' */
#ifndef SOAP_TYPE_ns1__VersionCfgListType
#define SOAP_TYPE_ns1__VersionCfgListType (299)
#endif

/* ns1__VersionFW_USCOREHWType has binding name 'ns1__VersionFW_USCOREHWType' for type 'ns1:VersionFW_HWType' */
#ifndef SOAP_TYPE_ns1__VersionFW_USCOREHWType
#define SOAP_TYPE_ns1__VersionFW_USCOREHWType (298)
#endif

/* ns1__VersionFW_USCOREHWListType has binding name 'ns1__VersionFW_USCOREHWListType' for type 'ns1:VersionFW_HWListType' */
#ifndef SOAP_TYPE_ns1__VersionFW_USCOREHWListType
#define SOAP_TYPE_ns1__VersionFW_USCOREHWListType (297)
#endif

/* ns1__VersionsCCTIUType has binding name 'ns1__VersionsCCTIUType' for type 'ns1:VersionsCCTIUType' */
#ifndef SOAP_TYPE_ns1__VersionsCCTIUType
#define SOAP_TYPE_ns1__VersionsCCTIUType (296)
#endif

/* ns1__SrvMTC_USCOREVersionResponseType has binding name 'ns1__SrvMTC_USCOREVersionResponseType' for type 'ns1:SrvMTC_VersionResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREVersionResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREVersionResponseType (295)
#endif

/* ns1__DiagnosticCCTIUType has binding name 'ns1__DiagnosticCCTIUType' for type 'ns1:DiagnosticCCTIUType' */
#ifndef SOAP_TYPE_ns1__DiagnosticCCTIUType
#define SOAP_TYPE_ns1__DiagnosticCCTIUType (294)
#endif

/* ns1__DiagnosticCCTIUListType has binding name 'ns1__DiagnosticCCTIUListType' for type 'ns1:DiagnosticCCTIUListType' */
#ifndef SOAP_TYPE_ns1__DiagnosticCCTIUListType
#define SOAP_TYPE_ns1__DiagnosticCCTIUListType (293)
#endif

/* ns1__SrvMTC_USCOREDiagnosticResponseType has binding name 'ns1__SrvMTC_USCOREDiagnosticResponseType' for type 'ns1:SrvMTC_DiagnosticResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticResponseType (292)
#endif

/* ns1__StatusCCTIUType has binding name 'ns1__StatusCCTIUType' for type 'ns1:StatusCCTIUType' */
#ifndef SOAP_TYPE_ns1__StatusCCTIUType
#define SOAP_TYPE_ns1__StatusCCTIUType (291)
#endif

/* ns1__StatusCCTIUListType has binding name 'ns1__StatusCCTIUListType' for type 'ns1:StatusCCTIUListType' */
#ifndef SOAP_TYPE_ns1__StatusCCTIUListType
#define SOAP_TYPE_ns1__StatusCCTIUListType (290)
#endif

/* ns1__SrvMTC_USCOREStatusResponseType has binding name 'ns1__SrvMTC_USCOREStatusResponseType' for type 'ns1:SrvMTC_StatusResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREStatusResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREStatusResponseType (289)
#endif

/* ns1__AlarmCCTIUType has binding name 'ns1__AlarmCCTIUType' for type 'ns1:AlarmCCTIUType' */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUType
#define SOAP_TYPE_ns1__AlarmCCTIUType (288)
#endif

/* ns1__AlarmCCTIUListType has binding name 'ns1__AlarmCCTIUListType' for type 'ns1:AlarmCCTIUListType' */
#ifndef SOAP_TYPE_ns1__AlarmCCTIUListType
#define SOAP_TYPE_ns1__AlarmCCTIUListType (287)
#endif

/* ns1__SrvMTC_USCOREAlarmResponseType has binding name 'ns1__SrvMTC_USCOREAlarmResponseType' for type 'ns1:SrvMTC_AlarmResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREAlarmResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCOREAlarmResponseType (286)
#endif

/* ns1__SlaveStateListType has binding name 'ns1__SlaveStateListType' for type 'ns1:SlaveStateListType' */
#ifndef SOAP_TYPE_ns1__SlaveStateListType
#define SOAP_TYPE_ns1__SlaveStateListType (285)
#endif

/* ns1__SlaveStateType has binding name 'ns1__SlaveStateType' for type 'ns1:SlaveStateType' */
#ifndef SOAP_TYPE_ns1__SlaveStateType
#define SOAP_TYPE_ns1__SlaveStateType (284)
#endif

/* ns1__AlarmType has binding name 'ns1__AlarmType' for type 'ns1:AlarmType' */
#ifndef SOAP_TYPE_ns1__AlarmType
#define SOAP_TYPE_ns1__AlarmType (283)
#endif

/* ns1__AlarmListType has binding name 'ns1__AlarmListType' for type 'ns1:AlarmListType' */
#ifndef SOAP_TYPE_ns1__AlarmListType
#define SOAP_TYPE_ns1__AlarmListType (282)
#endif

/* ns1__MeasureType has binding name 'ns1__MeasureType' for type 'ns1:MeasureType' */
#ifndef SOAP_TYPE_ns1__MeasureType
#define SOAP_TYPE_ns1__MeasureType (281)
#endif

/* ns1__MeasureListType has binding name 'ns1__MeasureListType' for type 'ns1:MeasureListType' */
#ifndef SOAP_TYPE_ns1__MeasureListType
#define SOAP_TYPE_ns1__MeasureListType (280)
#endif

/* ns1__DeviceType has binding name 'ns1__DeviceType' for type 'ns1:DeviceType' */
#ifndef SOAP_TYPE_ns1__DeviceType
#define SOAP_TYPE_ns1__DeviceType (279)
#endif

/* ns1__DeviceListType has binding name 'ns1__DeviceListType' for type 'ns1:DeviceListType' */
#ifndef SOAP_TYPE_ns1__DeviceListType
#define SOAP_TYPE_ns1__DeviceListType (278)
#endif

/* ns1__stateType has binding name 'ns1__stateType' for type 'ns1:stateType' */
#ifndef SOAP_TYPE_ns1__stateType
#define SOAP_TYPE_ns1__stateType (277)
#endif

/* ns1__SrvStateResponseType has binding name 'ns1__SrvStateResponseType' for type 'ns1:SrvStateResponseType' */
#ifndef SOAP_TYPE_ns1__SrvStateResponseType
#define SOAP_TYPE_ns1__SrvStateResponseType (276)
#endif

/* ns1__InfoFERecordMTCType has binding name 'ns1__InfoFERecordMTCType' for type 'ns1:InfoFERecordMTCType' */
#ifndef SOAP_TYPE_ns1__InfoFERecordMTCType
#define SOAP_TYPE_ns1__InfoFERecordMTCType (275)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionResponseType has binding name 'ns1__SrvFE_USCOREMTC_USCORETransactionResponseType' for type 'ns1:SrvFE_MTC_TransactionResponseType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionResponseType (274)
#endif

/* ns1__SignedTransactionMTCRegType has binding name 'ns1__SignedTransactionMTCRegType' for type 'ns1:SignedTransactionMTCRegType' */
#ifndef SOAP_TYPE_ns1__SignedTransactionMTCRegType
#define SOAP_TYPE_ns1__SignedTransactionMTCRegType (273)
#endif

/* ns1__MTC_USCOREActionExecutedContentType has binding name 'ns1__MTC_USCOREActionExecutedContentType' for type 'ns1:MTC_ActionExecutedContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREActionExecutedContentType
#define SOAP_TYPE_ns1__MTC_USCOREActionExecutedContentType (272)
#endif

/* ns1__MTC_USCORERestitutionTitleContentType has binding name 'ns1__MTC_USCORERestitutionTitleContentType' for type 'ns1:MTC_RestitutionTitleContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORERestitutionTitleContentType
#define SOAP_TYPE_ns1__MTC_USCORERestitutionTitleContentType (271)
#endif

/* ns1__MTC_USCOREEditTitleContentType has binding name 'ns1__MTC_USCOREEditTitleContentType' for type 'ns1:MTC_EditTitleContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEditTitleContentType
#define SOAP_TYPE_ns1__MTC_USCOREEditTitleContentType (270)
#endif

/* ns1__MTC_USCORETMobilitatCurveType has binding name 'ns1__MTC_USCORETMobilitatCurveType' for type 'ns1:MTC_TMobilitatCurveType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORETMobilitatCurveType
#define SOAP_TYPE_ns1__MTC_USCORETMobilitatCurveType (269)
#endif

/* ns1__MTC_USCOREValidationTitleContentType has binding name 'ns1__MTC_USCOREValidationTitleContentType' for type 'ns1:MTC_ValidationTitleContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREValidationTitleContentType
#define SOAP_TYPE_ns1__MTC_USCOREValidationTitleContentType (268)
#endif

/* ns1__MTC_USCORERechargeTitleContentType has binding name 'ns1__MTC_USCORERechargeTitleContentType' for type 'ns1:MTC_RechargeTitleContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORERechargeTitleContentType
#define SOAP_TYPE_ns1__MTC_USCORERechargeTitleContentType (267)
#endif

/* ns1__MTC_USCOREQuantityType has binding name 'ns1__MTC_USCOREQuantityType' for type 'ns1:MTC_QuantityType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREQuantityType
#define SOAP_TYPE_ns1__MTC_USCOREQuantityType (266)
#endif

/* ns1__MTC_USCORETitleLoadContainerInfoType has binding name 'ns1__MTC_USCORETitleLoadContainerInfoType' for type 'ns1:MTC_TitleLoadContainerInfoType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoType
#define SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoType (265)
#endif

/* ns1__MTC_USCORETitleLoadContainerInfoListType has binding name 'ns1__MTC_USCORETitleLoadContainerInfoListType' for type 'ns1:MTC_TitleLoadContainerInfoListType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoListType
#define SOAP_TYPE_ns1__MTC_USCORETitleLoadContainerInfoListType (264)
#endif

/* ns1__MTC_USCORETitleInfoType has binding name 'ns1__MTC_USCORETitleInfoType' for type 'ns1:MTC_TitleInfoType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORETitleInfoType
#define SOAP_TYPE_ns1__MTC_USCORETitleInfoType (263)
#endif

/* ns1__ProductIdType has binding name 'ns1__ProductIdType' for type 'ns1:ProductIdType' */
#ifndef SOAP_TYPE_ns1__ProductIdType
#define SOAP_TYPE_ns1__ProductIdType (262)
#endif

/* ns1__MTC_USCOREInstanceTitleContentType has binding name 'ns1__MTC_USCOREInstanceTitleContentType' for type 'ns1:MTC_InstanceTitleContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInstanceTitleContentType
#define SOAP_TYPE_ns1__MTC_USCOREInstanceTitleContentType (261)
#endif

/* ns1__MTC_USCOREDeleteProfileContentType has binding name 'ns1__MTC_USCOREDeleteProfileContentType' for type 'ns1:MTC_DeleteProfileContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREDeleteProfileContentType
#define SOAP_TYPE_ns1__MTC_USCOREDeleteProfileContentType (260)
#endif

/* ns1__MTC_USCOREEditProfileContentType has binding name 'ns1__MTC_USCOREEditProfileContentType' for type 'ns1:MTC_EditProfileContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEditProfileContentType
#define SOAP_TYPE_ns1__MTC_USCOREEditProfileContentType (259)
#endif

/* ns1__MTC_USCOREProfileInfoType has binding name 'ns1__MTC_USCOREProfileInfoType' for type 'ns1:MTC_ProfileInfoType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREProfileInfoType
#define SOAP_TYPE_ns1__MTC_USCOREProfileInfoType (258)
#endif

/* ns1__MTC_USCOREInstanceProfileContentType has binding name 'ns1__MTC_USCOREInstanceProfileContentType' for type 'ns1:MTC_InstanceProfileContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInstanceProfileContentType
#define SOAP_TYPE_ns1__MTC_USCOREInstanceProfileContentType (257)
#endif

/* ns1__MTC_USCOREEditAppContentType has binding name 'ns1__MTC_USCOREEditAppContentType' for type 'ns1:MTC_EditAppContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEditAppContentType
#define SOAP_TYPE_ns1__MTC_USCOREEditAppContentType (256)
#endif

/* ns1__ActionIdType has binding name 'ns1__ActionIdType' for type 'ns1:ActionIdType' */
#ifndef SOAP_TYPE_ns1__ActionIdType
#define SOAP_TYPE_ns1__ActionIdType (255)
#endif

/* ns1__MTC_USCORERangeDateType has binding name 'ns1__MTC_USCORERangeDateType' for type 'ns1:MTC_RangeDateType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORERangeDateType
#define SOAP_TYPE_ns1__MTC_USCORERangeDateType (254)
#endif

/* ns1__MTC_USCOREApplicationInfoType has binding name 'ns1__MTC_USCOREApplicationInfoType' for type 'ns1:MTC_ApplicationInfoType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREApplicationInfoType
#define SOAP_TYPE_ns1__MTC_USCOREApplicationInfoType (253)
#endif

/* ns1__MTC_USCOREInstanceAppContentType has binding name 'ns1__MTC_USCOREInstanceAppContentType' for type 'ns1:MTC_InstanceAppContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInstanceAppContentType
#define SOAP_TYPE_ns1__MTC_USCOREInstanceAppContentType (252)
#endif

/* ns1__MTC_USCOREInitializationSusContentType has binding name 'ns1__MTC_USCOREInitializationSusContentType' for type 'ns1:MTC_InitializationSusContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREInitializationSusContentType
#define SOAP_TYPE_ns1__MTC_USCOREInitializationSusContentType (251)
#endif

/* ns1__MTC_USCORELogValueType has binding name 'ns1__MTC_USCORELogValueType' for type 'ns1:MTC_LogValueType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORELogValueType
#define SOAP_TYPE_ns1__MTC_USCORELogValueType (250)
#endif

/* ns1__MTC_USCOREEquipmentInfoType has binding name 'ns1__MTC_USCOREEquipmentInfoType' for type 'ns1:MTC_EquipmentInfoType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREEquipmentInfoType
#define SOAP_TYPE_ns1__MTC_USCOREEquipmentInfoType (249)
#endif

/* ns1__MTC_USCOREConfigVersionType has binding name 'ns1__MTC_USCOREConfigVersionType' for type 'ns1:MTC_ConfigVersionType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREConfigVersionType
#define SOAP_TYPE_ns1__MTC_USCOREConfigVersionType (248)
#endif

/* ns1__MTC_USCOREConfigVersionTypeList has binding name 'ns1__MTC_USCOREConfigVersionTypeList' for type 'ns1:MTC_ConfigVersionTypeList' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREConfigVersionTypeList
#define SOAP_TYPE_ns1__MTC_USCOREConfigVersionTypeList (247)
#endif

/* ns1__MTC_USCOREOtherPoint has binding name 'ns1__MTC_USCOREOtherPoint' for type 'ns1:MTC_OtherPoint' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOtherPoint
#define SOAP_TYPE_ns1__MTC_USCOREOtherPoint (246)
#endif

/* ns1__MTC_USCOREOnBoardSellPointType has binding name 'ns1__MTC_USCOREOnBoardSellPointType' for type 'ns1:MTC_OnBoardSellPointType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnBoardSellPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnBoardSellPointType (245)
#endif

/* ns1__MTC_USCOREOnStationSellPointType has binding name 'ns1__MTC_USCOREOnStationSellPointType' for type 'ns1:MTC_OnStationSellPointType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnStationSellPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnStationSellPointType (244)
#endif

/* ns1__MTC_USCOREOnBoardAccessPointType has binding name 'ns1__MTC_USCOREOnBoardAccessPointType' for type 'ns1:MTC_OnBoardAccessPointType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnBoardAccessPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnBoardAccessPointType (243)
#endif

/* ns1__MTC_USCOREOnStationAccessPointType has binding name 'ns1__MTC_USCOREOnStationAccessPointType' for type 'ns1:MTC_OnStationAccessPointType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREOnStationAccessPointType
#define SOAP_TYPE_ns1__MTC_USCOREOnStationAccessPointType (242)
#endif

/* ns1__MTC_USCORENetworkLocationType has binding name 'ns1__MTC_USCORENetworkLocationType' for type 'ns1:MTC_NetworkLocationType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORENetworkLocationType
#define SOAP_TYPE_ns1__MTC_USCORENetworkLocationType (241)
#endif

/* ns1__MTC_USCORELocationType has binding name 'ns1__MTC_USCORELocationType' for type 'ns1:MTC_LocationType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORELocationType
#define SOAP_TYPE_ns1__MTC_USCORELocationType (240)
#endif

/* ns1__MTC_USCOREBaseTransactionType has binding name 'ns1__MTC_USCOREBaseTransactionType' for type 'ns1:MTC_BaseTransactionType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREBaseTransactionType
#define SOAP_TYPE_ns1__MTC_USCOREBaseTransactionType (239)
#endif

/* ns1__MTC_USCOREFabricationSusContentType has binding name 'ns1__MTC_USCOREFabricationSusContentType' for type 'ns1:MTC_FabricationSusContentType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREFabricationSusContentType
#define SOAP_TYPE_ns1__MTC_USCOREFabricationSusContentType (238)
#endif

/* ns1__MTC_USCOREUnsignedTransactionRegType has binding name 'ns1__MTC_USCOREUnsignedTransactionRegType' for type 'ns1:MTC_UnsignedTransactionRegType' */
#ifndef SOAP_TYPE_ns1__MTC_USCOREUnsignedTransactionRegType
#define SOAP_TYPE_ns1__MTC_USCOREUnsignedTransactionRegType (237)
#endif

/* ns1__TransactionMTCRegType has binding name 'ns1__TransactionMTCRegType' for type 'ns1:TransactionMTCRegType' */
#ifndef SOAP_TYPE_ns1__TransactionMTCRegType
#define SOAP_TYPE_ns1__TransactionMTCRegType (236)
#endif

/* ns1__TransactionMTCRegTypeList has binding name 'ns1__TransactionMTCRegTypeList' for type 'ns1:TransactionMTCRegTypeList' */
#ifndef SOAP_TYPE_ns1__TransactionMTCRegTypeList
#define SOAP_TYPE_ns1__TransactionMTCRegTypeList (235)
#endif

/* ns1__SrvMTC_USCORETransactionResponseType has binding name 'ns1__SrvMTC_USCORETransactionResponseType' for type 'ns1:SrvMTC_TransactionResponseType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionResponseType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionResponseType (234)
#endif

/* ns1__SignedRecordType has binding name 'ns1__SignedRecordType' for type 'ns1:SignedRecordType' */
#ifndef SOAP_TYPE_ns1__SignedRecordType
#define SOAP_TYPE_ns1__SignedRecordType (233)
#endif

/* ns1__SamQuotaUpdateRecordType has binding name 'ns1__SamQuotaUpdateRecordType' for type 'ns1:SamQuotaUpdateRecordType' */
#ifndef SOAP_TYPE_ns1__SamQuotaUpdateRecordType
#define SOAP_TYPE_ns1__SamQuotaUpdateRecordType (232)
#endif

/* ns1__Vehicle has binding name 'ns1__Vehicle' for type 'ns1:Vehicle' */
#ifndef SOAP_TYPE_ns1__Vehicle
#define SOAP_TYPE_ns1__Vehicle (231)
#endif

/* ns1__ParkingValidationInfo has binding name 'ns1__ParkingValidationInfo' for type 'ns1:ParkingValidationInfo' */
#ifndef SOAP_TYPE_ns1__ParkingValidationInfo
#define SOAP_TYPE_ns1__ParkingValidationInfo (230)
#endif

/* ns1__ParkingValidationRecord has binding name 'ns1__ParkingValidationRecord' for type 'ns1:ParkingValidationRecord' */
#ifndef SOAP_TYPE_ns1__ParkingValidationRecord
#define SOAP_TYPE_ns1__ParkingValidationRecord (229)
#endif

/* ns1__IncidenceRecordType has binding name 'ns1__IncidenceRecordType' for type 'ns1:IncidenceRecordType' */
#ifndef SOAP_TYPE_ns1__IncidenceRecordType
#define SOAP_TYPE_ns1__IncidenceRecordType (228)
#endif

/* ns1__EndTripRecordType has binding name 'ns1__EndTripRecordType' for type 'ns1:EndTripRecordType' */
#ifndef SOAP_TYPE_ns1__EndTripRecordType
#define SOAP_TYPE_ns1__EndTripRecordType (227)
#endif

/* ns1__StartTripRecordType has binding name 'ns1__StartTripRecordType' for type 'ns1:StartTripRecordType' */
#ifndef SOAP_TYPE_ns1__StartTripRecordType
#define SOAP_TYPE_ns1__StartTripRecordType (226)
#endif

/* ns1__StationModeChangeRecordType has binding name 'ns1__StationModeChangeRecordType' for type 'ns1:StationModeChangeRecordType' */
#ifndef SOAP_TYPE_ns1__StationModeChangeRecordType
#define SOAP_TYPE_ns1__StationModeChangeRecordType (225)
#endif

/* ns1__MaintenanceAccessRecordType has binding name 'ns1__MaintenanceAccessRecordType' for type 'ns1:MaintenanceAccessRecordType' */
#ifndef SOAP_TYPE_ns1__MaintenanceAccessRecordType
#define SOAP_TYPE_ns1__MaintenanceAccessRecordType (224)
#endif

/* ns1__LoginFailureRecordType has binding name 'ns1__LoginFailureRecordType' for type 'ns1:LoginFailureRecordType' */
#ifndef SOAP_TYPE_ns1__LoginFailureRecordType
#define SOAP_TYPE_ns1__LoginFailureRecordType (223)
#endif

/* ns1__LocationChangeRecordType has binding name 'ns1__LocationChangeRecordType' for type 'ns1:LocationChangeRecordType' */
#ifndef SOAP_TYPE_ns1__LocationChangeRecordType
#define SOAP_TYPE_ns1__LocationChangeRecordType (222)
#endif

/* ns1__CsmInitializationRecordType has binding name 'ns1__CsmInitializationRecordType' for type 'ns1:CsmInitializationRecordType' */
#ifndef SOAP_TYPE_ns1__CsmInitializationRecordType
#define SOAP_TYPE_ns1__CsmInitializationRecordType (221)
#endif

/* ns1__CsmUnblockingRecordType has binding name 'ns1__CsmUnblockingRecordType' for type 'ns1:CsmUnblockingRecordType' */
#ifndef SOAP_TYPE_ns1__CsmUnblockingRecordType
#define SOAP_TYPE_ns1__CsmUnblockingRecordType (220)
#endif

/* ns1__CsmBlockingRecordType has binding name 'ns1__CsmBlockingRecordType' for type 'ns1:CsmBlockingRecordType' */
#ifndef SOAP_TYPE_ns1__CsmBlockingRecordType
#define SOAP_TYPE_ns1__CsmBlockingRecordType (219)
#endif

/* ns1__CommandReportRecordType has binding name 'ns1__CommandReportRecordType' for type 'ns1:CommandReportRecordType' */
#ifndef SOAP_TYPE_ns1__CommandReportRecordType
#define SOAP_TYPE_ns1__CommandReportRecordType (218)
#endif

/* ns1__ActionType has binding name 'ns1__ActionType' for type 'ns1:ActionType' */
#ifndef SOAP_TYPE_ns1__ActionType
#define SOAP_TYPE_ns1__ActionType (217)
#endif

/* ns1__ActionListType has binding name 'ns1__ActionListType' for type 'ns1:ActionListType' */
#ifndef SOAP_TYPE_ns1__ActionListType
#define SOAP_TYPE_ns1__ActionListType (216)
#endif

/* ns1__ActionListRecordType has binding name 'ns1__ActionListRecordType' for type 'ns1:ActionListRecordType' */
#ifndef SOAP_TYPE_ns1__ActionListRecordType
#define SOAP_TYPE_ns1__ActionListRecordType (215)
#endif

/* ns1__OpenWideAisleGateRecordType has binding name 'ns1__OpenWideAisleGateRecordType' for type 'ns1:OpenWideAisleGateRecordType' */
#ifndef SOAP_TYPE_ns1__OpenWideAisleGateRecordType
#define SOAP_TYPE_ns1__OpenWideAisleGateRecordType (214)
#endif

/* ns1__OpenGatePsmRecordType has binding name 'ns1__OpenGatePsmRecordType' for type 'ns1:OpenGatePsmRecordType' */
#ifndef SOAP_TYPE_ns1__OpenGatePsmRecordType
#define SOAP_TYPE_ns1__OpenGatePsmRecordType (213)
#endif

/* ns1__AdvancedPurchaseRecordType has binding name 'ns1__AdvancedPurchaseRecordType' for type 'ns1:AdvancedPurchaseRecordType' */
#ifndef SOAP_TYPE_ns1__AdvancedPurchaseRecordType
#define SOAP_TYPE_ns1__AdvancedPurchaseRecordType (212)
#endif

/* ns1__MaintenanceOperationRecordType has binding name 'ns1__MaintenanceOperationRecordType' for type 'ns1:MaintenanceOperationRecordType' */
#ifndef SOAP_TYPE_ns1__MaintenanceOperationRecordType
#define SOAP_TYPE_ns1__MaintenanceOperationRecordType (211)
#endif

/* ns1__PenaltyType has binding name 'ns1__PenaltyType' for type 'ns1:PenaltyType' */
#ifndef SOAP_TYPE_ns1__PenaltyType
#define SOAP_TYPE_ns1__PenaltyType (210)
#endif

/* ns1__GateRejectionAnalysisRecordType has binding name 'ns1__GateRejectionAnalysisRecordType' for type 'ns1:GateRejectionAnalysisRecordType' */
#ifndef SOAP_TYPE_ns1__GateRejectionAnalysisRecordType
#define SOAP_TYPE_ns1__GateRejectionAnalysisRecordType (209)
#endif

/* ns1__PendingPaymentBalanceType has binding name 'ns1__PendingPaymentBalanceType' for type 'ns1:PendingPaymentBalanceType' */
#ifndef SOAP_TYPE_ns1__PendingPaymentBalanceType
#define SOAP_TYPE_ns1__PendingPaymentBalanceType (208)
#endif

/* ns1__PendingPaymentType has binding name 'ns1__PendingPaymentType' for type 'ns1:PendingPaymentType' */
#ifndef SOAP_TYPE_ns1__PendingPaymentType
#define SOAP_TYPE_ns1__PendingPaymentType (207)
#endif

/* ns1__FareMediumType has binding name 'ns1__FareMediumType' for type 'ns1:FareMediumType' */
#ifndef SOAP_TYPE_ns1__FareMediumType
#define SOAP_TYPE_ns1__FareMediumType (206)
#endif

/* ns1__Penalty has binding name 'ns1__Penalty' for type 'ns1:Penalty' */
#ifndef SOAP_TYPE_ns1__Penalty
#define SOAP_TYPE_ns1__Penalty (205)
#endif

/* ns1__PenaltyRecordType has binding name 'ns1__PenaltyRecordType' for type 'ns1:PenaltyRecordType' */
#ifndef SOAP_TYPE_ns1__PenaltyRecordType
#define SOAP_TYPE_ns1__PenaltyRecordType (204)
#endif

/* ns1__InternalCoinFlowRecordType has binding name 'ns1__InternalCoinFlowRecordType' for type 'ns1:InternalCoinFlowRecordType' */
#ifndef SOAP_TYPE_ns1__InternalCoinFlowRecordType
#define SOAP_TYPE_ns1__InternalCoinFlowRecordType (203)
#endif

/* ns1__CoinNoteRefillAdjustmentRecordType has binding name 'ns1__CoinNoteRefillAdjustmentRecordType' for type 'ns1:CoinNoteRefillAdjustmentRecordType' */
#ifndef SOAP_TYPE_ns1__CoinNoteRefillAdjustmentRecordType
#define SOAP_TYPE_ns1__CoinNoteRefillAdjustmentRecordType (202)
#endif

/* ns1__CoinNoteRefillRecordType has binding name 'ns1__CoinNoteRefillRecordType' for type 'ns1:CoinNoteRefillRecordType' */
#ifndef SOAP_TYPE_ns1__CoinNoteRefillRecordType
#define SOAP_TYPE_ns1__CoinNoteRefillRecordType (201)
#endif

/* ns1__MediaStockAdjustRecordType has binding name 'ns1__MediaStockAdjustRecordType' for type 'ns1:MediaStockAdjustRecordType' */
#ifndef SOAP_TYPE_ns1__MediaStockAdjustRecordType
#define SOAP_TYPE_ns1__MediaStockAdjustRecordType (200)
#endif

/* ns1__mediaStockType has binding name 'ns1__mediaStockType' for type 'ns1:mediaStockType' */
#ifndef SOAP_TYPE_ns1__mediaStockType
#define SOAP_TYPE_ns1__mediaStockType (199)
#endif

/* ns1__MediaStockListType has binding name 'ns1__MediaStockListType' for type 'ns1:MediaStockListType' */
#ifndef SOAP_TYPE_ns1__MediaStockListType
#define SOAP_TYPE_ns1__MediaStockListType (198)
#endif

/* ns1__MediaStockUpdateRecordType has binding name 'ns1__MediaStockUpdateRecordType' for type 'ns1:MediaStockUpdateRecordType' */
#ifndef SOAP_TYPE_ns1__MediaStockUpdateRecordType
#define SOAP_TYPE_ns1__MediaStockUpdateRecordType (197)
#endif

/* ns1__CoinsAndNotesCollectionRecordType has binding name 'ns1__CoinsAndNotesCollectionRecordType' for type 'ns1:CoinsAndNotesCollectionRecordType' */
#ifndef SOAP_TYPE_ns1__CoinsAndNotesCollectionRecordType
#define SOAP_TYPE_ns1__CoinsAndNotesCollectionRecordType (196)
#endif

/* ns1__CollectionRecordType has binding name 'ns1__CollectionRecordType' for type 'ns1:CollectionRecordType' */
#ifndef SOAP_TYPE_ns1__CollectionRecordType
#define SOAP_TYPE_ns1__CollectionRecordType (195)
#endif

/* ns1__CashMaintenanceRecordType has binding name 'ns1__CashMaintenanceRecordType' for type 'ns1:CashMaintenanceRecordType' */
#ifndef SOAP_TYPE_ns1__CashMaintenanceRecordType
#define SOAP_TYPE_ns1__CashMaintenanceRecordType (194)
#endif

/* ns1__CashCountingRecordType has binding name 'ns1__CashCountingRecordType' for type 'ns1:CashCountingRecordType' */
#ifndef SOAP_TYPE_ns1__CashCountingRecordType
#define SOAP_TYPE_ns1__CashCountingRecordType (193)
#endif

/* ns1__monetaryUnit has binding name 'ns1__monetaryUnit' for type 'ns1:monetaryUnit' */
#ifndef SOAP_TYPE_ns1__monetaryUnit
#define SOAP_TYPE_ns1__monetaryUnit (192)
#endif

/* ns1__monetaryUnitListType has binding name 'ns1__monetaryUnitListType' for type 'ns1:monetaryUnitListType' */
#ifndef SOAP_TYPE_ns1__monetaryUnitListType
#define SOAP_TYPE_ns1__monetaryUnitListType (191)
#endif

/* ns1__CashCountingAdjustRecordType has binding name 'ns1__CashCountingAdjustRecordType' for type 'ns1:CashCountingAdjustRecordType' */
#ifndef SOAP_TYPE_ns1__CashCountingAdjustRecordType
#define SOAP_TYPE_ns1__CashCountingAdjustRecordType (190)
#endif

/* ns1__TicketExchangeRecordType has binding name 'ns1__TicketExchangeRecordType' for type 'ns1:TicketExchangeRecordType' */
#ifndef SOAP_TYPE_ns1__TicketExchangeRecordType
#define SOAP_TYPE_ns1__TicketExchangeRecordType (189)
#endif

/* ns1__SamType has binding name 'ns1__SamType' for type 'ns1:SamType' */
#ifndef SOAP_TYPE_ns1__SamType
#define SOAP_TYPE_ns1__SamType (188)
#endif

/* ns1__IssueOperationRecordType has binding name 'ns1__IssueOperationRecordType' for type 'ns1:IssueOperationRecordType' */
#ifndef SOAP_TYPE_ns1__IssueOperationRecordType
#define SOAP_TYPE_ns1__IssueOperationRecordType (187)
#endif

/* ns1__CscReplacementRecordType has binding name 'ns1__CscReplacementRecordType' for type 'ns1:CscReplacementRecordType' */
#ifndef SOAP_TYPE_ns1__CscReplacementRecordType
#define SOAP_TYPE_ns1__CscReplacementRecordType (186)
#endif

/* ns1__CscRefundRecordType has binding name 'ns1__CscRefundRecordType' for type 'ns1:CscRefundRecordType' */
#ifndef SOAP_TYPE_ns1__CscRefundRecordType
#define SOAP_TYPE_ns1__CscRefundRecordType (185)
#endif

/* ns1__CscDeliveryRecordType has binding name 'ns1__CscDeliveryRecordType' for type 'ns1:CscDeliveryRecordType' */
#ifndef SOAP_TYPE_ns1__CscDeliveryRecordType
#define SOAP_TYPE_ns1__CscDeliveryRecordType (184)
#endif

/* ns1__CscKeyUpdateRecordType has binding name 'ns1__CscKeyUpdateRecordType' for type 'ns1:CscKeyUpdateRecordType' */
#ifndef SOAP_TYPE_ns1__CscKeyUpdateRecordType
#define SOAP_TYPE_ns1__CscKeyUpdateRecordType (183)
#endif

/* ns1__CscPersonalizationRecordType has binding name 'ns1__CscPersonalizationRecordType' for type 'ns1:CscPersonalizationRecordType' */
#ifndef SOAP_TYPE_ns1__CscPersonalizationRecordType
#define SOAP_TYPE_ns1__CscPersonalizationRecordType (182)
#endif

/* ns1__MediaUpdateStatusRecordType has binding name 'ns1__MediaUpdateStatusRecordType' for type 'ns1:MediaUpdateStatusRecordType' */
#ifndef SOAP_TYPE_ns1__MediaUpdateStatusRecordType
#define SOAP_TYPE_ns1__MediaUpdateStatusRecordType (181)
#endif

/* ns1__InspectionRecordType has binding name 'ns1__InspectionRecordType' for type 'ns1:InspectionRecordType' */
#ifndef SOAP_TYPE_ns1__InspectionRecordType
#define SOAP_TYPE_ns1__InspectionRecordType (180)
#endif

/* ns1__InternalFailureRecordType has binding name 'ns1__InternalFailureRecordType' for type 'ns1:InternalFailureRecordType' */
#ifndef SOAP_TYPE_ns1__InternalFailureRecordType
#define SOAP_TYPE_ns1__InternalFailureRecordType (179)
#endif

/* ns1__UnlockShiftRecordType has binding name 'ns1__UnlockShiftRecordType' for type 'ns1:UnlockShiftRecordType' */
#ifndef SOAP_TYPE_ns1__UnlockShiftRecordType
#define SOAP_TYPE_ns1__UnlockShiftRecordType (178)
#endif

/* ns1__LockShiftRecordType has binding name 'ns1__LockShiftRecordType' for type 'ns1:LockShiftRecordType' */
#ifndef SOAP_TYPE_ns1__LockShiftRecordType
#define SOAP_TYPE_ns1__LockShiftRecordType (177)
#endif

/* ns1__OperationType has binding name 'ns1__OperationType' for type 'ns1:OperationType' */
#ifndef SOAP_TYPE_ns1__OperationType
#define SOAP_TYPE_ns1__OperationType (176)
#endif

/* ns1__OperationListType has binding name 'ns1__OperationListType' for type 'ns1:OperationListType' */
#ifndef SOAP_TYPE_ns1__OperationListType
#define SOAP_TYPE_ns1__OperationListType (175)
#endif

/* ns1__MediaOperationType has binding name 'ns1__MediaOperationType' for type 'ns1:MediaOperationType' */
#ifndef SOAP_TYPE_ns1__MediaOperationType
#define SOAP_TYPE_ns1__MediaOperationType (174)
#endif

/* ns1__MediaOperationListType has binding name 'ns1__MediaOperationListType' for type 'ns1:MediaOperationListType' */
#ifndef SOAP_TYPE_ns1__MediaOperationListType
#define SOAP_TYPE_ns1__MediaOperationListType (173)
#endif

/* ns1__EndShiftRecordType has binding name 'ns1__EndShiftRecordType' for type 'ns1:EndShiftRecordType' */
#ifndef SOAP_TYPE_ns1__EndShiftRecordType
#define SOAP_TYPE_ns1__EndShiftRecordType (172)
#endif

/* ns1__BeginShiftRecordType has binding name 'ns1__BeginShiftRecordType' for type 'ns1:BeginShiftRecordType' */
#ifndef SOAP_TYPE_ns1__BeginShiftRecordType
#define SOAP_TYPE_ns1__BeginShiftRecordType (171)
#endif

/* ns1__missingDataType has binding name 'ns1__missingDataType' for type 'ns1:missingDataType' */
#ifndef SOAP_TYPE_ns1__missingDataType
#define SOAP_TYPE_ns1__missingDataType (170)
#endif

/* ns1__missingDataListType has binding name 'ns1__missingDataListType' for type 'ns1:missingDataListType' */
#ifndef SOAP_TYPE_ns1__missingDataListType
#define SOAP_TYPE_ns1__missingDataListType (169)
#endif

/* ns1__OpEndOfSessionRecordType has binding name 'ns1__OpEndOfSessionRecordType' for type 'ns1:OpEndOfSessionRecordType' */
#ifndef SOAP_TYPE_ns1__OpEndOfSessionRecordType
#define SOAP_TYPE_ns1__OpEndOfSessionRecordType (168)
#endif

/* ns1__SlaveDataReportType has binding name 'ns1__SlaveDataReportType' for type 'ns1:SlaveDataReportType' */
#ifndef SOAP_TYPE_ns1__SlaveDataReportType
#define SOAP_TYPE_ns1__SlaveDataReportType (167)
#endif

/* ns1__SlaveDataReportListType has binding name 'ns1__SlaveDataReportListType' for type 'ns1:SlaveDataReportListType' */
#ifndef SOAP_TYPE_ns1__SlaveDataReportListType
#define SOAP_TYPE_ns1__SlaveDataReportListType (166)
#endif

/* ns1__dataReportType has binding name 'ns1__dataReportType' for type 'ns1:dataReportType' */
#ifndef SOAP_TYPE_ns1__dataReportType
#define SOAP_TYPE_ns1__dataReportType (165)
#endif

/* ns1__dataReportListType has binding name 'ns1__dataReportListType' for type 'ns1:dataReportListType' */
#ifndef SOAP_TYPE_ns1__dataReportListType
#define SOAP_TYPE_ns1__dataReportListType (164)
#endif

/* ns1__EndOfSessionRecordType has binding name 'ns1__EndOfSessionRecordType' for type 'ns1:EndOfSessionRecordType' */
#ifndef SOAP_TYPE_ns1__EndOfSessionRecordType
#define SOAP_TYPE_ns1__EndOfSessionRecordType (163)
#endif

/* ns1__StartOfSessionRecordType has binding name 'ns1__StartOfSessionRecordType' for type 'ns1:StartOfSessionRecordType' */
#ifndef SOAP_TYPE_ns1__StartOfSessionRecordType
#define SOAP_TYPE_ns1__StartOfSessionRecordType (162)
#endif

/* ns1__IdentificationRecordType has binding name 'ns1__IdentificationRecordType' for type 'ns1:IdentificationRecordType' */
#ifndef SOAP_TYPE_ns1__IdentificationRecordType
#define SOAP_TYPE_ns1__IdentificationRecordType (161)
#endif

/* ns1__AccountingReceiptType has binding name 'ns1__AccountingReceiptType' for type 'ns1:AccountingReceiptType' */
#ifndef SOAP_TYPE_ns1__AccountingReceiptType
#define SOAP_TYPE_ns1__AccountingReceiptType (160)
#endif

/* ns1__MoneyReturnedFlow has binding name 'ns1__MoneyReturnedFlow' for type 'ns1:MoneyReturnedFlow' */
#ifndef SOAP_TYPE_ns1__MoneyReturnedFlow
#define SOAP_TYPE_ns1__MoneyReturnedFlow (159)
#endif

/* ns1__CoinNoteReturnedListType has binding name 'ns1__CoinNoteReturnedListType' for type 'ns1:CoinNoteReturnedListType' */
#ifndef SOAP_TYPE_ns1__CoinNoteReturnedListType
#define SOAP_TYPE_ns1__CoinNoteReturnedListType (158)
#endif

/* ns1__MoneyInsertedFlow has binding name 'ns1__MoneyInsertedFlow' for type 'ns1:MoneyInsertedFlow' */
#ifndef SOAP_TYPE_ns1__MoneyInsertedFlow
#define SOAP_TYPE_ns1__MoneyInsertedFlow (157)
#endif

/* ns1__CoinNoteInsertedListType has binding name 'ns1__CoinNoteInsertedListType' for type 'ns1:CoinNoteInsertedListType' */
#ifndef SOAP_TYPE_ns1__CoinNoteInsertedListType
#define SOAP_TYPE_ns1__CoinNoteInsertedListType (156)
#endif

/* ns1__AwardType has binding name 'ns1__AwardType' for type 'ns1:AwardType' */
#ifndef SOAP_TYPE_ns1__AwardType
#define SOAP_TYPE_ns1__AwardType (155)
#endif

/* ns1__AwardListType has binding name 'ns1__AwardListType' for type 'ns1:AwardListType' */
#ifndef SOAP_TYPE_ns1__AwardListType
#define SOAP_TYPE_ns1__AwardListType (154)
#endif

/* ns1__PaymentModeType has binding name 'ns1__PaymentModeType' for type 'ns1:PaymentModeType' */
#ifndef SOAP_TYPE_ns1__PaymentModeType
#define SOAP_TYPE_ns1__PaymentModeType (153)
#endif

/* ns1__PaymentModeListType has binding name 'ns1__PaymentModeListType' for type 'ns1:PaymentModeListType' */
#ifndef SOAP_TYPE_ns1__PaymentModeListType
#define SOAP_TYPE_ns1__PaymentModeListType (152)
#endif

/* ns1__AccountingFailureInfo has binding name 'ns1__AccountingFailureInfo' for type 'ns1:AccountingFailureInfo' */
#ifndef SOAP_TYPE_ns1__AccountingFailureInfo
#define SOAP_TYPE_ns1__AccountingFailureInfo (151)
#endif

/* ns1__AccountingFailureType has binding name 'ns1__AccountingFailureType' for type 'ns1:AccountingFailureType' */
#ifndef SOAP_TYPE_ns1__AccountingFailureType
#define SOAP_TYPE_ns1__AccountingFailureType (150)
#endif

/* ns1__AccountingFailureListType has binding name 'ns1__AccountingFailureListType' for type 'ns1:AccountingFailureListType' */
#ifndef SOAP_TYPE_ns1__AccountingFailureListType
#define SOAP_TYPE_ns1__AccountingFailureListType (149)
#endif

/* ns1__AccountingUnitInfo has binding name 'ns1__AccountingUnitInfo' for type 'ns1:AccountingUnitInfo' */
#ifndef SOAP_TYPE_ns1__AccountingUnitInfo
#define SOAP_TYPE_ns1__AccountingUnitInfo (148)
#endif

/* ns1__IdentificationDocument has binding name 'ns1__IdentificationDocument' for type 'ns1:IdentificationDocument' */
#ifndef SOAP_TYPE_ns1__IdentificationDocument
#define SOAP_TYPE_ns1__IdentificationDocument (147)
#endif

/* ns1__AccountingUnit has binding name 'ns1__AccountingUnit' for type 'ns1:AccountingUnit' */
#ifndef SOAP_TYPE_ns1__AccountingUnit
#define SOAP_TYPE_ns1__AccountingUnit (146)
#endif

/* ns1__taxAppliedType has binding name 'ns1__taxAppliedType' for type 'ns1:taxAppliedType' */
#ifndef SOAP_TYPE_ns1__taxAppliedType
#define SOAP_TYPE_ns1__taxAppliedType (145)
#endif

/* ns1__taxAppliedList has binding name 'ns1__taxAppliedList' for type 'ns1:taxAppliedList' */
#ifndef SOAP_TYPE_ns1__taxAppliedList
#define SOAP_TYPE_ns1__taxAppliedList (144)
#endif

/* ns1__AccountingUnitType has binding name 'ns1__AccountingUnitType' for type 'ns1:AccountingUnitType' */
#ifndef SOAP_TYPE_ns1__AccountingUnitType
#define SOAP_TYPE_ns1__AccountingUnitType (143)
#endif

/* ns1__AccountingUnitListType has binding name 'ns1__AccountingUnitListType' for type 'ns1:AccountingUnitListType' */
#ifndef SOAP_TYPE_ns1__AccountingUnitListType
#define SOAP_TYPE_ns1__AccountingUnitListType (142)
#endif

/* ns1__AccountingOperationInfo has binding name 'ns1__AccountingOperationInfo' for type 'ns1:AccountingOperationInfo' */
#ifndef SOAP_TYPE_ns1__AccountingOperationInfo
#define SOAP_TYPE_ns1__AccountingOperationInfo (141)
#endif

/* ns1__AccountingOpType has binding name 'ns1__AccountingOpType' for type 'ns1:AccountingOpType' */
#ifndef SOAP_TYPE_ns1__AccountingOpType
#define SOAP_TYPE_ns1__AccountingOpType (140)
#endif

/* ns1__AccountingOperationRecordType has binding name 'ns1__AccountingOperationRecordType' for type 'ns1:AccountingOperationRecordType' */
#ifndef SOAP_TYPE_ns1__AccountingOperationRecordType
#define SOAP_TYPE_ns1__AccountingOperationRecordType (139)
#endif

/* ns1__ReceiptItem has binding name 'ns1__ReceiptItem' for type 'ns1:ReceiptItem' */
#ifndef SOAP_TYPE_ns1__ReceiptItem
#define SOAP_TYPE_ns1__ReceiptItem (138)
#endif

/* ns1__ReceiptLine has binding name 'ns1__ReceiptLine' for type 'ns1:ReceiptLine' */
#ifndef SOAP_TYPE_ns1__ReceiptLine
#define SOAP_TYPE_ns1__ReceiptLine (137)
#endif

/* ns1__InvoiceReceiptType has binding name 'ns1__InvoiceReceiptType' for type 'ns1:InvoiceReceiptType' */
#ifndef SOAP_TYPE_ns1__InvoiceReceiptType
#define SOAP_TYPE_ns1__InvoiceReceiptType (136)
#endif

/* ns1__PrintedInvoiceRecordType has binding name 'ns1__PrintedInvoiceRecordType' for type 'ns1:PrintedInvoiceRecordType' */
#ifndef SOAP_TYPE_ns1__PrintedInvoiceRecordType
#define SOAP_TYPE_ns1__PrintedInvoiceRecordType (135)
#endif

/* ns1__valOpMagType has binding name 'ns1__valOpMagType' for type 'ns1:valOpMagType' */
#ifndef SOAP_TYPE_ns1__valOpMagType
#define SOAP_TYPE_ns1__valOpMagType (134)
#endif

/* ns1__cardDataMagBody has binding name 'ns1__cardDataMagBody' for type 'ns1:cardDataMagBody' */
#ifndef SOAP_TYPE_ns1__cardDataMagBody
#define SOAP_TYPE_ns1__cardDataMagBody (133)
#endif

/* ns1__cardDataMagHeader has binding name 'ns1__cardDataMagHeader' for type 'ns1:cardDataMagHeader' */
#ifndef SOAP_TYPE_ns1__cardDataMagHeader
#define SOAP_TYPE_ns1__cardDataMagHeader (132)
#endif

/* ns1__CardDataMagType has binding name 'ns1__CardDataMagType' for type 'ns1:CardDataMagType' */
#ifndef SOAP_TYPE_ns1__CardDataMagType
#define SOAP_TYPE_ns1__CardDataMagType (131)
#endif

/* ns1__CardDataInfoType has binding name 'ns1__CardDataInfoType' for type 'ns1:CardDataInfoType' */
#ifndef SOAP_TYPE_ns1__CardDataInfoType
#define SOAP_TYPE_ns1__CardDataInfoType (130)
#endif

/* ns1__cardIdentificationType has binding name 'ns1__cardIdentificationType' for type 'ns1:cardIdentificationType' */
#ifndef SOAP_TYPE_ns1__cardIdentificationType
#define SOAP_TYPE_ns1__cardIdentificationType (129)
#endif

/* ns1__ValidationInfo has binding name 'ns1__ValidationInfo' for type 'ns1:ValidationInfo' */
#ifndef SOAP_TYPE_ns1__ValidationInfo
#define SOAP_TYPE_ns1__ValidationInfo (128)
#endif

/* ns1__ValidationOpType has binding name 'ns1__ValidationOpType' for type 'ns1:ValidationOpType' */
#ifndef SOAP_TYPE_ns1__ValidationOpType
#define SOAP_TYPE_ns1__ValidationOpType (127)
#endif

/* ns1__FareMedia has binding name 'ns1__FareMedia' for type 'ns1:FareMedia' */
#ifndef SOAP_TYPE_ns1__FareMedia
#define SOAP_TYPE_ns1__FareMedia (126)
#endif

/* ns1__FareProduct has binding name 'ns1__FareProduct' for type 'ns1:FareProduct' */
#ifndef SOAP_TYPE_ns1__FareProduct
#define SOAP_TYPE_ns1__FareProduct (125)
#endif

/* ns1__FareInfo has binding name 'ns1__FareInfo' for type 'ns1:FareInfo' */
#ifndef SOAP_TYPE_ns1__FareInfo
#define SOAP_TYPE_ns1__FareInfo (124)
#endif

/* ns1__FareType has binding name 'ns1__FareType' for type 'ns1:FareType' */
#ifndef SOAP_TYPE_ns1__FareType
#define SOAP_TYPE_ns1__FareType (123)
#endif

/* ns1__TitleCodeType has binding name 'ns1__TitleCodeType' for type 'ns1:TitleCodeType' */
#ifndef SOAP_TYPE_ns1__TitleCodeType
#define SOAP_TYPE_ns1__TitleCodeType (122)
#endif

/* ns1__FareProductType has binding name 'ns1__FareProductType' for type 'ns1:FareProductType' */
#ifndef SOAP_TYPE_ns1__FareProductType
#define SOAP_TYPE_ns1__FareProductType (121)
#endif

/* ns1__shiftType has binding name 'ns1__shiftType' for type 'ns1:shiftType' */
#ifndef SOAP_TYPE_ns1__shiftType
#define SOAP_TYPE_ns1__shiftType (120)
#endif

/* ns1__ValidationRecordType has binding name 'ns1__ValidationRecordType' for type 'ns1:ValidationRecordType' */
#ifndef SOAP_TYPE_ns1__ValidationRecordType
#define SOAP_TYPE_ns1__ValidationRecordType (119)
#endif

/* ns1__OperationInfoType has binding name 'ns1__OperationInfoType' for type 'ns1:OperationInfoType' */
#ifndef SOAP_TYPE_ns1__OperationInfoType
#define SOAP_TYPE_ns1__OperationInfoType (118)
#endif

/* ns1__LocationBoardType has binding name 'ns1__LocationBoardType' for type 'ns1:LocationBoardType' */
#ifndef SOAP_TYPE_ns1__LocationBoardType
#define SOAP_TYPE_ns1__LocationBoardType (117)
#endif

/* ns1__LocationStationType has binding name 'ns1__LocationStationType' for type 'ns1:LocationStationType' */
#ifndef SOAP_TYPE_ns1__LocationStationType
#define SOAP_TYPE_ns1__LocationStationType (116)
#endif

/* ns1__Schedule has binding name 'ns1__Schedule' for type 'ns1:Schedule' */
#ifndef SOAP_TYPE_ns1__Schedule
#define SOAP_TYPE_ns1__Schedule (115)
#endif

/* ns1__AVLocation has binding name 'ns1__AVLocation' for type 'ns1:AVLocation' */
#ifndef SOAP_TYPE_ns1__AVLocation
#define SOAP_TYPE_ns1__AVLocation (114)
#endif

/* ns1__OperationalLocationBase has binding name 'ns1__OperationalLocationBase' for type 'ns1:OperationalLocationBase' */
#ifndef SOAP_TYPE_ns1__OperationalLocationBase
#define SOAP_TYPE_ns1__OperationalLocationBase (113)
#endif

/* ns1__OperationalLocation has binding name 'ns1__OperationalLocation' for type 'ns1:OperationalLocation' */
#ifndef SOAP_TYPE_ns1__OperationalLocation
#define SOAP_TYPE_ns1__OperationalLocation (112)
#endif

/* ns1__OnboardLocation has binding name 'ns1__OnboardLocation' for type 'ns1:OnboardLocation' */
#ifndef SOAP_TYPE_ns1__OnboardLocation
#define SOAP_TYPE_ns1__OnboardLocation (111)
#endif

/* ns1__EquipmentLocation has binding name 'ns1__EquipmentLocation' for type 'ns1:EquipmentLocation' */
#ifndef SOAP_TYPE_ns1__EquipmentLocation
#define SOAP_TYPE_ns1__EquipmentLocation (110)
#endif

/* ns1__FixedLocation has binding name 'ns1__FixedLocation' for type 'ns1:FixedLocation' */
#ifndef SOAP_TYPE_ns1__FixedLocation
#define SOAP_TYPE_ns1__FixedLocation (109)
#endif

/* ns1__LocationType has binding name 'ns1__LocationType' for type 'ns1:LocationType' */
#ifndef SOAP_TYPE_ns1__LocationType
#define SOAP_TYPE_ns1__LocationType (108)
#endif

/* ns1__ConfigVersionType has binding name 'ns1__ConfigVersionType' for type 'ns1:ConfigVersionType' */
#ifndef SOAP_TYPE_ns1__ConfigVersionType
#define SOAP_TYPE_ns1__ConfigVersionType (107)
#endif

/* ns1__ConfigVersionTypeList has binding name 'ns1__ConfigVersionTypeList' for type 'ns1:ConfigVersionTypeList' */
#ifndef SOAP_TYPE_ns1__ConfigVersionTypeList
#define SOAP_TYPE_ns1__ConfigVersionTypeList (106)
#endif

/* ns1__stSWFileType has binding name 'ns1__stSWFileType' for type 'ns1:stSWFileType' */
#ifndef SOAP_TYPE_ns1__stSWFileType
#define SOAP_TYPE_ns1__stSWFileType (105)
#endif

/* ns1__stSWFileListType has binding name 'ns1__stSWFileListType' for type 'ns1:stSWFileListType' */
#ifndef SOAP_TYPE_ns1__stSWFileListType
#define SOAP_TYPE_ns1__stSWFileListType (104)
#endif

/* ns1__stConfigFileType has binding name 'ns1__stConfigFileType' for type 'ns1:stConfigFileType' */
#ifndef SOAP_TYPE_ns1__stConfigFileType
#define SOAP_TYPE_ns1__stConfigFileType (103)
#endif

/* ns1__stConfigFileListType has binding name 'ns1__stConfigFileListType' for type 'ns1:stConfigFileListType' */
#ifndef SOAP_TYPE_ns1__stConfigFileListType
#define SOAP_TYPE_ns1__stConfigFileListType (102)
#endif

/* ns1__stPackageType has binding name 'ns1__stPackageType' for type 'ns1:stPackageType' */
#ifndef SOAP_TYPE_ns1__stPackageType
#define SOAP_TYPE_ns1__stPackageType (101)
#endif

/* ns1__stPackageListType has binding name 'ns1__stPackageListType' for type 'ns1:stPackageListType' */
#ifndef SOAP_TYPE_ns1__stPackageListType
#define SOAP_TYPE_ns1__stPackageListType (100)
#endif

/* ns1__BaseRecordType has binding name 'ns1__BaseRecordType' for type 'ns1:BaseRecordType' */
#ifndef SOAP_TYPE_ns1__BaseRecordType
#define SOAP_TYPE_ns1__BaseRecordType (99)
#endif

/* ns1__StartUpRecordType has binding name 'ns1__StartUpRecordType' for type 'ns1:StartUpRecordType' */
#ifndef SOAP_TYPE_ns1__StartUpRecordType
#define SOAP_TYPE_ns1__StartUpRecordType (98)
#endif

/* ns1__UnsignedRecordType has binding name 'ns1__UnsignedRecordType' for type 'ns1:UnsignedRecordType' */
#ifndef SOAP_TYPE_ns1__UnsignedRecordType
#define SOAP_TYPE_ns1__UnsignedRecordType (97)
#endif

/* ns1__RecordType has binding name 'ns1__RecordType' for type 'ns1:RecordType' */
#ifndef SOAP_TYPE_ns1__RecordType
#define SOAP_TYPE_ns1__RecordType (96)
#endif

/* ns1__RecordListType has binding name 'ns1__RecordListType' for type 'ns1:RecordListType' */
#ifndef SOAP_TYPE_ns1__RecordListType
#define SOAP_TYPE_ns1__RecordListType (95)
#endif

/* ns1__ResultWS has binding name 'ns1__ResultWS' for type 'ns1:ResultWS' */
#ifndef SOAP_TYPE_ns1__ResultWS
#define SOAP_TYPE_ns1__ResultWS (94)
#endif

/* ns1__SrvRecordResponseType has binding name 'ns1__SrvRecordResponseType' for type 'ns1:SrvRecordResponseType' */
#ifndef SOAP_TYPE_ns1__SrvRecordResponseType
#define SOAP_TYPE_ns1__SrvRecordResponseType (93)
#endif

/* ns1__FileConfigVersionListType has binding name 'ns1__FileConfigVersionListType' for type 'ns1:FileConfigVersionListType' */
#ifndef SOAP_TYPE_ns1__FileConfigVersionListType
#define SOAP_TYPE_ns1__FileConfigVersionListType (92)
#endif

/* ns1__PackageConfigVersionType has binding name 'ns1__PackageConfigVersionType' for type 'ns1:PackageConfigVersionType' */
#ifndef SOAP_TYPE_ns1__PackageConfigVersionType
#define SOAP_TYPE_ns1__PackageConfigVersionType (91)
#endif

/* ns1__PackageConfigVersionListType has binding name 'ns1__PackageConfigVersionListType' for type 'ns1:PackageConfigVersionListType' */
#ifndef SOAP_TYPE_ns1__PackageConfigVersionListType
#define SOAP_TYPE_ns1__PackageConfigVersionListType (90)
#endif

/* ns1__PatternServiceResponseType has binding name 'ns1__PatternServiceResponseType' for type 'ns1:PatternServiceResponseType' */
#ifndef SOAP_TYPE_ns1__PatternServiceResponseType
#define SOAP_TYPE_ns1__PatternServiceResponseType (89)
#endif

/* ns1__SrvConfigurationInfoResponseType has binding name 'ns1__SrvConfigurationInfoResponseType' for type 'ns1:SrvConfigurationInfoResponseType' */
#ifndef SOAP_TYPE_ns1__SrvConfigurationInfoResponseType
#define SOAP_TYPE_ns1__SrvConfigurationInfoResponseType (88)
#endif

/* ns1__getVersionListResponse has binding name 'ns1__getVersionListResponse' for type 'ns1:getVersionListResponse' */
#ifndef SOAP_TYPE_ns1__getVersionListResponse
#define SOAP_TYPE_ns1__getVersionListResponse (87)
#endif

/* ns1__srvCommandV1RequestType has binding name 'ns1__srvCommandV1RequestType' for type 'ns1:srvCommandV1RequestType' */
#ifndef SOAP_TYPE_ns1__srvCommandV1RequestType
#define SOAP_TYPE_ns1__srvCommandV1RequestType (86)
#endif

/* ns1__srvCommandBaseRequestType has binding name 'ns1__srvCommandBaseRequestType' for type 'ns1:srvCommandBaseRequestType' */
#ifndef SOAP_TYPE_ns1__srvCommandBaseRequestType
#define SOAP_TYPE_ns1__srvCommandBaseRequestType (85)
#endif

/* ns1__srvConfigurationV1RequestType has binding name 'ns1__srvConfigurationV1RequestType' for type 'ns1:srvConfigurationV1RequestType' */
#ifndef SOAP_TYPE_ns1__srvConfigurationV1RequestType
#define SOAP_TYPE_ns1__srvConfigurationV1RequestType (84)
#endif

/* ns1__srvConfigurationBaseRequestType has binding name 'ns1__srvConfigurationBaseRequestType' for type 'ns1:srvConfigurationBaseRequestType' */
#ifndef SOAP_TYPE_ns1__srvConfigurationBaseRequestType
#define SOAP_TYPE_ns1__srvConfigurationBaseRequestType (83)
#endif

/* ns1__srvPresentationV1RequestType has binding name 'ns1__srvPresentationV1RequestType' for type 'ns1:srvPresentationV1RequestType' */
#ifndef SOAP_TYPE_ns1__srvPresentationV1RequestType
#define SOAP_TYPE_ns1__srvPresentationV1RequestType (82)
#endif

/* ns1__srvPresentationBaseRequestType has binding name 'ns1__srvPresentationBaseRequestType' for type 'ns1:srvPresentationBaseRequestType' */
#ifndef SOAP_TYPE_ns1__srvPresentationBaseRequestType
#define SOAP_TYPE_ns1__srvPresentationBaseRequestType (81)
#endif

/* ns1__FileConfigVersionType has binding name 'ns1__FileConfigVersionType' for type 'ns1:FileConfigVersionType' */
#ifndef SOAP_TYPE_ns1__FileConfigVersionType
#define SOAP_TYPE_ns1__FileConfigVersionType (80)
#endif

/* ns1__SrvConfigurationContentRequestType has binding name 'ns1__SrvConfigurationContentRequestType' for type 'ns1:SrvConfigurationContentRequestType' */
#ifndef SOAP_TYPE_ns1__SrvConfigurationContentRequestType
#define SOAP_TYPE_ns1__SrvConfigurationContentRequestType (79)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREVersionRequestType has binding name 'ns1__SrvFE_USCOREMTC_USCOREVersionRequestType' for type 'ns1:SrvFE_MTC_VersionRequestType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREVersionRequestType (78)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType has binding name 'ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType' for type 'ns1:SrvFE_MTC_DiagnosticRequestType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType (77)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREStatusRequestType has binding name 'ns1__SrvFE_USCOREMTC_USCOREStatusRequestType' for type 'ns1:SrvFE_MTC_StatusRequestType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREStatusRequestType (76)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType has binding name 'ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType' for type 'ns1:SrvFE_MTC_AlarmRequestType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType (75)
#endif

/* ns1__CommandParamCCTIUType has binding name 'ns1__CommandParamCCTIUType' for type 'ns1:CommandParamCCTIUType' */
#ifndef SOAP_TYPE_ns1__CommandParamCCTIUType
#define SOAP_TYPE_ns1__CommandParamCCTIUType (74)
#endif

/* ns1__CommandParamCCTIUListType has binding name 'ns1__CommandParamCCTIUListType' for type 'ns1:CommandParamCCTIUListType' */
#ifndef SOAP_TYPE_ns1__CommandParamCCTIUListType
#define SOAP_TYPE_ns1__CommandParamCCTIUListType (73)
#endif

/* ns1__CommandCCTIUType has binding name 'ns1__CommandCCTIUType' for type 'ns1:CommandCCTIUType' */
#ifndef SOAP_TYPE_ns1__CommandCCTIUType
#define SOAP_TYPE_ns1__CommandCCTIUType (72)
#endif

/* ns1__SrvMTC_USCORECommandExecRequestType has binding name 'ns1__SrvMTC_USCORECommandExecRequestType' for type 'ns1:SrvMTC_CommandExecRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORECommandExecRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCORECommandExecRequestType (71)
#endif

/* ns1__ValueType has binding name 'ns1__ValueType' for type 'ns1:ValueType' */
#ifndef SOAP_TYPE_ns1__ValueType
#define SOAP_TYPE_ns1__ValueType (70)
#endif

/* ns1__ConfigElementCCTIUType has binding name 'ns1__ConfigElementCCTIUType' for type 'ns1:ConfigElementCCTIUType' */
#ifndef SOAP_TYPE_ns1__ConfigElementCCTIUType
#define SOAP_TYPE_ns1__ConfigElementCCTIUType (69)
#endif

/* ns1__ConfigElementCCTIUListType has binding name 'ns1__ConfigElementCCTIUListType' for type 'ns1:ConfigElementCCTIUListType' */
#ifndef SOAP_TYPE_ns1__ConfigElementCCTIUListType
#define SOAP_TYPE_ns1__ConfigElementCCTIUListType (68)
#endif

/* ns1__SrvMTC_USCOREConfigElementChangeRequestType has binding name 'ns1__SrvMTC_USCOREConfigElementChangeRequestType' for type 'ns1:SrvMTC_ConfigElementChangeRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementChangeRequestType (67)
#endif

/* ns1__SrvMTC_USCOREConfigElementRequestType has binding name 'ns1__SrvMTC_USCOREConfigElementRequestType' for type 'ns1:SrvMTC_ConfigElementRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREConfigElementRequestType (66)
#endif

/* ns1__SrvMTC_USCOREVersionRequestType has binding name 'ns1__SrvMTC_USCOREVersionRequestType' for type 'ns1:SrvMTC_VersionRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREVersionRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREVersionRequestType (65)
#endif

/* ns1__SrvMTC_USCOREDiagnosticRequestType has binding name 'ns1__SrvMTC_USCOREDiagnosticRequestType' for type 'ns1:SrvMTC_DiagnosticRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREDiagnosticRequestType (64)
#endif

/* ns1__SrvMTC_USCOREStatusRequestType has binding name 'ns1__SrvMTC_USCOREStatusRequestType' for type 'ns1:SrvMTC_StatusRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREStatusRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREStatusRequestType (63)
#endif

/* ns1__SrvMTC_USCOREAlarmRequestType has binding name 'ns1__SrvMTC_USCOREAlarmRequestType' for type 'ns1:SrvMTC_AlarmRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCOREAlarmRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCOREAlarmRequestType (62)
#endif

/* ns1__SrvStateRequestType has binding name 'ns1__SrvStateRequestType' for type 'ns1:SrvStateRequestType' */
#ifndef SOAP_TYPE_ns1__SrvStateRequestType
#define SOAP_TYPE_ns1__SrvStateRequestType (61)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionRequestType has binding name 'ns1__SrvFE_USCOREMTC_USCORETransactionRequestType' for type 'ns1:SrvFE_MTC_TransactionRequestType' */
#ifndef SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType
#define SOAP_TYPE_ns1__SrvFE_USCOREMTC_USCORETransactionRequestType (60)
#endif

/* ns1__MTC_USCORETransactionIdType has binding name 'ns1__MTC_USCORETransactionIdType' for type 'ns1:MTC_TransactionIdType' */
#ifndef SOAP_TYPE_ns1__MTC_USCORETransactionIdType
#define SOAP_TYPE_ns1__MTC_USCORETransactionIdType (59)
#endif

/* ns1__TransactionMTCIdRangeType has binding name 'ns1__TransactionMTCIdRangeType' for type 'ns1:TransactionMTCIdRangeType' */
#ifndef SOAP_TYPE_ns1__TransactionMTCIdRangeType
#define SOAP_TYPE_ns1__TransactionMTCIdRangeType (58)
#endif

/* ns1__TransactionMTCIdRangeListType has binding name 'ns1__TransactionMTCIdRangeListType' for type 'ns1:TransactionMTCIdRangeListType' */
#ifndef SOAP_TYPE_ns1__TransactionMTCIdRangeListType
#define SOAP_TYPE_ns1__TransactionMTCIdRangeListType (57)
#endif

/* ns1__SrvMTC_USCORETransactionRequestType has binding name 'ns1__SrvMTC_USCORETransactionRequestType' for type 'ns1:SrvMTC_TransactionRequestType' */
#ifndef SOAP_TYPE_ns1__SrvMTC_USCORETransactionRequestType
#define SOAP_TYPE_ns1__SrvMTC_USCORETransactionRequestType (56)
#endif

/* ns1__Parameter has binding name 'ns1__Parameter' for type 'ns1:Parameter' */
#ifndef SOAP_TYPE_ns1__Parameter
#define SOAP_TYPE_ns1__Parameter (55)
#endif

/* ns1__ParameterList has binding name 'ns1__ParameterList' for type 'ns1:ParameterList' */
#ifndef SOAP_TYPE_ns1__ParameterList
#define SOAP_TYPE_ns1__ParameterList (54)
#endif

/* ns1__CustomRecordRequest has binding name 'ns1__CustomRecordRequest' for type 'ns1:CustomRecordRequest' */
#ifndef SOAP_TYPE_ns1__CustomRecordRequest
#define SOAP_TYPE_ns1__CustomRecordRequest (53)
#endif

/* ns1__RecordIdType has binding name 'ns1__RecordIdType' for type 'ns1:RecordIdType' */
#ifndef SOAP_TYPE_ns1__RecordIdType
#define SOAP_TYPE_ns1__RecordIdType (52)
#endif

/* ns1__RecordRangeIdType has binding name 'ns1__RecordRangeIdType' for type 'ns1:RecordRangeIdType' */
#ifndef SOAP_TYPE_ns1__RecordRangeIdType
#define SOAP_TYPE_ns1__RecordRangeIdType (51)
#endif

/* ns1__RecordRangeIdTypeList has binding name 'ns1__RecordRangeIdTypeList' for type 'ns1:RecordRangeIdTypeList' */
#ifndef SOAP_TYPE_ns1__RecordRangeIdTypeList
#define SOAP_TYPE_ns1__RecordRangeIdTypeList (50)
#endif

/* ns1__SrvRecordRequestType has binding name 'ns1__SrvRecordRequestType' for type 'ns1:SrvRecordRequestType' */
#ifndef SOAP_TYPE_ns1__SrvRecordRequestType
#define SOAP_TYPE_ns1__SrvRecordRequestType (49)
#endif

/* ns1__SlaveEquipmentListType has binding name 'ns1__SlaveEquipmentListType' for type 'ns1:SlaveEquipmentListType' */
#ifndef SOAP_TYPE_ns1__SlaveEquipmentListType
#define SOAP_TYPE_ns1__SlaveEquipmentListType (48)
#endif

/* ns1__EquipmentReferenceType has binding name 'ns1__EquipmentReferenceType' for type 'ns1:EquipmentReferenceType' */
#ifndef SOAP_TYPE_ns1__EquipmentReferenceType
#define SOAP_TYPE_ns1__EquipmentReferenceType (47)
#endif

/* ns1__PatternServiceRequestType has binding name 'ns1__PatternServiceRequestType' for type 'ns1:PatternServiceRequestType' */
#ifndef SOAP_TYPE_ns1__PatternServiceRequestType
#define SOAP_TYPE_ns1__PatternServiceRequestType (46)
#endif

/* ns1__SrvConfigurationInfoRequestType has binding name 'ns1__SrvConfigurationInfoRequestType' for type 'ns1:SrvConfigurationInfoRequestType' */
#ifndef SOAP_TYPE_ns1__SrvConfigurationInfoRequestType
#define SOAP_TYPE_ns1__SrvConfigurationInfoRequestType (45)
#endif

/* ns1__getVersionList has binding name 'ns1__getVersionList' for type 'ns1:getVersionList' */
#ifndef SOAP_TYPE_ns1__getVersionList
#define SOAP_TYPE_ns1__getVersionList (44)
#endif

/* ns1__getProtoVersionListResponse has binding name 'ns1__getProtoVersionListResponse' for type 'ns1:getProtoVersionListResponse' */
#ifndef SOAP_TYPE_ns1__getProtoVersionListResponse
#define SOAP_TYPE_ns1__getProtoVersionListResponse (43)
#endif

/* ns1__getProtoVersionList has binding name 'ns1__getProtoVersionList' for type 'ns1:getProtoVersionList' */
#ifndef SOAP_TYPE_ns1__getProtoVersionList
#define SOAP_TYPE_ns1__getProtoVersionList (42)
#endif

/* xsd__unsignedShort has binding name 'xsd__unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort
#define SOAP_TYPE_xsd__unsignedShort (39)
#endif

/* xsd__unsignedLong has binding name 'xsd__unsignedLong' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (37)
#endif

/* xsd__unsignedInt has binding name 'xsd__unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt
#define SOAP_TYPE_xsd__unsignedInt (36)
#endif

/* xsd__string has binding name 'xsd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (35)
#endif

/* xsd__positiveInteger_ has binding name 'xsd__positiveInteger_' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_xsd__positiveInteger_
#define SOAP_TYPE_xsd__positiveInteger_ (34)
#endif

/* xsd__long has binding name 'xsd__long' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long
#define SOAP_TYPE_xsd__long (31)
#endif

/* xsd__language_ has binding name 'xsd__language_' for type 'xsd:language' */
#ifndef SOAP_TYPE_xsd__language_
#define SOAP_TYPE_xsd__language_ (30)
#endif

/* xsd__integer_ has binding name 'xsd__integer_' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (28)
#endif

/* xsd__int has binding name 'xsd__int' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (26)
#endif

/* xsd__hexBinary_ has binding name 'xsd__hexBinary_' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary_
#define SOAP_TYPE_xsd__hexBinary_ (25)
#endif

/* xsd__float has binding name 'xsd__float' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (23)
#endif

/* xsd__double has binding name 'xsd__double' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double
#define SOAP_TYPE_xsd__double (21)
#endif

/* xsd__dateTime has binding name 'xsd__dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (19)
#endif

/* xsd__date_ has binding name 'xsd__date_' for type 'xsd:date' */
#ifndef SOAP_TYPE_xsd__date_
#define SOAP_TYPE_xsd__date_ (18)
#endif

/* xsd__boolean has binding name 'xsd__boolean' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (15)
#endif

/* xsd__base64Binary_ has binding name 'xsd__base64Binary_' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (14)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (13)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (9)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (7)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (838)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (837)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (834)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (832)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (831)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (840)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (839)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (833)
#endif

/* ns1__getVersionList * has binding name 'PointerTons1__getVersionList' for type 'ns1:getVersionList' */
#ifndef SOAP_TYPE_PointerTons1__getVersionList
#define SOAP_TYPE_PointerTons1__getVersionList (827)
#endif

/* ns1__getProtoVersionList * has binding name 'PointerTons1__getProtoVersionList' for type 'ns1:getProtoVersionList' */
#ifndef SOAP_TYPE_PointerTons1__getProtoVersionList
#define SOAP_TYPE_PointerTons1__getProtoVersionList (823)
#endif

/* ns1__SlavePresentationResponseListType * has binding name 'PointerTons1__SlavePresentationResponseListType' for type 'ns1:SlavePresentationResponseListType' */
#ifndef SOAP_TYPE_PointerTons1__SlavePresentationResponseListType
#define SOAP_TYPE_PointerTons1__SlavePresentationResponseListType (822)
#endif

/* ns1__MtvmExtStateType * has binding name 'PointerTons1__MtvmExtStateType' for type 'ns1:MtvmExtStateType' */
#ifndef SOAP_TYPE_PointerTons1__MtvmExtStateType
#define SOAP_TYPE_PointerTons1__MtvmExtStateType (821)
#endif

/* ns1__ExtStateType * has binding name 'PointerTons1__ExtStateType' for type 'ns1:ExtStateType' */
#ifndef SOAP_TYPE_PointerTons1__ExtStateType
#define SOAP_TYPE_PointerTons1__ExtStateType (820)
#endif

/* ns1__TvmExtStateType * has binding name 'PointerTons1__TvmExtStateType' for type 'ns1:TvmExtStateType' */
#ifndef SOAP_TYPE_PointerTons1__TvmExtStateType
#define SOAP_TYPE_PointerTons1__TvmExtStateType (819)
#endif

/* ns1__StateConfigInstallationListType * has binding name 'PointerTons1__StateConfigInstallationListType' for type 'ns1:StateConfigInstallationListType' */
#ifndef SOAP_TYPE_PointerTons1__StateConfigInstallationListType
#define SOAP_TYPE_PointerTons1__StateConfigInstallationListType (818)
#endif

/* ns1__versionListType * has binding name 'PointerTons1__versionListType' for type 'ns1:versionListType' */
#ifndef SOAP_TYPE_PointerTons1__versionListType
#define SOAP_TYPE_PointerTons1__versionListType (817)
#endif

/* ns1__diagnosticListType * has binding name 'PointerTons1__diagnosticListType' for type 'ns1:diagnosticListType' */
#ifndef SOAP_TYPE_PointerTons1__diagnosticListType
#define SOAP_TYPE_PointerTons1__diagnosticListType (816)
#endif

/* ns1__confPackageListType * has binding name 'PointerTons1__confPackageListType' for type 'ns1:confPackageListType' */
#ifndef SOAP_TYPE_PointerTons1__confPackageListType
#define SOAP_TYPE_PointerTons1__confPackageListType (815)
#endif

/* ns1__AgExtStateType * has binding name 'PointerTons1__AgExtStateType' for type 'ns1:AgExtStateType' */
#ifndef SOAP_TYPE_PointerTons1__AgExtStateType
#define SOAP_TYPE_PointerTons1__AgExtStateType (814)
#endif

/* ns1__RecordConfirmationListType * has binding name 'PointerTons1__RecordConfirmationListType' for type 'ns1:RecordConfirmationListType' */
#ifndef SOAP_TYPE_PointerTons1__RecordConfirmationListType
#define SOAP_TYPE_PointerTons1__RecordConfirmationListType (813)
#endif

/* ns1__TransactionMTCConfTypeList * has binding name 'PointerTons1__TransactionMTCConfTypeList' for type 'ns1:TransactionMTCConfTypeList' */
#ifndef SOAP_TYPE_PointerTons1__TransactionMTCConfTypeList
#define SOAP_TYPE_PointerTons1__TransactionMTCConfTypeList (812)
#endif

/* ns2__ConfigurationDocument * has binding name 'PointerTons2__ConfigurationDocument' for type 'ns2:ConfigurationDocument' */
#ifndef SOAP_TYPE_PointerTons2__ConfigurationDocument
#define SOAP_TYPE_PointerTons2__ConfigurationDocument (811)
#endif

/* ns1__InfoFEMonitorCCTIUType * has binding name 'PointerTons1__InfoFEMonitorCCTIUType' for type 'ns1:InfoFEMonitorCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__InfoFEMonitorCCTIUType
#define SOAP_TYPE_PointerTons1__InfoFEMonitorCCTIUType (810)
#endif

/* ns1__VersionsCCTIUType * has binding name 'PointerTons1__VersionsCCTIUType' for type 'ns1:VersionsCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__VersionsCCTIUType
#define SOAP_TYPE_PointerTons1__VersionsCCTIUType (809)
#endif

/* ns1__DiagnosticCCTIUListType * has binding name 'PointerTons1__DiagnosticCCTIUListType' for type 'ns1:DiagnosticCCTIUListType' */
#ifndef SOAP_TYPE_PointerTons1__DiagnosticCCTIUListType
#define SOAP_TYPE_PointerTons1__DiagnosticCCTIUListType (808)
#endif

/* ns1__StatusCCTIUListType * has binding name 'PointerTons1__StatusCCTIUListType' for type 'ns1:StatusCCTIUListType' */
#ifndef SOAP_TYPE_PointerTons1__StatusCCTIUListType
#define SOAP_TYPE_PointerTons1__StatusCCTIUListType (807)
#endif

/* ns1__AlarmCCTIUListType * has binding name 'PointerTons1__AlarmCCTIUListType' for type 'ns1:AlarmCCTIUListType' */
#ifndef SOAP_TYPE_PointerTons1__AlarmCCTIUListType
#define SOAP_TYPE_PointerTons1__AlarmCCTIUListType (806)
#endif

/* ns1__SlaveStateListType * has binding name 'PointerTons1__SlaveStateListType' for type 'ns1:SlaveStateListType' */
#ifndef SOAP_TYPE_PointerTons1__SlaveStateListType
#define SOAP_TYPE_PointerTons1__SlaveStateListType (805)
#endif

/* ns1__stateType * has binding name 'PointerTons1__stateType' for type 'ns1:stateType' */
#ifndef SOAP_TYPE_PointerTons1__stateType
#define SOAP_TYPE_PointerTons1__stateType (804)
#endif

/* ns1__InfoFERecordMTCType * has binding name 'PointerTons1__InfoFERecordMTCType' for type 'ns1:InfoFERecordMTCType' */
#ifndef SOAP_TYPE_PointerTons1__InfoFERecordMTCType
#define SOAP_TYPE_PointerTons1__InfoFERecordMTCType (803)
#endif

/* ns1__MTC_USCORETMobilitatCurveType * has binding name 'PointerTons1__MTC_USCORETMobilitatCurveType' for type 'ns1:MTC_TMobilitatCurveType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORETMobilitatCurveType
#define SOAP_TYPE_PointerTons1__MTC_USCORETMobilitatCurveType (802)
#endif

/* ns1__MTC_USCOREQuantityType ** has binding name 'PointerToPointerTons1__MTC_USCOREQuantityType' for type 'ns1:MTC_QuantityType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MTC_USCOREQuantityType
#define SOAP_TYPE_PointerToPointerTons1__MTC_USCOREQuantityType (801)
#endif

/* ns1__MTC_USCORETitleInfoType * has binding name 'PointerTons1__MTC_USCORETitleInfoType' for type 'ns1:MTC_TitleInfoType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORETitleInfoType
#define SOAP_TYPE_PointerTons1__MTC_USCORETitleInfoType (800)
#endif

/* ns1__ProductIdType * has binding name 'PointerTons1__ProductIdType' for type 'ns1:ProductIdType' */
#ifndef SOAP_TYPE_PointerTons1__ProductIdType
#define SOAP_TYPE_PointerTons1__ProductIdType (799)
#endif

/* ns1__MTC_USCOREProfileInfoType * has binding name 'PointerTons1__MTC_USCOREProfileInfoType' for type 'ns1:MTC_ProfileInfoType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREProfileInfoType
#define SOAP_TYPE_PointerTons1__MTC_USCOREProfileInfoType (798)
#endif

/* ns1__ActionIdType * has binding name 'PointerTons1__ActionIdType' for type 'ns1:ActionIdType' */
#ifndef SOAP_TYPE_PointerTons1__ActionIdType
#define SOAP_TYPE_PointerTons1__ActionIdType (797)
#endif

/* ns1__MTC_USCOREApplicationInfoType * has binding name 'PointerTons1__MTC_USCOREApplicationInfoType' for type 'ns1:MTC_ApplicationInfoType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREApplicationInfoType
#define SOAP_TYPE_PointerTons1__MTC_USCOREApplicationInfoType (796)
#endif

/* ns1__TransactionMTCRegTypeList * has binding name 'PointerTons1__TransactionMTCRegTypeList' for type 'ns1:TransactionMTCRegTypeList' */
#ifndef SOAP_TYPE_PointerTons1__TransactionMTCRegTypeList
#define SOAP_TYPE_PointerTons1__TransactionMTCRegTypeList (795)
#endif

/* ns1__ParkingValidationInfo * has binding name 'PointerTons1__ParkingValidationInfo' for type 'ns1:ParkingValidationInfo' */
#ifndef SOAP_TYPE_PointerTons1__ParkingValidationInfo
#define SOAP_TYPE_PointerTons1__ParkingValidationInfo (794)
#endif

/* ns1__ActionListType * has binding name 'PointerTons1__ActionListType' for type 'ns1:ActionListType' */
#ifndef SOAP_TYPE_PointerTons1__ActionListType
#define SOAP_TYPE_PointerTons1__ActionListType (793)
#endif

/* ns1__PenaltyType * has binding name 'PointerTons1__PenaltyType' for type 'ns1:PenaltyType' */
#ifndef SOAP_TYPE_PointerTons1__PenaltyType
#define SOAP_TYPE_PointerTons1__PenaltyType (792)
#endif

/* ns1__PendingPaymentType * has binding name 'PointerTons1__PendingPaymentType' for type 'ns1:PendingPaymentType' */
#ifndef SOAP_TYPE_PointerTons1__PendingPaymentType
#define SOAP_TYPE_PointerTons1__PendingPaymentType (791)
#endif

/* ns1__Penalty * has binding name 'PointerTons1__Penalty' for type 'ns1:Penalty' */
#ifndef SOAP_TYPE_PointerTons1__Penalty
#define SOAP_TYPE_PointerTons1__Penalty (790)
#endif

/* ns1__MediaStockListType * has binding name 'PointerTons1__MediaStockListType' for type 'ns1:MediaStockListType' */
#ifndef SOAP_TYPE_PointerTons1__MediaStockListType
#define SOAP_TYPE_PointerTons1__MediaStockListType (789)
#endif

/* ns1__SamType * has binding name 'PointerTons1__SamType' for type 'ns1:SamType' */
#ifndef SOAP_TYPE_PointerTons1__SamType
#define SOAP_TYPE_PointerTons1__SamType (788)
#endif

/* ns1__missingDataListType * has binding name 'PointerTons1__missingDataListType' for type 'ns1:missingDataListType' */
#ifndef SOAP_TYPE_PointerTons1__missingDataListType
#define SOAP_TYPE_PointerTons1__missingDataListType (787)
#endif

/* ns1__SlaveDataReportListType * has binding name 'PointerTons1__SlaveDataReportListType' for type 'ns1:SlaveDataReportListType' */
#ifndef SOAP_TYPE_PointerTons1__SlaveDataReportListType
#define SOAP_TYPE_PointerTons1__SlaveDataReportListType (786)
#endif

/* ns1__AccountingReceiptType * has binding name 'PointerTons1__AccountingReceiptType' for type 'ns1:AccountingReceiptType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingReceiptType
#define SOAP_TYPE_PointerTons1__AccountingReceiptType (785)
#endif

/* ns1__CoinNoteReturnedListType * has binding name 'PointerTons1__CoinNoteReturnedListType' for type 'ns1:CoinNoteReturnedListType' */
#ifndef SOAP_TYPE_PointerTons1__CoinNoteReturnedListType
#define SOAP_TYPE_PointerTons1__CoinNoteReturnedListType (784)
#endif

/* ns1__CoinNoteInsertedListType * has binding name 'PointerTons1__CoinNoteInsertedListType' for type 'ns1:CoinNoteInsertedListType' */
#ifndef SOAP_TYPE_PointerTons1__CoinNoteInsertedListType
#define SOAP_TYPE_PointerTons1__CoinNoteInsertedListType (783)
#endif

/* ns1__AwardListType * has binding name 'PointerTons1__AwardListType' for type 'ns1:AwardListType' */
#ifndef SOAP_TYPE_PointerTons1__AwardListType
#define SOAP_TYPE_PointerTons1__AwardListType (782)
#endif

/* ns1__PaymentModeListType * has binding name 'PointerTons1__PaymentModeListType' for type 'ns1:PaymentModeListType' */
#ifndef SOAP_TYPE_PointerTons1__PaymentModeListType
#define SOAP_TYPE_PointerTons1__PaymentModeListType (781)
#endif

/* ns1__AccountingFailureListType * has binding name 'PointerTons1__AccountingFailureListType' for type 'ns1:AccountingFailureListType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingFailureListType
#define SOAP_TYPE_PointerTons1__AccountingFailureListType (780)
#endif

/* ns1__AccountingUnitListType * has binding name 'PointerTons1__AccountingUnitListType' for type 'ns1:AccountingUnitListType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingUnitListType
#define SOAP_TYPE_PointerTons1__AccountingUnitListType (779)
#endif

/* ns1__AccountingOperationInfo * has binding name 'PointerTons1__AccountingOperationInfo' for type 'ns1:AccountingOperationInfo' */
#ifndef SOAP_TYPE_PointerTons1__AccountingOperationInfo
#define SOAP_TYPE_PointerTons1__AccountingOperationInfo (778)
#endif

/* ns1__AccountingOpType * has binding name 'PointerTons1__AccountingOpType' for type 'ns1:AccountingOpType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingOpType
#define SOAP_TYPE_PointerTons1__AccountingOpType (777)
#endif

/* ns1__FareType * has binding name 'PointerTons1__FareType' for type 'ns1:FareType' */
#ifndef SOAP_TYPE_PointerTons1__FareType
#define SOAP_TYPE_PointerTons1__FareType (776)
#endif

/* ns1__ValidationInfo * has binding name 'PointerTons1__ValidationInfo' for type 'ns1:ValidationInfo' */
#ifndef SOAP_TYPE_PointerTons1__ValidationInfo
#define SOAP_TYPE_PointerTons1__ValidationInfo (775)
#endif

/* ns1__ValidationOpType * has binding name 'PointerTons1__ValidationOpType' for type 'ns1:ValidationOpType' */
#ifndef SOAP_TYPE_PointerTons1__ValidationOpType
#define SOAP_TYPE_PointerTons1__ValidationOpType (774)
#endif

/* ns1__FareProductType * has binding name 'PointerTons1__FareProductType' for type 'ns1:FareProductType' */
#ifndef SOAP_TYPE_PointerTons1__FareProductType
#define SOAP_TYPE_PointerTons1__FareProductType (773)
#endif

/* ns1__Schedule * has binding name 'PointerTons1__Schedule' for type 'ns1:Schedule' */
#ifndef SOAP_TYPE_PointerTons1__Schedule
#define SOAP_TYPE_PointerTons1__Schedule (772)
#endif

/* ns1__stPackageListType * has binding name 'PointerTons1__stPackageListType' for type 'ns1:stPackageListType' */
#ifndef SOAP_TYPE_PointerTons1__stPackageListType
#define SOAP_TYPE_PointerTons1__stPackageListType (771)
#endif

/* ns1__RecordListType * has binding name 'PointerTons1__RecordListType' for type 'ns1:RecordListType' */
#ifndef SOAP_TYPE_PointerTons1__RecordListType
#define SOAP_TYPE_PointerTons1__RecordListType (770)
#endif

/* ns1__ResultWS * has binding name 'PointerTons1__ResultWS' for type 'ns1:ResultWS' */
#ifndef SOAP_TYPE_PointerTons1__ResultWS
#define SOAP_TYPE_PointerTons1__ResultWS (769)
#endif

/* ns1__PackageConfigVersionListType * has binding name 'PointerTons1__PackageConfigVersionListType' for type 'ns1:PackageConfigVersionListType' */
#ifndef SOAP_TYPE_PointerTons1__PackageConfigVersionListType
#define SOAP_TYPE_PointerTons1__PackageConfigVersionListType (768)
#endif

/* ns1__CommandCCTIUType * has binding name 'PointerTons1__CommandCCTIUType' for type 'ns1:CommandCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__CommandCCTIUType
#define SOAP_TYPE_PointerTons1__CommandCCTIUType (767)
#endif

/* ns1__ConfigElementCCTIUListType * has binding name 'PointerTons1__ConfigElementCCTIUListType' for type 'ns1:ConfigElementCCTIUListType' */
#ifndef SOAP_TYPE_PointerTons1__ConfigElementCCTIUListType
#define SOAP_TYPE_PointerTons1__ConfigElementCCTIUListType (766)
#endif

/* ns1__TransactionMTCIdRangeListType * has binding name 'PointerTons1__TransactionMTCIdRangeListType' for type 'ns1:TransactionMTCIdRangeListType' */
#ifndef SOAP_TYPE_PointerTons1__TransactionMTCIdRangeListType
#define SOAP_TYPE_PointerTons1__TransactionMTCIdRangeListType (765)
#endif

/* ns1__CustomRecordRequest * has binding name 'PointerTons1__CustomRecordRequest' for type 'ns1:CustomRecordRequest' */
#ifndef SOAP_TYPE_PointerTons1__CustomRecordRequest
#define SOAP_TYPE_PointerTons1__CustomRecordRequest (764)
#endif

/* ns1__RecordRangeIdTypeList * has binding name 'PointerTons1__RecordRangeIdTypeList' for type 'ns1:RecordRangeIdTypeList' */
#ifndef SOAP_TYPE_PointerTons1__RecordRangeIdTypeList
#define SOAP_TYPE_PointerTons1__RecordRangeIdTypeList (763)
#endif

/* ns2__Distance ** has binding name 'PointerToPointerTons2__Distance' for type 'ns2:Distance' */
#ifndef SOAP_TYPE_PointerToPointerTons2__Distance
#define SOAP_TYPE_PointerToPointerTons2__Distance (762)
#endif

/* ns2__Distance * has binding name 'PointerTons2__Distance' for type 'ns2:Distance' */
#ifndef SOAP_TYPE_PointerTons2__Distance
#define SOAP_TYPE_PointerTons2__Distance (761)
#endif

/* ns2__DistanceList * has binding name 'PointerTons2__DistanceList' for type 'ns2:DistanceList' */
#ifndef SOAP_TYPE_PointerTons2__DistanceList
#define SOAP_TYPE_PointerTons2__DistanceList (760)
#endif

/* ns2__NameSet ** has binding name 'PointerToPointerTons2__NameSet' for type 'ns2:NameSet' */
#ifndef SOAP_TYPE_PointerToPointerTons2__NameSet
#define SOAP_TYPE_PointerToPointerTons2__NameSet (759)
#endif

/* ns2__NameSet * has binding name 'PointerTons2__NameSet' for type 'ns2:NameSet' */
#ifndef SOAP_TYPE_PointerTons2__NameSet
#define SOAP_TYPE_PointerTons2__NameSet (758)
#endif

/* ns2__Header * has binding name 'PointerTons2__Header' for type 'ns2:Header' */
#ifndef SOAP_TYPE_PointerTons2__Header
#define SOAP_TYPE_PointerTons2__Header (757)
#endif

/* ns1__versionList * has binding name 'PointerTons1__versionList' for type 'ns1:versionList' */
#ifndef SOAP_TYPE_PointerTons1__versionList
#define SOAP_TYPE_PointerTons1__versionList (755)
#endif

/* ns1__SrvOrderConfirmationType * has binding name 'PointerTons1__SrvOrderConfirmationType' for type 'ns1:SrvOrderConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvOrderConfirmationType
#define SOAP_TYPE_PointerTons1__SrvOrderConfirmationType (754)
#endif

/* ns1__SrvOrderNotificationType * has binding name 'PointerTons1__SrvOrderNotificationType' for type 'ns1:SrvOrderNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvOrderNotificationType
#define SOAP_TYPE_PointerTons1__SrvOrderNotificationType (753)
#endif

/* ns1__SrvFileConfirmationType * has binding name 'PointerTons1__SrvFileConfirmationType' for type 'ns1:SrvFileConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFileConfirmationType
#define SOAP_TYPE_PointerTons1__SrvFileConfirmationType (752)
#endif

/* ns1__SrvFileNotificationType * has binding name 'PointerTons1__SrvFileNotificationType' for type 'ns1:SrvFileNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFileNotificationType
#define SOAP_TYPE_PointerTons1__SrvFileNotificationType (751)
#endif

/* ns1__SrvConfigurationContentResponseType * has binding name 'PointerTons1__SrvConfigurationContentResponseType' for type 'ns1:SrvConfigurationContentResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvConfigurationContentResponseType
#define SOAP_TYPE_PointerTons1__SrvConfigurationContentResponseType (750)
#endif

/* ns1__SrvConfigurationContentRequestType * has binding name 'PointerTons1__SrvConfigurationContentRequestType' for type 'ns1:SrvConfigurationContentRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvConfigurationContentRequestType
#define SOAP_TYPE_PointerTons1__SrvConfigurationContentRequestType (749)
#endif

/* ns1__SrvNewConfigurationConfirmationType * has binding name 'PointerTons1__SrvNewConfigurationConfirmationType' for type 'ns1:SrvNewConfigurationConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvNewConfigurationConfirmationType
#define SOAP_TYPE_PointerTons1__SrvNewConfigurationConfirmationType (748)
#endif

/* ns1__SrvNewConfigurationNotificationType * has binding name 'PointerTons1__SrvNewConfigurationNotificationType' for type 'ns1:SrvNewConfigurationNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvNewConfigurationNotificationType
#define SOAP_TYPE_PointerTons1__SrvNewConfigurationNotificationType (747)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREVersionResponseType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREVersionResponseType' for type 'ns1:SrvFE_MTC_VersionResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREVersionResponseType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREVersionResponseType (746)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREVersionRequestType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREVersionRequestType' for type 'ns1:SrvFE_MTC_VersionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREVersionRequestType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREVersionRequestType (745)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType' for type 'ns1:SrvFE_MTC_DiagnosticResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREDiagnosticResponseType (744)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType' for type 'ns1:SrvFE_MTC_DiagnosticRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREDiagnosticRequestType (743)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREStatusNotificationType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREStatusNotificationType' for type 'ns1:SrvFE_MTC_StatusNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREStatusNotificationType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREStatusNotificationType (742)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREStatusResponseType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREStatusResponseType' for type 'ns1:SrvFE_MTC_StatusResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREStatusResponseType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREStatusResponseType (741)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREStatusRequestType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREStatusRequestType' for type 'ns1:SrvFE_MTC_StatusRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREStatusRequestType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREStatusRequestType (740)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREAlarmNotificationType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREAlarmNotificationType' for type 'ns1:SrvFE_MTC_AlarmNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREAlarmNotificationType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREAlarmNotificationType (739)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREAlarmResponseType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREAlarmResponseType' for type 'ns1:SrvFE_MTC_AlarmResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREAlarmResponseType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREAlarmResponseType (738)
#endif

/* ns1__SrvFE_USCOREMTC_USCOREAlarmRequestType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCOREAlarmRequestType' for type 'ns1:SrvFE_MTC_AlarmRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREAlarmRequestType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCOREAlarmRequestType (737)
#endif

/* ns1__SrvMTC_USCORECommandExecNotifyType * has binding name 'PointerTons1__SrvMTC_USCORECommandExecNotifyType' for type 'ns1:SrvMTC_CommandExecNotifyType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORECommandExecNotifyType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORECommandExecNotifyType (736)
#endif

/* ns1__SrvMTC_USCORECommandExecResponseType * has binding name 'PointerTons1__SrvMTC_USCORECommandExecResponseType' for type 'ns1:SrvMTC_CommandExecResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORECommandExecResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORECommandExecResponseType (735)
#endif

/* ns1__SrvMTC_USCORECommandExecRequestType * has binding name 'PointerTons1__SrvMTC_USCORECommandExecRequestType' for type 'ns1:SrvMTC_CommandExecRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORECommandExecRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORECommandExecRequestType (734)
#endif

/* ns1__SrvMTC_USCOREConfigElementChangeResponseType * has binding name 'PointerTons1__SrvMTC_USCOREConfigElementChangeResponseType' for type 'ns1:SrvMTC_ConfigElementChangeResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementChangeResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementChangeResponseType (733)
#endif

/* ns1__SrvMTC_USCOREConfigElementChangeRequestType * has binding name 'PointerTons1__SrvMTC_USCOREConfigElementChangeRequestType' for type 'ns1:SrvMTC_ConfigElementChangeRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementChangeRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementChangeRequestType (732)
#endif

/* ns1__SrvMTC_USCOREConfigElementResponseType * has binding name 'PointerTons1__SrvMTC_USCOREConfigElementResponseType' for type 'ns1:SrvMTC_ConfigElementResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementResponseType (731)
#endif

/* ns1__SrvMTC_USCOREConfigElementRequestType * has binding name 'PointerTons1__SrvMTC_USCOREConfigElementRequestType' for type 'ns1:SrvMTC_ConfigElementRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREConfigElementRequestType (730)
#endif

/* ns1__SrvMTC_USCOREVersionResponseType * has binding name 'PointerTons1__SrvMTC_USCOREVersionResponseType' for type 'ns1:SrvMTC_VersionResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREVersionResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREVersionResponseType (729)
#endif

/* ns1__SrvMTC_USCOREVersionRequestType * has binding name 'PointerTons1__SrvMTC_USCOREVersionRequestType' for type 'ns1:SrvMTC_VersionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREVersionRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREVersionRequestType (728)
#endif

/* ns1__SrvMTC_USCOREDiagnosticResponseType * has binding name 'PointerTons1__SrvMTC_USCOREDiagnosticResponseType' for type 'ns1:SrvMTC_DiagnosticResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREDiagnosticResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREDiagnosticResponseType (727)
#endif

/* ns1__SrvMTC_USCOREDiagnosticRequestType * has binding name 'PointerTons1__SrvMTC_USCOREDiagnosticRequestType' for type 'ns1:SrvMTC_DiagnosticRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREDiagnosticRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREDiagnosticRequestType (726)
#endif

/* ns1__SrvMTC_USCOREStatusNotificationType * has binding name 'PointerTons1__SrvMTC_USCOREStatusNotificationType' for type 'ns1:SrvMTC_StatusNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREStatusNotificationType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREStatusNotificationType (725)
#endif

/* ns1__SrvMTC_USCOREStatusResponseType * has binding name 'PointerTons1__SrvMTC_USCOREStatusResponseType' for type 'ns1:SrvMTC_StatusResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREStatusResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREStatusResponseType (724)
#endif

/* ns1__SrvMTC_USCOREStatusRequestType * has binding name 'PointerTons1__SrvMTC_USCOREStatusRequestType' for type 'ns1:SrvMTC_StatusRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREStatusRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREStatusRequestType (723)
#endif

/* ns1__SrvMTC_USCOREAlarmNotificationType * has binding name 'PointerTons1__SrvMTC_USCOREAlarmNotificationType' for type 'ns1:SrvMTC_AlarmNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREAlarmNotificationType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREAlarmNotificationType (722)
#endif

/* ns1__SrvMTC_USCOREAlarmResponseType * has binding name 'PointerTons1__SrvMTC_USCOREAlarmResponseType' for type 'ns1:SrvMTC_AlarmResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREAlarmResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREAlarmResponseType (721)
#endif

/* ns1__SrvMTC_USCOREAlarmRequestType * has binding name 'PointerTons1__SrvMTC_USCOREAlarmRequestType' for type 'ns1:SrvMTC_AlarmRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCOREAlarmRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCOREAlarmRequestType (720)
#endif

/* ns1__SrvMtvmExtendedStateNotificationType * has binding name 'PointerTons1__SrvMtvmExtendedStateNotificationType' for type 'ns1:SrvMtvmExtendedStateNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMtvmExtendedStateNotificationType
#define SOAP_TYPE_PointerTons1__SrvMtvmExtendedStateNotificationType (719)
#endif

/* ns1__SrvExtendedStateNotificationType * has binding name 'PointerTons1__SrvExtendedStateNotificationType' for type 'ns1:SrvExtendedStateNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvExtendedStateNotificationType
#define SOAP_TYPE_PointerTons1__SrvExtendedStateNotificationType (718)
#endif

/* ns1__SrvTvmExtendedStateNotificationType * has binding name 'PointerTons1__SrvTvmExtendedStateNotificationType' for type 'ns1:SrvTvmExtendedStateNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvTvmExtendedStateNotificationType
#define SOAP_TYPE_PointerTons1__SrvTvmExtendedStateNotificationType (717)
#endif

/* ns1__SrvAgExtendedStateNotificationType * has binding name 'PointerTons1__SrvAgExtendedStateNotificationType' for type 'ns1:SrvAgExtendedStateNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvAgExtendedStateNotificationType
#define SOAP_TYPE_PointerTons1__SrvAgExtendedStateNotificationType (716)
#endif

/* ns1__SrvStateSceqnNotificationType * has binding name 'PointerTons1__SrvStateSceqnNotificationType' for type 'ns1:SrvStateSceqnNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvStateSceqnNotificationType
#define SOAP_TYPE_PointerTons1__SrvStateSceqnNotificationType (715)
#endif

/* ns1__SrvStateConfigInstallationNotificationType * has binding name 'PointerTons1__SrvStateConfigInstallationNotificationType' for type 'ns1:SrvStateConfigInstallationNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvStateConfigInstallationNotificationType
#define SOAP_TYPE_PointerTons1__SrvStateConfigInstallationNotificationType (714)
#endif

/* ns1__SrvVersionNotificationType * has binding name 'PointerTons1__SrvVersionNotificationType' for type 'ns1:SrvVersionNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvVersionNotificationType
#define SOAP_TYPE_PointerTons1__SrvVersionNotificationType (713)
#endif

/* ns1__SrvDiagnosticNotificationType * has binding name 'PointerTons1__SrvDiagnosticNotificationType' for type 'ns1:SrvDiagnosticNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvDiagnosticNotificationType
#define SOAP_TYPE_PointerTons1__SrvDiagnosticNotificationType (712)
#endif

/* ns1__SrvConfigurationNotificationType * has binding name 'PointerTons1__SrvConfigurationNotificationType' for type 'ns1:SrvConfigurationNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvConfigurationNotificationType
#define SOAP_TYPE_PointerTons1__SrvConfigurationNotificationType (711)
#endif

/* ns1__srvCommandBaseResponseType * has binding name 'PointerTons1__srvCommandBaseResponseType' for type 'ns1:srvCommandBaseResponseType' */
#ifndef SOAP_TYPE_PointerTons1__srvCommandBaseResponseType
#define SOAP_TYPE_PointerTons1__srvCommandBaseResponseType (710)
#endif

/* ns1__srvCommandBaseRequestType * has binding name 'PointerTons1__srvCommandBaseRequestType' for type 'ns1:srvCommandBaseRequestType' */
#ifndef SOAP_TYPE_PointerTons1__srvCommandBaseRequestType
#define SOAP_TYPE_PointerTons1__srvCommandBaseRequestType (709)
#endif

/* ns1__SrvAlarmConfirmationType * has binding name 'PointerTons1__SrvAlarmConfirmationType' for type 'ns1:SrvAlarmConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvAlarmConfirmationType
#define SOAP_TYPE_PointerTons1__SrvAlarmConfirmationType (708)
#endif

/* ns1__SrvAlarmNotificationType * has binding name 'PointerTons1__SrvAlarmNotificationType' for type 'ns1:SrvAlarmNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvAlarmNotificationType
#define SOAP_TYPE_PointerTons1__SrvAlarmNotificationType (707)
#endif

/* ns1__srvConfigurationBaseResponseType * has binding name 'PointerTons1__srvConfigurationBaseResponseType' for type 'ns1:srvConfigurationBaseResponseType' */
#ifndef SOAP_TYPE_PointerTons1__srvConfigurationBaseResponseType
#define SOAP_TYPE_PointerTons1__srvConfigurationBaseResponseType (706)
#endif

/* ns1__srvConfigurationBaseRequestType * has binding name 'PointerTons1__srvConfigurationBaseRequestType' for type 'ns1:srvConfigurationBaseRequestType' */
#ifndef SOAP_TYPE_PointerTons1__srvConfigurationBaseRequestType
#define SOAP_TYPE_PointerTons1__srvConfigurationBaseRequestType (705)
#endif

/* ns1__SrvStateConfirmationType * has binding name 'PointerTons1__SrvStateConfirmationType' for type 'ns1:SrvStateConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvStateConfirmationType
#define SOAP_TYPE_PointerTons1__SrvStateConfirmationType (704)
#endif

/* ns1__SrvStateNotificationType * has binding name 'PointerTons1__SrvStateNotificationType' for type 'ns1:SrvStateNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvStateNotificationType
#define SOAP_TYPE_PointerTons1__SrvStateNotificationType (703)
#endif

/* ns1__SrvStateResponseType * has binding name 'PointerTons1__SrvStateResponseType' for type 'ns1:SrvStateResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvStateResponseType
#define SOAP_TYPE_PointerTons1__SrvStateResponseType (702)
#endif

/* ns1__SrvStateRequestType * has binding name 'PointerTons1__SrvStateRequestType' for type 'ns1:SrvStateRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvStateRequestType
#define SOAP_TYPE_PointerTons1__SrvStateRequestType (701)
#endif

/* ns1__srvPresentationV1ResponseType * has binding name 'PointerTons1__srvPresentationV1ResponseType' for type 'ns1:srvPresentationV1ResponseType' */
#ifndef SOAP_TYPE_PointerTons1__srvPresentationV1ResponseType
#define SOAP_TYPE_PointerTons1__srvPresentationV1ResponseType (700)
#endif

/* ns1__srvPresentationV1RequestType * has binding name 'PointerTons1__srvPresentationV1RequestType' for type 'ns1:srvPresentationV1RequestType' */
#ifndef SOAP_TYPE_PointerTons1__srvPresentationV1RequestType
#define SOAP_TYPE_PointerTons1__srvPresentationV1RequestType (699)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionResponseType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCORETransactionResponseType' for type 'ns1:SrvFE_MTC_TransactionResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionResponseType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionResponseType (698)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionRequestType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCORETransactionRequestType' for type 'ns1:SrvFE_MTC_TransactionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionRequestType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionRequestType (697)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionConfirmationType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCORETransactionConfirmationType' for type 'ns1:SrvFE_MTC_TransactionConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionConfirmationType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionConfirmationType (696)
#endif

/* ns1__SrvFE_USCOREMTC_USCORETransactionNotificationType * has binding name 'PointerTons1__SrvFE_USCOREMTC_USCORETransactionNotificationType' for type 'ns1:SrvFE_MTC_TransactionNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionNotificationType
#define SOAP_TYPE_PointerTons1__SrvFE_USCOREMTC_USCORETransactionNotificationType (695)
#endif

/* ns1__SrvMTC_USCORETransactionResponseType * has binding name 'PointerTons1__SrvMTC_USCORETransactionResponseType' for type 'ns1:SrvMTC_TransactionResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionResponseType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionResponseType (694)
#endif

/* ns1__SrvMTC_USCORETransactionRequestType * has binding name 'PointerTons1__SrvMTC_USCORETransactionRequestType' for type 'ns1:SrvMTC_TransactionRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionRequestType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionRequestType (693)
#endif

/* ns1__SrvMTC_USCORETransactionConfirmationType * has binding name 'PointerTons1__SrvMTC_USCORETransactionConfirmationType' for type 'ns1:SrvMTC_TransactionConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionConfirmationType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionConfirmationType (692)
#endif

/* ns1__SrvMTC_USCORETransactionNotificationType * has binding name 'PointerTons1__SrvMTC_USCORETransactionNotificationType' for type 'ns1:SrvMTC_TransactionNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionNotificationType
#define SOAP_TYPE_PointerTons1__SrvMTC_USCORETransactionNotificationType (691)
#endif

/* ns1__SrvRecordResponseType * has binding name 'PointerTons1__SrvRecordResponseType' for type 'ns1:SrvRecordResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvRecordResponseType
#define SOAP_TYPE_PointerTons1__SrvRecordResponseType (690)
#endif

/* ns1__SrvRecordRequestType * has binding name 'PointerTons1__SrvRecordRequestType' for type 'ns1:SrvRecordRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvRecordRequestType
#define SOAP_TYPE_PointerTons1__SrvRecordRequestType (689)
#endif

/* ns1__SrvRecordConfirmationType * has binding name 'PointerTons1__SrvRecordConfirmationType' for type 'ns1:SrvRecordConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvRecordConfirmationType
#define SOAP_TYPE_PointerTons1__SrvRecordConfirmationType (688)
#endif

/* ns1__SrvRecordNotificationType ** has binding name 'PointerToPointerTons1__SrvRecordNotificationType' for type 'ns1:SrvRecordNotificationType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__SrvRecordNotificationType
#define SOAP_TYPE_PointerToPointerTons1__SrvRecordNotificationType (687)
#endif

/* ns1__SrvRecordNotificationType * has binding name 'PointerTons1__SrvRecordNotificationType' for type 'ns1:SrvRecordNotificationType' */
#ifndef SOAP_TYPE_PointerTons1__SrvRecordNotificationType
#define SOAP_TYPE_PointerTons1__SrvRecordNotificationType (686)
#endif

/* ns1__stateConfigInstallationType ** has binding name 'PointerToPointerTons1__stateConfigInstallationType' for type 'ns1:stateConfigInstallationType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__stateConfigInstallationType
#define SOAP_TYPE_PointerToPointerTons1__stateConfigInstallationType (685)
#endif

/* ns1__stateConfigInstallationType * has binding name 'PointerTons1__stateConfigInstallationType' for type 'ns1:stateConfigInstallationType' */
#ifndef SOAP_TYPE_PointerTons1__stateConfigInstallationType
#define SOAP_TYPE_PointerTons1__stateConfigInstallationType (684)
#endif

/* ns1__RecordConfirmationType ** has binding name 'PointerToPointerTons1__RecordConfirmationType' for type 'ns1:RecordConfirmationType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__RecordConfirmationType
#define SOAP_TYPE_PointerToPointerTons1__RecordConfirmationType (683)
#endif

/* ns1__RecordConfirmationType * has binding name 'PointerTons1__RecordConfirmationType' for type 'ns1:RecordConfirmationType' */
#ifndef SOAP_TYPE_PointerTons1__RecordConfirmationType
#define SOAP_TYPE_PointerTons1__RecordConfirmationType (682)
#endif

/* ns1__SceqExtStateType ** has binding name 'PointerToPointerTons1__SceqExtStateType' for type 'ns1:SceqExtStateType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__SceqExtStateType
#define SOAP_TYPE_PointerToPointerTons1__SceqExtStateType (681)
#endif

/* ns1__SceqExtStateType * has binding name 'PointerTons1__SceqExtStateType' for type 'ns1:SceqExtStateType' */
#ifndef SOAP_TYPE_PointerTons1__SceqExtStateType
#define SOAP_TYPE_PointerTons1__SceqExtStateType (680)
#endif

/* ns1__diagnosticType ** has binding name 'PointerToPointerTons1__diagnosticType' for type 'ns1:diagnosticType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__diagnosticType
#define SOAP_TYPE_PointerToPointerTons1__diagnosticType (679)
#endif

/* ns1__diagnosticType * has binding name 'PointerTons1__diagnosticType' for type 'ns1:diagnosticType' */
#ifndef SOAP_TYPE_PointerTons1__diagnosticType
#define SOAP_TYPE_PointerTons1__diagnosticType (678)
#endif

/* ns1__versionType ** has binding name 'PointerToPointerTons1__versionType' for type 'ns1:versionType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__versionType
#define SOAP_TYPE_PointerToPointerTons1__versionType (677)
#endif

/* ns1__versionType * has binding name 'PointerTons1__versionType' for type 'ns1:versionType' */
#ifndef SOAP_TYPE_PointerTons1__versionType
#define SOAP_TYPE_PointerTons1__versionType (676)
#endif

/* _ns1__eqList_eq * has binding name 'PointerTo_ns1__eqList_eq' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__eqList_eq
#define SOAP_TYPE_PointerTo_ns1__eqList_eq (675)
#endif

/* ns1__eqList * has binding name 'PointerTons1__eqList' for type 'ns1:eqList' */
#ifndef SOAP_TYPE_PointerTons1__eqList
#define SOAP_TYPE_PointerTons1__eqList (673)
#endif

/* ns1__monetaryUnitListType * has binding name 'PointerTons1__monetaryUnitListType' for type 'ns1:monetaryUnitListType' */
#ifndef SOAP_TYPE_PointerTons1__monetaryUnitListType
#define SOAP_TYPE_PointerTons1__monetaryUnitListType (672)
#endif

/* ns1__boxType ** has binding name 'PointerToPointerTons1__boxType' for type 'ns1:boxType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__boxType
#define SOAP_TYPE_PointerToPointerTons1__boxType (671)
#endif

/* ns1__boxType * has binding name 'PointerTons1__boxType' for type 'ns1:boxType' */
#ifndef SOAP_TYPE_PointerTons1__boxType
#define SOAP_TYPE_PointerTons1__boxType (670)
#endif

/* ns1__MediaDispenserListType * has binding name 'PointerTons1__MediaDispenserListType' for type 'ns1:MediaDispenserListType' */
#ifndef SOAP_TYPE_PointerTons1__MediaDispenserListType
#define SOAP_TYPE_PointerTons1__MediaDispenserListType (669)
#endif

/* ns1__BoxListType * has binding name 'PointerTons1__BoxListType' for type 'ns1:BoxListType' */
#ifndef SOAP_TYPE_PointerTons1__BoxListType
#define SOAP_TYPE_PointerTons1__BoxListType (668)
#endif

/* ns1__TransactionMTCConfType ** has binding name 'PointerToPointerTons1__TransactionMTCConfType' for type 'ns1:TransactionMTCConfType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TransactionMTCConfType
#define SOAP_TYPE_PointerToPointerTons1__TransactionMTCConfType (667)
#endif

/* ns1__TransactionMTCConfType * has binding name 'PointerTons1__TransactionMTCConfType' for type 'ns1:TransactionMTCConfType' */
#ifndef SOAP_TYPE_PointerTons1__TransactionMTCConfType
#define SOAP_TYPE_PointerTons1__TransactionMTCConfType (666)
#endif

/* ns1__CashInfo ** has binding name 'PointerToPointerTons1__CashInfo' for type 'ns1:CashInfo' */
#ifndef SOAP_TYPE_PointerToPointerTons1__CashInfo
#define SOAP_TYPE_PointerToPointerTons1__CashInfo (665)
#endif

/* ns1__CashInfo * has binding name 'PointerTons1__CashInfo' for type 'ns1:CashInfo' */
#ifndef SOAP_TYPE_PointerTons1__CashInfo
#define SOAP_TYPE_PointerTons1__CashInfo (664)
#endif

/* ns1__samDeviceType ** has binding name 'PointerToPointerTons1__samDeviceType' for type 'ns1:samDeviceType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__samDeviceType
#define SOAP_TYPE_PointerToPointerTons1__samDeviceType (663)
#endif

/* ns1__samDeviceType * has binding name 'PointerTons1__samDeviceType' for type 'ns1:samDeviceType' */
#ifndef SOAP_TYPE_PointerTons1__samDeviceType
#define SOAP_TYPE_PointerTons1__samDeviceType (662)
#endif

/* ns1__Shift ** has binding name 'PointerToPointerTons1__Shift' for type 'ns1:Shift' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Shift
#define SOAP_TYPE_PointerToPointerTons1__Shift (661)
#endif

/* ns1__Shift * has binding name 'PointerTons1__Shift' for type 'ns1:Shift' */
#ifndef SOAP_TYPE_PointerTons1__Shift
#define SOAP_TYPE_PointerTons1__Shift (660)
#endif

/* ns1__DispenserStockType ** has binding name 'PointerToPointerTons1__DispenserStockType' for type 'ns1:DispenserStockType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__DispenserStockType
#define SOAP_TYPE_PointerToPointerTons1__DispenserStockType (659)
#endif

/* ns1__DispenserStockType * has binding name 'PointerTons1__DispenserStockType' for type 'ns1:DispenserStockType' */
#ifndef SOAP_TYPE_PointerTons1__DispenserStockType
#define SOAP_TYPE_PointerTons1__DispenserStockType (658)
#endif

/* ns1__DispenserStockListType * has binding name 'PointerTons1__DispenserStockListType' for type 'ns1:DispenserStockListType' */
#ifndef SOAP_TYPE_PointerTons1__DispenserStockListType
#define SOAP_TYPE_PointerTons1__DispenserStockListType (657)
#endif

/* ns1__MediaDispenserType ** has binding name 'PointerToPointerTons1__MediaDispenserType' for type 'ns1:MediaDispenserType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MediaDispenserType
#define SOAP_TYPE_PointerToPointerTons1__MediaDispenserType (656)
#endif

/* ns1__MediaDispenserType * has binding name 'PointerTons1__MediaDispenserType' for type 'ns1:MediaDispenserType' */
#ifndef SOAP_TYPE_PointerTons1__MediaDispenserType
#define SOAP_TYPE_PointerTons1__MediaDispenserType (655)
#endif

/* ns1__CashInfoList * has binding name 'PointerTons1__CashInfoList' for type 'ns1:CashInfoList' */
#ifndef SOAP_TYPE_PointerTons1__CashInfoList
#define SOAP_TYPE_PointerTons1__CashInfoList (654)
#endif

/* ns1__samDeviceTypeList * has binding name 'PointerTons1__samDeviceTypeList' for type 'ns1:samDeviceTypeList' */
#ifndef SOAP_TYPE_PointerTons1__samDeviceTypeList
#define SOAP_TYPE_PointerTons1__samDeviceTypeList (653)
#endif

/* ns1__ShiftList * has binding name 'PointerTons1__ShiftList' for type 'ns1:ShiftList' */
#ifndef SOAP_TYPE_PointerTons1__ShiftList
#define SOAP_TYPE_PointerTons1__ShiftList (652)
#endif

/* ns1__shiftType * has binding name 'PointerTons1__shiftType' for type 'ns1:shiftType' */
#ifndef SOAP_TYPE_PointerTons1__shiftType
#define SOAP_TYPE_PointerTons1__shiftType (651)
#endif

/* ns1__MediaOperationListType * has binding name 'PointerTons1__MediaOperationListType' for type 'ns1:MediaOperationListType' */
#ifndef SOAP_TYPE_PointerTons1__MediaOperationListType
#define SOAP_TYPE_PointerTons1__MediaOperationListType (650)
#endif

/* ns1__configFileType ** has binding name 'PointerToPointerTons1__configFileType' for type 'ns1:configFileType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__configFileType
#define SOAP_TYPE_PointerToPointerTons1__configFileType (649)
#endif

/* ns1__configFileType * has binding name 'PointerTons1__configFileType' for type 'ns1:configFileType' */
#ifndef SOAP_TYPE_PointerTons1__configFileType
#define SOAP_TYPE_PointerTons1__configFileType (648)
#endif

/* ns1__configFileListType * has binding name 'PointerTons1__configFileListType' for type 'ns1:configFileListType' */
#ifndef SOAP_TYPE_PointerTons1__configFileListType
#define SOAP_TYPE_PointerTons1__configFileListType (647)
#endif

/* ns1__packageType ** has binding name 'PointerToPointerTons1__packageType' for type 'ns1:packageType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__packageType
#define SOAP_TYPE_PointerToPointerTons1__packageType (646)
#endif

/* ns1__packageType * has binding name 'PointerTons1__packageType' for type 'ns1:packageType' */
#ifndef SOAP_TYPE_PointerTons1__packageType
#define SOAP_TYPE_PointerTons1__packageType (645)
#endif

/* ns1__MonitoringTypeId * has binding name 'PointerTons1__MonitoringTypeId' for type 'ns1:MonitoringTypeId' */
#ifndef SOAP_TYPE_PointerTons1__MonitoringTypeId
#define SOAP_TYPE_PointerTons1__MonitoringTypeId (644)
#endif

/* ns1__SlavePresentationResponseType ** has binding name 'PointerToPointerTons1__SlavePresentationResponseType' for type 'ns1:SlavePresentationResponseType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__SlavePresentationResponseType
#define SOAP_TYPE_PointerToPointerTons1__SlavePresentationResponseType (643)
#endif

/* ns1__SlavePresentationResponseType * has binding name 'PointerTons1__SlavePresentationResponseType' for type 'ns1:SlavePresentationResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SlavePresentationResponseType
#define SOAP_TYPE_PointerTons1__SlavePresentationResponseType (642)
#endif

/* ns1__VersionElementCfgType ** has binding name 'PointerToPointerTons1__VersionElementCfgType' for type 'ns1:VersionElementCfgType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__VersionElementCfgType
#define SOAP_TYPE_PointerToPointerTons1__VersionElementCfgType (641)
#endif

/* ns1__VersionElementCfgType * has binding name 'PointerTons1__VersionElementCfgType' for type 'ns1:VersionElementCfgType' */
#ifndef SOAP_TYPE_PointerTons1__VersionElementCfgType
#define SOAP_TYPE_PointerTons1__VersionElementCfgType (640)
#endif

/* ns1__VersionElementCfgListType * has binding name 'PointerTons1__VersionElementCfgListType' for type 'ns1:VersionElementCfgListType' */
#ifndef SOAP_TYPE_PointerTons1__VersionElementCfgListType
#define SOAP_TYPE_PointerTons1__VersionElementCfgListType (639)
#endif

/* ns1__VersionCfgType ** has binding name 'PointerToPointerTons1__VersionCfgType' for type 'ns1:VersionCfgType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__VersionCfgType
#define SOAP_TYPE_PointerToPointerTons1__VersionCfgType (638)
#endif

/* ns1__VersionCfgType * has binding name 'PointerTons1__VersionCfgType' for type 'ns1:VersionCfgType' */
#ifndef SOAP_TYPE_PointerTons1__VersionCfgType
#define SOAP_TYPE_PointerTons1__VersionCfgType (637)
#endif

/* ns1__VersionFW_USCOREHWType ** has binding name 'PointerToPointerTons1__VersionFW_USCOREHWType' for type 'ns1:VersionFW_HWType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__VersionFW_USCOREHWType
#define SOAP_TYPE_PointerToPointerTons1__VersionFW_USCOREHWType (636)
#endif

/* ns1__VersionFW_USCOREHWType * has binding name 'PointerTons1__VersionFW_USCOREHWType' for type 'ns1:VersionFW_HWType' */
#ifndef SOAP_TYPE_PointerTons1__VersionFW_USCOREHWType
#define SOAP_TYPE_PointerTons1__VersionFW_USCOREHWType (635)
#endif

/* ns1__VersionCfgListType * has binding name 'PointerTons1__VersionCfgListType' for type 'ns1:VersionCfgListType' */
#ifndef SOAP_TYPE_PointerTons1__VersionCfgListType
#define SOAP_TYPE_PointerTons1__VersionCfgListType (634)
#endif

/* ns1__VersionFW_USCOREHWListType * has binding name 'PointerTons1__VersionFW_USCOREHWListType' for type 'ns1:VersionFW_HWListType' */
#ifndef SOAP_TYPE_PointerTons1__VersionFW_USCOREHWListType
#define SOAP_TYPE_PointerTons1__VersionFW_USCOREHWListType (633)
#endif

/* ns1__DiagnosticCCTIUType ** has binding name 'PointerToPointerTons1__DiagnosticCCTIUType' for type 'ns1:DiagnosticCCTIUType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__DiagnosticCCTIUType
#define SOAP_TYPE_PointerToPointerTons1__DiagnosticCCTIUType (632)
#endif

/* ns1__DiagnosticCCTIUType * has binding name 'PointerTons1__DiagnosticCCTIUType' for type 'ns1:DiagnosticCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__DiagnosticCCTIUType
#define SOAP_TYPE_PointerTons1__DiagnosticCCTIUType (631)
#endif

/* ns1__StatusCCTIUType ** has binding name 'PointerToPointerTons1__StatusCCTIUType' for type 'ns1:StatusCCTIUType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__StatusCCTIUType
#define SOAP_TYPE_PointerToPointerTons1__StatusCCTIUType (630)
#endif

/* ns1__StatusCCTIUType * has binding name 'PointerTons1__StatusCCTIUType' for type 'ns1:StatusCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__StatusCCTIUType
#define SOAP_TYPE_PointerTons1__StatusCCTIUType (629)
#endif

/* ns1__AlarmCCTIUType ** has binding name 'PointerToPointerTons1__AlarmCCTIUType' for type 'ns1:AlarmCCTIUType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AlarmCCTIUType
#define SOAP_TYPE_PointerToPointerTons1__AlarmCCTIUType (628)
#endif

/* ns1__AlarmCCTIUType * has binding name 'PointerTons1__AlarmCCTIUType' for type 'ns1:AlarmCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__AlarmCCTIUType
#define SOAP_TYPE_PointerTons1__AlarmCCTIUType (627)
#endif

/* ns1__SlaveStateType ** has binding name 'PointerToPointerTons1__SlaveStateType' for type 'ns1:SlaveStateType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__SlaveStateType
#define SOAP_TYPE_PointerToPointerTons1__SlaveStateType (626)
#endif

/* ns1__SlaveStateType * has binding name 'PointerTons1__SlaveStateType' for type 'ns1:SlaveStateType' */
#ifndef SOAP_TYPE_PointerTons1__SlaveStateType
#define SOAP_TYPE_PointerTons1__SlaveStateType (625)
#endif

/* ns1__AlarmType ** has binding name 'PointerToPointerTons1__AlarmType' for type 'ns1:AlarmType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AlarmType
#define SOAP_TYPE_PointerToPointerTons1__AlarmType (624)
#endif

/* ns1__AlarmType * has binding name 'PointerTons1__AlarmType' for type 'ns1:AlarmType' */
#ifndef SOAP_TYPE_PointerTons1__AlarmType
#define SOAP_TYPE_PointerTons1__AlarmType (623)
#endif

/* ns1__MeasureType ** has binding name 'PointerToPointerTons1__MeasureType' for type 'ns1:MeasureType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MeasureType
#define SOAP_TYPE_PointerToPointerTons1__MeasureType (622)
#endif

/* ns1__MeasureType * has binding name 'PointerTons1__MeasureType' for type 'ns1:MeasureType' */
#ifndef SOAP_TYPE_PointerTons1__MeasureType
#define SOAP_TYPE_PointerTons1__MeasureType (621)
#endif

/* ns1__MeasureListType * has binding name 'PointerTons1__MeasureListType' for type 'ns1:MeasureListType' */
#ifndef SOAP_TYPE_PointerTons1__MeasureListType
#define SOAP_TYPE_PointerTons1__MeasureListType (620)
#endif

/* ns1__DeviceType ** has binding name 'PointerToPointerTons1__DeviceType' for type 'ns1:DeviceType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__DeviceType
#define SOAP_TYPE_PointerToPointerTons1__DeviceType (619)
#endif

/* ns1__DeviceType * has binding name 'PointerTons1__DeviceType' for type 'ns1:DeviceType' */
#ifndef SOAP_TYPE_PointerTons1__DeviceType
#define SOAP_TYPE_PointerTons1__DeviceType (618)
#endif

/* ns1__AlarmListType * has binding name 'PointerTons1__AlarmListType' for type 'ns1:AlarmListType' */
#ifndef SOAP_TYPE_PointerTons1__AlarmListType
#define SOAP_TYPE_PointerTons1__AlarmListType (617)
#endif

/* ns1__DeviceListType * has binding name 'PointerTons1__DeviceListType' for type 'ns1:DeviceListType' */
#ifndef SOAP_TYPE_PointerTons1__DeviceListType
#define SOAP_TYPE_PointerTons1__DeviceListType (616)
#endif

/* ns1__MTC_USCOREQuantityType * has binding name 'PointerTons1__MTC_USCOREQuantityType' for type 'ns1:MTC_QuantityType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREQuantityType
#define SOAP_TYPE_PointerTons1__MTC_USCOREQuantityType (615)
#endif

/* ns1__MTC_USCORETitleLoadContainerInfoType ** has binding name 'PointerToPointerTons1__MTC_USCORETitleLoadContainerInfoType' for type 'ns1:MTC_TitleLoadContainerInfoType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MTC_USCORETitleLoadContainerInfoType
#define SOAP_TYPE_PointerToPointerTons1__MTC_USCORETitleLoadContainerInfoType (614)
#endif

/* ns1__MTC_USCORETitleLoadContainerInfoType * has binding name 'PointerTons1__MTC_USCORETitleLoadContainerInfoType' for type 'ns1:MTC_TitleLoadContainerInfoType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORETitleLoadContainerInfoType
#define SOAP_TYPE_PointerTons1__MTC_USCORETitleLoadContainerInfoType (613)
#endif

/* ns1__MTC_USCORETitleLoadContainerInfoListType * has binding name 'PointerTons1__MTC_USCORETitleLoadContainerInfoListType' for type 'ns1:MTC_TitleLoadContainerInfoListType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORETitleLoadContainerInfoListType
#define SOAP_TYPE_PointerTons1__MTC_USCORETitleLoadContainerInfoListType (612)
#endif

/* ns1__MTC_USCORERangeDateType * has binding name 'PointerTons1__MTC_USCORERangeDateType' for type 'ns1:MTC_RangeDateType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORERangeDateType
#define SOAP_TYPE_PointerTons1__MTC_USCORERangeDateType (611)
#endif

/* ns1__MTC_USCOREConfigVersionType ** has binding name 'PointerToPointerTons1__MTC_USCOREConfigVersionType' for type 'ns1:MTC_ConfigVersionType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MTC_USCOREConfigVersionType
#define SOAP_TYPE_PointerToPointerTons1__MTC_USCOREConfigVersionType (610)
#endif

/* ns1__MTC_USCOREConfigVersionType * has binding name 'PointerTons1__MTC_USCOREConfigVersionType' for type 'ns1:MTC_ConfigVersionType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREConfigVersionType
#define SOAP_TYPE_PointerTons1__MTC_USCOREConfigVersionType (609)
#endif

/* ns1__MTC_USCOREOnBoardSellPointType * has binding name 'PointerTons1__MTC_USCOREOnBoardSellPointType' for type 'ns1:MTC_OnBoardSellPointType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREOnBoardSellPointType
#define SOAP_TYPE_PointerTons1__MTC_USCOREOnBoardSellPointType (608)
#endif

/* ns1__MTC_USCOREOnStationSellPointType * has binding name 'PointerTons1__MTC_USCOREOnStationSellPointType' for type 'ns1:MTC_OnStationSellPointType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREOnStationSellPointType
#define SOAP_TYPE_PointerTons1__MTC_USCOREOnStationSellPointType (607)
#endif

/* ns1__MTC_USCOREOnBoardAccessPointType * has binding name 'PointerTons1__MTC_USCOREOnBoardAccessPointType' for type 'ns1:MTC_OnBoardAccessPointType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREOnBoardAccessPointType
#define SOAP_TYPE_PointerTons1__MTC_USCOREOnBoardAccessPointType (606)
#endif

/* ns1__MTC_USCOREOnStationAccessPointType * has binding name 'PointerTons1__MTC_USCOREOnStationAccessPointType' for type 'ns1:MTC_OnStationAccessPointType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREOnStationAccessPointType
#define SOAP_TYPE_PointerTons1__MTC_USCOREOnStationAccessPointType (605)
#endif

/* ns1__MTC_USCOREOtherPoint * has binding name 'PointerTons1__MTC_USCOREOtherPoint' for type 'ns1:MTC_OtherPoint' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREOtherPoint
#define SOAP_TYPE_PointerTons1__MTC_USCOREOtherPoint (604)
#endif

/* ns1__MTC_USCORENetworkLocationType * has binding name 'PointerTons1__MTC_USCORENetworkLocationType' for type 'ns1:MTC_NetworkLocationType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORENetworkLocationType
#define SOAP_TYPE_PointerTons1__MTC_USCORENetworkLocationType (603)
#endif

/* ns1__MTC_USCORELogValueType ** has binding name 'PointerToPointerTons1__MTC_USCORELogValueType' for type 'ns1:MTC_LogValueType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MTC_USCORELogValueType
#define SOAP_TYPE_PointerToPointerTons1__MTC_USCORELogValueType (602)
#endif

/* ns1__MTC_USCORELogValueType * has binding name 'PointerTons1__MTC_USCORELogValueType' for type 'ns1:MTC_LogValueType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORELogValueType
#define SOAP_TYPE_PointerTons1__MTC_USCORELogValueType (601)
#endif

/* ns1__MTC_USCOREEquipmentInfoType * has binding name 'PointerTons1__MTC_USCOREEquipmentInfoType' for type 'ns1:MTC_EquipmentInfoType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREEquipmentInfoType
#define SOAP_TYPE_PointerTons1__MTC_USCOREEquipmentInfoType (600)
#endif

/* ns1__MTC_USCOREConfigVersionTypeList * has binding name 'PointerTons1__MTC_USCOREConfigVersionTypeList' for type 'ns1:MTC_ConfigVersionTypeList' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREConfigVersionTypeList
#define SOAP_TYPE_PointerTons1__MTC_USCOREConfigVersionTypeList (599)
#endif

/* ns1__MTC_USCORELocationType * has binding name 'PointerTons1__MTC_USCORELocationType' for type 'ns1:MTC_LocationType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORELocationType
#define SOAP_TYPE_PointerTons1__MTC_USCORELocationType (598)
#endif

/* ns1__MTC_USCOREActionExecutedContentType * has binding name 'PointerTons1__MTC_USCOREActionExecutedContentType' for type 'ns1:MTC_ActionExecutedContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREActionExecutedContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREActionExecutedContentType (596)
#endif

/* ns1__MTC_USCORERestitutionTitleContentType * has binding name 'PointerTons1__MTC_USCORERestitutionTitleContentType' for type 'ns1:MTC_RestitutionTitleContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORERestitutionTitleContentType
#define SOAP_TYPE_PointerTons1__MTC_USCORERestitutionTitleContentType (595)
#endif

/* ns1__MTC_USCOREEditTitleContentType * has binding name 'PointerTons1__MTC_USCOREEditTitleContentType' for type 'ns1:MTC_EditTitleContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREEditTitleContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREEditTitleContentType (594)
#endif

/* ns1__MTC_USCOREValidationTitleContentType * has binding name 'PointerTons1__MTC_USCOREValidationTitleContentType' for type 'ns1:MTC_ValidationTitleContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREValidationTitleContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREValidationTitleContentType (593)
#endif

/* ns1__MTC_USCORERechargeTitleContentType * has binding name 'PointerTons1__MTC_USCORERechargeTitleContentType' for type 'ns1:MTC_RechargeTitleContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORERechargeTitleContentType
#define SOAP_TYPE_PointerTons1__MTC_USCORERechargeTitleContentType (592)
#endif

/* ns1__MTC_USCOREInstanceTitleContentType * has binding name 'PointerTons1__MTC_USCOREInstanceTitleContentType' for type 'ns1:MTC_InstanceTitleContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREInstanceTitleContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREInstanceTitleContentType (591)
#endif

/* ns1__MTC_USCOREDeleteProfileContentType * has binding name 'PointerTons1__MTC_USCOREDeleteProfileContentType' for type 'ns1:MTC_DeleteProfileContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREDeleteProfileContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREDeleteProfileContentType (590)
#endif

/* ns1__MTC_USCOREEditProfileContentType * has binding name 'PointerTons1__MTC_USCOREEditProfileContentType' for type 'ns1:MTC_EditProfileContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREEditProfileContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREEditProfileContentType (589)
#endif

/* ns1__MTC_USCOREInstanceProfileContentType * has binding name 'PointerTons1__MTC_USCOREInstanceProfileContentType' for type 'ns1:MTC_InstanceProfileContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREInstanceProfileContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREInstanceProfileContentType (588)
#endif

/* ns1__MTC_USCOREEditAppContentType * has binding name 'PointerTons1__MTC_USCOREEditAppContentType' for type 'ns1:MTC_EditAppContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREEditAppContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREEditAppContentType (587)
#endif

/* ns1__MTC_USCOREInstanceAppContentType * has binding name 'PointerTons1__MTC_USCOREInstanceAppContentType' for type 'ns1:MTC_InstanceAppContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREInstanceAppContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREInstanceAppContentType (586)
#endif

/* ns1__MTC_USCOREInitializationSusContentType * has binding name 'PointerTons1__MTC_USCOREInitializationSusContentType' for type 'ns1:MTC_InitializationSusContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREInitializationSusContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREInitializationSusContentType (585)
#endif

/* ns1__MTC_USCOREFabricationSusContentType * has binding name 'PointerTons1__MTC_USCOREFabricationSusContentType' for type 'ns1:MTC_FabricationSusContentType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREFabricationSusContentType
#define SOAP_TYPE_PointerTons1__MTC_USCOREFabricationSusContentType (584)
#endif

/* ns1__SignedTransactionMTCRegType * has binding name 'PointerTons1__SignedTransactionMTCRegType' for type 'ns1:SignedTransactionMTCRegType' */
#ifndef SOAP_TYPE_PointerTons1__SignedTransactionMTCRegType
#define SOAP_TYPE_PointerTons1__SignedTransactionMTCRegType (583)
#endif

/* ns1__MTC_USCOREUnsignedTransactionRegType * has binding name 'PointerTons1__MTC_USCOREUnsignedTransactionRegType' for type 'ns1:MTC_UnsignedTransactionRegType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCOREUnsignedTransactionRegType
#define SOAP_TYPE_PointerTons1__MTC_USCOREUnsignedTransactionRegType (582)
#endif

/* ns1__TransactionMTCRegType ** has binding name 'PointerToPointerTons1__TransactionMTCRegType' for type 'ns1:TransactionMTCRegType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TransactionMTCRegType
#define SOAP_TYPE_PointerToPointerTons1__TransactionMTCRegType (581)
#endif

/* ns1__TransactionMTCRegType * has binding name 'PointerTons1__TransactionMTCRegType' for type 'ns1:TransactionMTCRegType' */
#ifndef SOAP_TYPE_PointerTons1__TransactionMTCRegType
#define SOAP_TYPE_PointerTons1__TransactionMTCRegType (580)
#endif

/* xsd__anyType * has binding name 'PointerToxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_PointerToxsd__anyType
#define SOAP_TYPE_PointerToxsd__anyType (579)
#endif

/* ns1__Vehicle * has binding name 'PointerTons1__Vehicle' for type 'ns1:Vehicle' */
#ifndef SOAP_TYPE_PointerTons1__Vehicle
#define SOAP_TYPE_PointerTons1__Vehicle (578)
#endif

/* ns1__ActionType ** has binding name 'PointerToPointerTons1__ActionType' for type 'ns1:ActionType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__ActionType
#define SOAP_TYPE_PointerToPointerTons1__ActionType (577)
#endif

/* ns1__ActionType * has binding name 'PointerTons1__ActionType' for type 'ns1:ActionType' */
#ifndef SOAP_TYPE_PointerTons1__ActionType
#define SOAP_TYPE_PointerTons1__ActionType (576)
#endif

/* ns1__PendingPaymentBalanceType * has binding name 'PointerTons1__PendingPaymentBalanceType' for type 'ns1:PendingPaymentBalanceType' */
#ifndef SOAP_TYPE_PointerTons1__PendingPaymentBalanceType
#define SOAP_TYPE_PointerTons1__PendingPaymentBalanceType (575)
#endif

/* ns1__FareMediumType * has binding name 'PointerTons1__FareMediumType' for type 'ns1:FareMediumType' */
#ifndef SOAP_TYPE_PointerTons1__FareMediumType
#define SOAP_TYPE_PointerTons1__FareMediumType (574)
#endif

/* ns1__mediaStockType ** has binding name 'PointerToPointerTons1__mediaStockType' for type 'ns1:mediaStockType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__mediaStockType
#define SOAP_TYPE_PointerToPointerTons1__mediaStockType (573)
#endif

/* ns1__mediaStockType * has binding name 'PointerTons1__mediaStockType' for type 'ns1:mediaStockType' */
#ifndef SOAP_TYPE_PointerTons1__mediaStockType
#define SOAP_TYPE_PointerTons1__mediaStockType (572)
#endif

/* ns1__monetaryUnit ** has binding name 'PointerToPointerTons1__monetaryUnit' for type 'ns1:monetaryUnit' */
#ifndef SOAP_TYPE_PointerToPointerTons1__monetaryUnit
#define SOAP_TYPE_PointerToPointerTons1__monetaryUnit (571)
#endif

/* ns1__monetaryUnit * has binding name 'PointerTons1__monetaryUnit' for type 'ns1:monetaryUnit' */
#ifndef SOAP_TYPE_PointerTons1__monetaryUnit
#define SOAP_TYPE_PointerTons1__monetaryUnit (570)
#endif

/* ns1__OperationType ** has binding name 'PointerToPointerTons1__OperationType' for type 'ns1:OperationType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__OperationType
#define SOAP_TYPE_PointerToPointerTons1__OperationType (569)
#endif

/* ns1__OperationType * has binding name 'PointerTons1__OperationType' for type 'ns1:OperationType' */
#ifndef SOAP_TYPE_PointerTons1__OperationType
#define SOAP_TYPE_PointerTons1__OperationType (568)
#endif

/* ns1__OperationListType * has binding name 'PointerTons1__OperationListType' for type 'ns1:OperationListType' */
#ifndef SOAP_TYPE_PointerTons1__OperationListType
#define SOAP_TYPE_PointerTons1__OperationListType (567)
#endif

/* ns1__MediaOperationType ** has binding name 'PointerToPointerTons1__MediaOperationType' for type 'ns1:MediaOperationType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MediaOperationType
#define SOAP_TYPE_PointerToPointerTons1__MediaOperationType (566)
#endif

/* ns1__MediaOperationType * has binding name 'PointerTons1__MediaOperationType' for type 'ns1:MediaOperationType' */
#ifndef SOAP_TYPE_PointerTons1__MediaOperationType
#define SOAP_TYPE_PointerTons1__MediaOperationType (565)
#endif

/* ns1__missingDataType ** has binding name 'PointerToPointerTons1__missingDataType' for type 'ns1:missingDataType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__missingDataType
#define SOAP_TYPE_PointerToPointerTons1__missingDataType (564)
#endif

/* ns1__missingDataType * has binding name 'PointerTons1__missingDataType' for type 'ns1:missingDataType' */
#ifndef SOAP_TYPE_PointerTons1__missingDataType
#define SOAP_TYPE_PointerTons1__missingDataType (563)
#endif

/* ns1__dataReportListType * has binding name 'PointerTons1__dataReportListType' for type 'ns1:dataReportListType' */
#ifndef SOAP_TYPE_PointerTons1__dataReportListType
#define SOAP_TYPE_PointerTons1__dataReportListType (562)
#endif

/* ns1__SlaveDataReportType ** has binding name 'PointerToPointerTons1__SlaveDataReportType' for type 'ns1:SlaveDataReportType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__SlaveDataReportType
#define SOAP_TYPE_PointerToPointerTons1__SlaveDataReportType (561)
#endif

/* ns1__SlaveDataReportType * has binding name 'PointerTons1__SlaveDataReportType' for type 'ns1:SlaveDataReportType' */
#ifndef SOAP_TYPE_PointerTons1__SlaveDataReportType
#define SOAP_TYPE_PointerTons1__SlaveDataReportType (560)
#endif

/* ns1__dataReportType ** has binding name 'PointerToPointerTons1__dataReportType' for type 'ns1:dataReportType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__dataReportType
#define SOAP_TYPE_PointerToPointerTons1__dataReportType (559)
#endif

/* ns1__dataReportType * has binding name 'PointerTons1__dataReportType' for type 'ns1:dataReportType' */
#ifndef SOAP_TYPE_PointerTons1__dataReportType
#define SOAP_TYPE_PointerTons1__dataReportType (558)
#endif

/* ns1__InvoiceReceiptType * has binding name 'PointerTons1__InvoiceReceiptType' for type 'ns1:InvoiceReceiptType' */
#ifndef SOAP_TYPE_PointerTons1__InvoiceReceiptType
#define SOAP_TYPE_PointerTons1__InvoiceReceiptType (557)
#endif

/* ns1__MoneyReturnedFlow ** has binding name 'PointerToPointerTons1__MoneyReturnedFlow' for type 'ns1:MoneyReturnedFlow' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MoneyReturnedFlow
#define SOAP_TYPE_PointerToPointerTons1__MoneyReturnedFlow (556)
#endif

/* ns1__MoneyReturnedFlow * has binding name 'PointerTons1__MoneyReturnedFlow' for type 'ns1:MoneyReturnedFlow' */
#ifndef SOAP_TYPE_PointerTons1__MoneyReturnedFlow
#define SOAP_TYPE_PointerTons1__MoneyReturnedFlow (555)
#endif

/* ns1__MoneyInsertedFlow ** has binding name 'PointerToPointerTons1__MoneyInsertedFlow' for type 'ns1:MoneyInsertedFlow' */
#ifndef SOAP_TYPE_PointerToPointerTons1__MoneyInsertedFlow
#define SOAP_TYPE_PointerToPointerTons1__MoneyInsertedFlow (554)
#endif

/* ns1__MoneyInsertedFlow * has binding name 'PointerTons1__MoneyInsertedFlow' for type 'ns1:MoneyInsertedFlow' */
#ifndef SOAP_TYPE_PointerTons1__MoneyInsertedFlow
#define SOAP_TYPE_PointerTons1__MoneyInsertedFlow (553)
#endif

/* ns1__AwardType ** has binding name 'PointerToPointerTons1__AwardType' for type 'ns1:AwardType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AwardType
#define SOAP_TYPE_PointerToPointerTons1__AwardType (552)
#endif

/* ns1__AwardType * has binding name 'PointerTons1__AwardType' for type 'ns1:AwardType' */
#ifndef SOAP_TYPE_PointerTons1__AwardType
#define SOAP_TYPE_PointerTons1__AwardType (551)
#endif

/* ns1__PaymentModeType ** has binding name 'PointerToPointerTons1__PaymentModeType' for type 'ns1:PaymentModeType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__PaymentModeType
#define SOAP_TYPE_PointerToPointerTons1__PaymentModeType (550)
#endif

/* ns1__PaymentModeType * has binding name 'PointerTons1__PaymentModeType' for type 'ns1:PaymentModeType' */
#ifndef SOAP_TYPE_PointerTons1__PaymentModeType
#define SOAP_TYPE_PointerTons1__PaymentModeType (549)
#endif

/* ns1__AccountingFailureInfo ** has binding name 'PointerToPointerTons1__AccountingFailureInfo' for type 'ns1:AccountingFailureInfo' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AccountingFailureInfo
#define SOAP_TYPE_PointerToPointerTons1__AccountingFailureInfo (548)
#endif

/* ns1__AccountingFailureInfo * has binding name 'PointerTons1__AccountingFailureInfo' for type 'ns1:AccountingFailureInfo' */
#ifndef SOAP_TYPE_PointerTons1__AccountingFailureInfo
#define SOAP_TYPE_PointerTons1__AccountingFailureInfo (547)
#endif

/* ns1__AccountingFailureType ** has binding name 'PointerToPointerTons1__AccountingFailureType' for type 'ns1:AccountingFailureType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AccountingFailureType
#define SOAP_TYPE_PointerToPointerTons1__AccountingFailureType (546)
#endif

/* ns1__AccountingFailureType * has binding name 'PointerTons1__AccountingFailureType' for type 'ns1:AccountingFailureType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingFailureType
#define SOAP_TYPE_PointerTons1__AccountingFailureType (545)
#endif

/* ns1__cardIdentificationType * has binding name 'PointerTons1__cardIdentificationType' for type 'ns1:cardIdentificationType' */
#ifndef SOAP_TYPE_PointerTons1__cardIdentificationType
#define SOAP_TYPE_PointerTons1__cardIdentificationType (544)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (543)
#endif

/* ns1__AccountingUnitInfo * has binding name 'PointerTons1__AccountingUnitInfo' for type 'ns1:AccountingUnitInfo' */
#ifndef SOAP_TYPE_PointerTons1__AccountingUnitInfo
#define SOAP_TYPE_PointerTons1__AccountingUnitInfo (542)
#endif

/* ns1__IdentificationDocument * has binding name 'PointerTons1__IdentificationDocument' for type 'ns1:IdentificationDocument' */
#ifndef SOAP_TYPE_PointerTons1__IdentificationDocument
#define SOAP_TYPE_PointerTons1__IdentificationDocument (541)
#endif

/* ns1__FareInfo * has binding name 'PointerTons1__FareInfo' for type 'ns1:FareInfo' */
#ifndef SOAP_TYPE_PointerTons1__FareInfo
#define SOAP_TYPE_PointerTons1__FareInfo (540)
#endif

/* ns1__taxAppliedType ** has binding name 'PointerToPointerTons1__taxAppliedType' for type 'ns1:taxAppliedType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__taxAppliedType
#define SOAP_TYPE_PointerToPointerTons1__taxAppliedType (539)
#endif

/* ns1__taxAppliedType * has binding name 'PointerTons1__taxAppliedType' for type 'ns1:taxAppliedType' */
#ifndef SOAP_TYPE_PointerTons1__taxAppliedType
#define SOAP_TYPE_PointerTons1__taxAppliedType (538)
#endif

/* ns1__CardDataMagType * has binding name 'PointerTons1__CardDataMagType' for type 'ns1:CardDataMagType' */
#ifndef SOAP_TYPE_PointerTons1__CardDataMagType
#define SOAP_TYPE_PointerTons1__CardDataMagType (537)
#endif

/* ns1__CardDataInfoType * has binding name 'PointerTons1__CardDataInfoType' for type 'ns1:CardDataInfoType' */
#ifndef SOAP_TYPE_PointerTons1__CardDataInfoType
#define SOAP_TYPE_PointerTons1__CardDataInfoType (536)
#endif

/* ns1__taxAppliedList * has binding name 'PointerTons1__taxAppliedList' for type 'ns1:taxAppliedList' */
#ifndef SOAP_TYPE_PointerTons1__taxAppliedList
#define SOAP_TYPE_PointerTons1__taxAppliedList (535)
#endif

/* ns1__TitleCodeType * has binding name 'PointerTons1__TitleCodeType' for type 'ns1:TitleCodeType' */
#ifndef SOAP_TYPE_PointerTons1__TitleCodeType
#define SOAP_TYPE_PointerTons1__TitleCodeType (533)
#endif

/* ns1__AccountingUnit ** has binding name 'PointerToPointerTons1__AccountingUnit' for type 'ns1:AccountingUnit' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AccountingUnit
#define SOAP_TYPE_PointerToPointerTons1__AccountingUnit (530)
#endif

/* ns1__AccountingUnit * has binding name 'PointerTons1__AccountingUnit' for type 'ns1:AccountingUnit' */
#ifndef SOAP_TYPE_PointerTons1__AccountingUnit
#define SOAP_TYPE_PointerTons1__AccountingUnit (529)
#endif

/* ns1__AccountingUnitType ** has binding name 'PointerToPointerTons1__AccountingUnitType' for type 'ns1:AccountingUnitType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__AccountingUnitType
#define SOAP_TYPE_PointerToPointerTons1__AccountingUnitType (528)
#endif

/* ns1__AccountingUnitType * has binding name 'PointerTons1__AccountingUnitType' for type 'ns1:AccountingUnitType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingUnitType
#define SOAP_TYPE_PointerTons1__AccountingUnitType (527)
#endif

/* ns1__ReceiptItem * has binding name 'PointerTons1__ReceiptItem' for type 'ns1:ReceiptItem' */
#ifndef SOAP_TYPE_PointerTons1__ReceiptItem
#define SOAP_TYPE_PointerTons1__ReceiptItem (526)
#endif

/* ns1__ReceiptLine ** has binding name 'PointerToPointerTons1__ReceiptLine' for type 'ns1:ReceiptLine' */
#ifndef SOAP_TYPE_PointerToPointerTons1__ReceiptLine
#define SOAP_TYPE_PointerToPointerTons1__ReceiptLine (525)
#endif

/* ns1__ReceiptLine * has binding name 'PointerTons1__ReceiptLine' for type 'ns1:ReceiptLine' */
#ifndef SOAP_TYPE_PointerTons1__ReceiptLine
#define SOAP_TYPE_PointerTons1__ReceiptLine (524)
#endif

/* ns1__valOpMagType * has binding name 'PointerTons1__valOpMagType' for type 'ns1:valOpMagType' */
#ifndef SOAP_TYPE_PointerTons1__valOpMagType
#define SOAP_TYPE_PointerTons1__valOpMagType (523)
#endif

/* ns1__cardDataMagBody * has binding name 'PointerTons1__cardDataMagBody' for type 'ns1:cardDataMagBody' */
#ifndef SOAP_TYPE_PointerTons1__cardDataMagBody
#define SOAP_TYPE_PointerTons1__cardDataMagBody (522)
#endif

/* ns1__cardDataMagHeader * has binding name 'PointerTons1__cardDataMagHeader' for type 'ns1:cardDataMagHeader' */
#ifndef SOAP_TYPE_PointerTons1__cardDataMagHeader
#define SOAP_TYPE_PointerTons1__cardDataMagHeader (521)
#endif

/* xsd__hexBinary * has binding name 'PointerToxsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_PointerToxsd__hexBinary
#define SOAP_TYPE_PointerToxsd__hexBinary (520)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (519)
#endif

/* ns1__FareMedia * has binding name 'PointerTons1__FareMedia' for type 'ns1:FareMedia' */
#ifndef SOAP_TYPE_PointerTons1__FareMedia
#define SOAP_TYPE_PointerTons1__FareMedia (518)
#endif

/* ns1__FareProduct ** has binding name 'PointerToPointerTons1__FareProduct' for type 'ns1:FareProduct' */
#ifndef SOAP_TYPE_PointerToPointerTons1__FareProduct
#define SOAP_TYPE_PointerToPointerTons1__FareProduct (517)
#endif

/* ns1__FareProduct * has binding name 'PointerTons1__FareProduct' for type 'ns1:FareProduct' */
#ifndef SOAP_TYPE_PointerTons1__FareProduct
#define SOAP_TYPE_PointerTons1__FareProduct (516)
#endif

/* ns1__LocationBoardType * has binding name 'PointerTons1__LocationBoardType' for type 'ns1:LocationBoardType' */
#ifndef SOAP_TYPE_PointerTons1__LocationBoardType
#define SOAP_TYPE_PointerTons1__LocationBoardType (515)
#endif

/* ns1__LocationStationType * has binding name 'PointerTons1__LocationStationType' for type 'ns1:LocationStationType' */
#ifndef SOAP_TYPE_PointerTons1__LocationStationType
#define SOAP_TYPE_PointerTons1__LocationStationType (514)
#endif

/* ns1__AVLocation * has binding name 'PointerTons1__AVLocation' for type 'ns1:AVLocation' */
#ifndef SOAP_TYPE_PointerTons1__AVLocation
#define SOAP_TYPE_PointerTons1__AVLocation (513)
#endif

/* ns1__OperationalLocation * has binding name 'PointerTons1__OperationalLocation' for type 'ns1:OperationalLocation' */
#ifndef SOAP_TYPE_PointerTons1__OperationalLocation
#define SOAP_TYPE_PointerTons1__OperationalLocation (512)
#endif

/* ns1__OnboardLocation * has binding name 'PointerTons1__OnboardLocation' for type 'ns1:OnboardLocation' */
#ifndef SOAP_TYPE_PointerTons1__OnboardLocation
#define SOAP_TYPE_PointerTons1__OnboardLocation (511)
#endif

/* ns1__FixedLocation * has binding name 'PointerTons1__FixedLocation' for type 'ns1:FixedLocation' */
#ifndef SOAP_TYPE_PointerTons1__FixedLocation
#define SOAP_TYPE_PointerTons1__FixedLocation (510)
#endif

/* ns1__ConfigVersionType ** has binding name 'PointerToPointerTons1__ConfigVersionType' for type 'ns1:ConfigVersionType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__ConfigVersionType
#define SOAP_TYPE_PointerToPointerTons1__ConfigVersionType (509)
#endif

/* ns1__ConfigVersionType * has binding name 'PointerTons1__ConfigVersionType' for type 'ns1:ConfigVersionType' */
#ifndef SOAP_TYPE_PointerTons1__ConfigVersionType
#define SOAP_TYPE_PointerTons1__ConfigVersionType (508)
#endif

/* ns1__stSWFileType ** has binding name 'PointerToPointerTons1__stSWFileType' for type 'ns1:stSWFileType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__stSWFileType
#define SOAP_TYPE_PointerToPointerTons1__stSWFileType (507)
#endif

/* ns1__stSWFileType * has binding name 'PointerTons1__stSWFileType' for type 'ns1:stSWFileType' */
#ifndef SOAP_TYPE_PointerTons1__stSWFileType
#define SOAP_TYPE_PointerTons1__stSWFileType (506)
#endif

/* ns1__stConfigFileType ** has binding name 'PointerToPointerTons1__stConfigFileType' for type 'ns1:stConfigFileType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__stConfigFileType
#define SOAP_TYPE_PointerToPointerTons1__stConfigFileType (505)
#endif

/* ns1__stConfigFileType * has binding name 'PointerTons1__stConfigFileType' for type 'ns1:stConfigFileType' */
#ifndef SOAP_TYPE_PointerTons1__stConfigFileType
#define SOAP_TYPE_PointerTons1__stConfigFileType (504)
#endif

/* ns1__stSWFileListType * has binding name 'PointerTons1__stSWFileListType' for type 'ns1:stSWFileListType' */
#ifndef SOAP_TYPE_PointerTons1__stSWFileListType
#define SOAP_TYPE_PointerTons1__stSWFileListType (503)
#endif

/* ns1__stConfigFileListType * has binding name 'PointerTons1__stConfigFileListType' for type 'ns1:stConfigFileListType' */
#ifndef SOAP_TYPE_PointerTons1__stConfigFileListType
#define SOAP_TYPE_PointerTons1__stConfigFileListType (502)
#endif

/* ns1__stPackageType ** has binding name 'PointerToPointerTons1__stPackageType' for type 'ns1:stPackageType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__stPackageType
#define SOAP_TYPE_PointerToPointerTons1__stPackageType (501)
#endif

/* ns1__stPackageType * has binding name 'PointerTons1__stPackageType' for type 'ns1:stPackageType' */
#ifndef SOAP_TYPE_PointerTons1__stPackageType
#define SOAP_TYPE_PointerTons1__stPackageType (500)
#endif

/* ns1__OperationInfoType * has binding name 'PointerTons1__OperationInfoType' for type 'ns1:OperationInfoType' */
#ifndef SOAP_TYPE_PointerTons1__OperationInfoType
#define SOAP_TYPE_PointerTons1__OperationInfoType (499)
#endif

/* ns1__LocationType * has binding name 'PointerTons1__LocationType' for type 'ns1:LocationType' */
#ifndef SOAP_TYPE_PointerTons1__LocationType
#define SOAP_TYPE_PointerTons1__LocationType (498)
#endif

/* ns1__ConfigVersionTypeList * has binding name 'PointerTons1__ConfigVersionTypeList' for type 'ns1:ConfigVersionTypeList' */
#ifndef SOAP_TYPE_PointerTons1__ConfigVersionTypeList
#define SOAP_TYPE_PointerTons1__ConfigVersionTypeList (497)
#endif

/* ns1__SamQuotaUpdateRecordType * has binding name 'PointerTons1__SamQuotaUpdateRecordType' for type 'ns1:SamQuotaUpdateRecordType' */
#ifndef SOAP_TYPE_PointerTons1__SamQuotaUpdateRecordType
#define SOAP_TYPE_PointerTons1__SamQuotaUpdateRecordType (495)
#endif

/* ns1__ParkingValidationRecord * has binding name 'PointerTons1__ParkingValidationRecord' for type 'ns1:ParkingValidationRecord' */
#ifndef SOAP_TYPE_PointerTons1__ParkingValidationRecord
#define SOAP_TYPE_PointerTons1__ParkingValidationRecord (494)
#endif

/* ns1__IncidenceRecordType * has binding name 'PointerTons1__IncidenceRecordType' for type 'ns1:IncidenceRecordType' */
#ifndef SOAP_TYPE_PointerTons1__IncidenceRecordType
#define SOAP_TYPE_PointerTons1__IncidenceRecordType (493)
#endif

/* ns1__PrintedInvoiceRecordType * has binding name 'PointerTons1__PrintedInvoiceRecordType' for type 'ns1:PrintedInvoiceRecordType' */
#ifndef SOAP_TYPE_PointerTons1__PrintedInvoiceRecordType
#define SOAP_TYPE_PointerTons1__PrintedInvoiceRecordType (492)
#endif

/* ns1__EndTripRecordType * has binding name 'PointerTons1__EndTripRecordType' for type 'ns1:EndTripRecordType' */
#ifndef SOAP_TYPE_PointerTons1__EndTripRecordType
#define SOAP_TYPE_PointerTons1__EndTripRecordType (491)
#endif

/* ns1__StartTripRecordType * has binding name 'PointerTons1__StartTripRecordType' for type 'ns1:StartTripRecordType' */
#ifndef SOAP_TYPE_PointerTons1__StartTripRecordType
#define SOAP_TYPE_PointerTons1__StartTripRecordType (490)
#endif

/* ns1__InternalFailureRecordType * has binding name 'PointerTons1__InternalFailureRecordType' for type 'ns1:InternalFailureRecordType' */
#ifndef SOAP_TYPE_PointerTons1__InternalFailureRecordType
#define SOAP_TYPE_PointerTons1__InternalFailureRecordType (489)
#endif

/* ns1__InspectionRecordType * has binding name 'PointerTons1__InspectionRecordType' for type 'ns1:InspectionRecordType' */
#ifndef SOAP_TYPE_PointerTons1__InspectionRecordType
#define SOAP_TYPE_PointerTons1__InspectionRecordType (488)
#endif

/* ns1__MediaUpdateStatusRecordType * has binding name 'PointerTons1__MediaUpdateStatusRecordType' for type 'ns1:MediaUpdateStatusRecordType' */
#ifndef SOAP_TYPE_PointerTons1__MediaUpdateStatusRecordType
#define SOAP_TYPE_PointerTons1__MediaUpdateStatusRecordType (487)
#endif

/* ns1__CscPersonalizationRecordType * has binding name 'PointerTons1__CscPersonalizationRecordType' for type 'ns1:CscPersonalizationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CscPersonalizationRecordType
#define SOAP_TYPE_PointerTons1__CscPersonalizationRecordType (486)
#endif

/* ns1__CsmInitializationRecordType * has binding name 'PointerTons1__CsmInitializationRecordType' for type 'ns1:CsmInitializationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CsmInitializationRecordType
#define SOAP_TYPE_PointerTons1__CsmInitializationRecordType (485)
#endif

/* ns1__CscKeyUpdateRecordType * has binding name 'PointerTons1__CscKeyUpdateRecordType' for type 'ns1:CscKeyUpdateRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CscKeyUpdateRecordType
#define SOAP_TYPE_PointerTons1__CscKeyUpdateRecordType (484)
#endif

/* ns1__CscDeliveryRecordType * has binding name 'PointerTons1__CscDeliveryRecordType' for type 'ns1:CscDeliveryRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CscDeliveryRecordType
#define SOAP_TYPE_PointerTons1__CscDeliveryRecordType (483)
#endif

/* ns1__IssueOperationRecordType * has binding name 'PointerTons1__IssueOperationRecordType' for type 'ns1:IssueOperationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__IssueOperationRecordType
#define SOAP_TYPE_PointerTons1__IssueOperationRecordType (482)
#endif

/* ns1__TicketExchangeRecordType * has binding name 'PointerTons1__TicketExchangeRecordType' for type 'ns1:TicketExchangeRecordType' */
#ifndef SOAP_TYPE_PointerTons1__TicketExchangeRecordType
#define SOAP_TYPE_PointerTons1__TicketExchangeRecordType (481)
#endif

/* ns1__CscRefundRecordType * has binding name 'PointerTons1__CscRefundRecordType' for type 'ns1:CscRefundRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CscRefundRecordType
#define SOAP_TYPE_PointerTons1__CscRefundRecordType (480)
#endif

/* ns1__CscReplacementRecordType * has binding name 'PointerTons1__CscReplacementRecordType' for type 'ns1:CscReplacementRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CscReplacementRecordType
#define SOAP_TYPE_PointerTons1__CscReplacementRecordType (479)
#endif

/* ns1__CashCountingAdjustRecordType * has binding name 'PointerTons1__CashCountingAdjustRecordType' for type 'ns1:CashCountingAdjustRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CashCountingAdjustRecordType
#define SOAP_TYPE_PointerTons1__CashCountingAdjustRecordType (478)
#endif

/* ns1__CashCountingRecordType * has binding name 'PointerTons1__CashCountingRecordType' for type 'ns1:CashCountingRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CashCountingRecordType
#define SOAP_TYPE_PointerTons1__CashCountingRecordType (477)
#endif

/* ns1__MediaStockAdjustRecordType * has binding name 'PointerTons1__MediaStockAdjustRecordType' for type 'ns1:MediaStockAdjustRecordType' */
#ifndef SOAP_TYPE_PointerTons1__MediaStockAdjustRecordType
#define SOAP_TYPE_PointerTons1__MediaStockAdjustRecordType (476)
#endif

/* ns1__MediaStockUpdateRecordType * has binding name 'PointerTons1__MediaStockUpdateRecordType' for type 'ns1:MediaStockUpdateRecordType' */
#ifndef SOAP_TYPE_PointerTons1__MediaStockUpdateRecordType
#define SOAP_TYPE_PointerTons1__MediaStockUpdateRecordType (475)
#endif

/* ns1__CoinsAndNotesCollectionRecordType * has binding name 'PointerTons1__CoinsAndNotesCollectionRecordType' for type 'ns1:CoinsAndNotesCollectionRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CoinsAndNotesCollectionRecordType
#define SOAP_TYPE_PointerTons1__CoinsAndNotesCollectionRecordType (474)
#endif

/* ns1__CashMaintenanceRecordType * has binding name 'PointerTons1__CashMaintenanceRecordType' for type 'ns1:CashMaintenanceRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CashMaintenanceRecordType
#define SOAP_TYPE_PointerTons1__CashMaintenanceRecordType (473)
#endif

/* ns1__CoinNoteRefillAdjustmentRecordType * has binding name 'PointerTons1__CoinNoteRefillAdjustmentRecordType' for type 'ns1:CoinNoteRefillAdjustmentRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CoinNoteRefillAdjustmentRecordType
#define SOAP_TYPE_PointerTons1__CoinNoteRefillAdjustmentRecordType (472)
#endif

/* ns1__InternalCoinFlowRecordType * has binding name 'PointerTons1__InternalCoinFlowRecordType' for type 'ns1:InternalCoinFlowRecordType' */
#ifndef SOAP_TYPE_PointerTons1__InternalCoinFlowRecordType
#define SOAP_TYPE_PointerTons1__InternalCoinFlowRecordType (471)
#endif

/* ns1__CoinNoteRefillRecordType * has binding name 'PointerTons1__CoinNoteRefillRecordType' for type 'ns1:CoinNoteRefillRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CoinNoteRefillRecordType
#define SOAP_TYPE_PointerTons1__CoinNoteRefillRecordType (470)
#endif

/* ns1__CollectionRecordType * has binding name 'PointerTons1__CollectionRecordType' for type 'ns1:CollectionRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CollectionRecordType
#define SOAP_TYPE_PointerTons1__CollectionRecordType (469)
#endif

/* ns1__GateRejectionAnalysisRecordType * has binding name 'PointerTons1__GateRejectionAnalysisRecordType' for type 'ns1:GateRejectionAnalysisRecordType' */
#ifndef SOAP_TYPE_PointerTons1__GateRejectionAnalysisRecordType
#define SOAP_TYPE_PointerTons1__GateRejectionAnalysisRecordType (468)
#endif

/* ns1__PenaltyRecordType * has binding name 'PointerTons1__PenaltyRecordType' for type 'ns1:PenaltyRecordType' */
#ifndef SOAP_TYPE_PointerTons1__PenaltyRecordType
#define SOAP_TYPE_PointerTons1__PenaltyRecordType (467)
#endif

/* ns1__ValidationRecordType * has binding name 'PointerTons1__ValidationRecordType' for type 'ns1:ValidationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__ValidationRecordType
#define SOAP_TYPE_PointerTons1__ValidationRecordType (466)
#endif

/* ns1__AdvancedPurchaseRecordType * has binding name 'PointerTons1__AdvancedPurchaseRecordType' for type 'ns1:AdvancedPurchaseRecordType' */
#ifndef SOAP_TYPE_PointerTons1__AdvancedPurchaseRecordType
#define SOAP_TYPE_PointerTons1__AdvancedPurchaseRecordType (465)
#endif

/* ns1__MaintenanceOperationRecordType * has binding name 'PointerTons1__MaintenanceOperationRecordType' for type 'ns1:MaintenanceOperationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__MaintenanceOperationRecordType
#define SOAP_TYPE_PointerTons1__MaintenanceOperationRecordType (464)
#endif

/* ns1__AccountingOperationRecordType * has binding name 'PointerTons1__AccountingOperationRecordType' for type 'ns1:AccountingOperationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__AccountingOperationRecordType
#define SOAP_TYPE_PointerTons1__AccountingOperationRecordType (463)
#endif

/* ns1__OpenWideAisleGateRecordType * has binding name 'PointerTons1__OpenWideAisleGateRecordType' for type 'ns1:OpenWideAisleGateRecordType' */
#ifndef SOAP_TYPE_PointerTons1__OpenWideAisleGateRecordType
#define SOAP_TYPE_PointerTons1__OpenWideAisleGateRecordType (462)
#endif

/* ns1__OpenGatePsmRecordType * has binding name 'PointerTons1__OpenGatePsmRecordType' for type 'ns1:OpenGatePsmRecordType' */
#ifndef SOAP_TYPE_PointerTons1__OpenGatePsmRecordType
#define SOAP_TYPE_PointerTons1__OpenGatePsmRecordType (461)
#endif

/* ns1__StationModeChangeRecordType * has binding name 'PointerTons1__StationModeChangeRecordType' for type 'ns1:StationModeChangeRecordType' */
#ifndef SOAP_TYPE_PointerTons1__StationModeChangeRecordType
#define SOAP_TYPE_PointerTons1__StationModeChangeRecordType (460)
#endif

/* ns1__CommandReportRecordType * has binding name 'PointerTons1__CommandReportRecordType' for type 'ns1:CommandReportRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CommandReportRecordType
#define SOAP_TYPE_PointerTons1__CommandReportRecordType (459)
#endif

/* ns1__UnlockShiftRecordType * has binding name 'PointerTons1__UnlockShiftRecordType' for type 'ns1:UnlockShiftRecordType' */
#ifndef SOAP_TYPE_PointerTons1__UnlockShiftRecordType
#define SOAP_TYPE_PointerTons1__UnlockShiftRecordType (458)
#endif

/* ns1__LockShiftRecordType * has binding name 'PointerTons1__LockShiftRecordType' for type 'ns1:LockShiftRecordType' */
#ifndef SOAP_TYPE_PointerTons1__LockShiftRecordType
#define SOAP_TYPE_PointerTons1__LockShiftRecordType (457)
#endif

/* ns1__EndShiftRecordType * has binding name 'PointerTons1__EndShiftRecordType' for type 'ns1:EndShiftRecordType' */
#ifndef SOAP_TYPE_PointerTons1__EndShiftRecordType
#define SOAP_TYPE_PointerTons1__EndShiftRecordType (456)
#endif

/* ns1__BeginShiftRecordType * has binding name 'PointerTons1__BeginShiftRecordType' for type 'ns1:BeginShiftRecordType' */
#ifndef SOAP_TYPE_PointerTons1__BeginShiftRecordType
#define SOAP_TYPE_PointerTons1__BeginShiftRecordType (455)
#endif

/* ns1__MaintenanceAccessRecordType * has binding name 'PointerTons1__MaintenanceAccessRecordType' for type 'ns1:MaintenanceAccessRecordType' */
#ifndef SOAP_TYPE_PointerTons1__MaintenanceAccessRecordType
#define SOAP_TYPE_PointerTons1__MaintenanceAccessRecordType (454)
#endif

/* ns1__LoginFailureRecordType * has binding name 'PointerTons1__LoginFailureRecordType' for type 'ns1:LoginFailureRecordType' */
#ifndef SOAP_TYPE_PointerTons1__LoginFailureRecordType
#define SOAP_TYPE_PointerTons1__LoginFailureRecordType (453)
#endif

/* ns1__IdentificationRecordType * has binding name 'PointerTons1__IdentificationRecordType' for type 'ns1:IdentificationRecordType' */
#ifndef SOAP_TYPE_PointerTons1__IdentificationRecordType
#define SOAP_TYPE_PointerTons1__IdentificationRecordType (452)
#endif

/* ns1__OpEndOfSessionRecordType * has binding name 'PointerTons1__OpEndOfSessionRecordType' for type 'ns1:OpEndOfSessionRecordType' */
#ifndef SOAP_TYPE_PointerTons1__OpEndOfSessionRecordType
#define SOAP_TYPE_PointerTons1__OpEndOfSessionRecordType (451)
#endif

/* ns1__LocationChangeRecordType * has binding name 'PointerTons1__LocationChangeRecordType' for type 'ns1:LocationChangeRecordType' */
#ifndef SOAP_TYPE_PointerTons1__LocationChangeRecordType
#define SOAP_TYPE_PointerTons1__LocationChangeRecordType (450)
#endif

/* ns1__ActionListRecordType * has binding name 'PointerTons1__ActionListRecordType' for type 'ns1:ActionListRecordType' */
#ifndef SOAP_TYPE_PointerTons1__ActionListRecordType
#define SOAP_TYPE_PointerTons1__ActionListRecordType (449)
#endif

/* ns1__CsmUnblockingRecordType * has binding name 'PointerTons1__CsmUnblockingRecordType' for type 'ns1:CsmUnblockingRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CsmUnblockingRecordType
#define SOAP_TYPE_PointerTons1__CsmUnblockingRecordType (448)
#endif

/* ns1__CsmBlockingRecordType * has binding name 'PointerTons1__CsmBlockingRecordType' for type 'ns1:CsmBlockingRecordType' */
#ifndef SOAP_TYPE_PointerTons1__CsmBlockingRecordType
#define SOAP_TYPE_PointerTons1__CsmBlockingRecordType (447)
#endif

/* ns1__EndOfSessionRecordType * has binding name 'PointerTons1__EndOfSessionRecordType' for type 'ns1:EndOfSessionRecordType' */
#ifndef SOAP_TYPE_PointerTons1__EndOfSessionRecordType
#define SOAP_TYPE_PointerTons1__EndOfSessionRecordType (446)
#endif

/* ns1__StartOfSessionRecordType * has binding name 'PointerTons1__StartOfSessionRecordType' for type 'ns1:StartOfSessionRecordType' */
#ifndef SOAP_TYPE_PointerTons1__StartOfSessionRecordType
#define SOAP_TYPE_PointerTons1__StartOfSessionRecordType (445)
#endif

/* ns1__StartUpRecordType * has binding name 'PointerTons1__StartUpRecordType' for type 'ns1:StartUpRecordType' */
#ifndef SOAP_TYPE_PointerTons1__StartUpRecordType
#define SOAP_TYPE_PointerTons1__StartUpRecordType (444)
#endif

/* ns1__SignedRecordType * has binding name 'PointerTons1__SignedRecordType' for type 'ns1:SignedRecordType' */
#ifndef SOAP_TYPE_PointerTons1__SignedRecordType
#define SOAP_TYPE_PointerTons1__SignedRecordType (443)
#endif

/* ns1__UnsignedRecordType * has binding name 'PointerTons1__UnsignedRecordType' for type 'ns1:UnsignedRecordType' */
#ifndef SOAP_TYPE_PointerTons1__UnsignedRecordType
#define SOAP_TYPE_PointerTons1__UnsignedRecordType (442)
#endif

/* ns1__RecordType ** has binding name 'PointerToPointerTons1__RecordType' for type 'ns1:RecordType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__RecordType
#define SOAP_TYPE_PointerToPointerTons1__RecordType (441)
#endif

/* ns1__RecordType * has binding name 'PointerTons1__RecordType' for type 'ns1:RecordType' */
#ifndef SOAP_TYPE_PointerTons1__RecordType
#define SOAP_TYPE_PointerTons1__RecordType (440)
#endif

/* ns1__FileConfigVersionType ** has binding name 'PointerToPointerTons1__FileConfigVersionType' for type 'ns1:FileConfigVersionType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__FileConfigVersionType
#define SOAP_TYPE_PointerToPointerTons1__FileConfigVersionType (439)
#endif

/* ns1__FileConfigVersionType * has binding name 'PointerTons1__FileConfigVersionType' for type 'ns1:FileConfigVersionType' */
#ifndef SOAP_TYPE_PointerTons1__FileConfigVersionType
#define SOAP_TYPE_PointerTons1__FileConfigVersionType (438)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (437)
#endif

/* ns1__FileConfigVersionListType * has binding name 'PointerTons1__FileConfigVersionListType' for type 'ns1:FileConfigVersionListType' */
#ifndef SOAP_TYPE_PointerTons1__FileConfigVersionListType
#define SOAP_TYPE_PointerTons1__FileConfigVersionListType (436)
#endif

/* ns1__PackageConfigVersionType ** has binding name 'PointerToPointerTons1__PackageConfigVersionType' for type 'ns1:PackageConfigVersionType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__PackageConfigVersionType
#define SOAP_TYPE_PointerToPointerTons1__PackageConfigVersionType (435)
#endif

/* ns1__PackageConfigVersionType * has binding name 'PointerTons1__PackageConfigVersionType' for type 'ns1:PackageConfigVersionType' */
#ifndef SOAP_TYPE_PointerTons1__PackageConfigVersionType
#define SOAP_TYPE_PointerTons1__PackageConfigVersionType (434)
#endif

/* ns1__SrvConfigurationInfoResponseType * has binding name 'PointerTons1__SrvConfigurationInfoResponseType' for type 'ns1:SrvConfigurationInfoResponseType' */
#ifndef SOAP_TYPE_PointerTons1__SrvConfigurationInfoResponseType
#define SOAP_TYPE_PointerTons1__SrvConfigurationInfoResponseType (433)
#endif

/* ns1__CommandParamCCTIUType ** has binding name 'PointerToPointerTons1__CommandParamCCTIUType' for type 'ns1:CommandParamCCTIUType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__CommandParamCCTIUType
#define SOAP_TYPE_PointerToPointerTons1__CommandParamCCTIUType (432)
#endif

/* ns1__CommandParamCCTIUType * has binding name 'PointerTons1__CommandParamCCTIUType' for type 'ns1:CommandParamCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__CommandParamCCTIUType
#define SOAP_TYPE_PointerTons1__CommandParamCCTIUType (431)
#endif

/* ns1__CommandParamCCTIUListType * has binding name 'PointerTons1__CommandParamCCTIUListType' for type 'ns1:CommandParamCCTIUListType' */
#ifndef SOAP_TYPE_PointerTons1__CommandParamCCTIUListType
#define SOAP_TYPE_PointerTons1__CommandParamCCTIUListType (430)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_PointerTodouble
#define SOAP_TYPE_PointerTodouble (429)
#endif

/* float * has binding name 'PointerTofloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_PointerTofloat
#define SOAP_TYPE_PointerTofloat (428)
#endif

/* LONG64 * has binding name 'PointerToLONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_PointerToLONG64
#define SOAP_TYPE_PointerToLONG64 (427)
#endif

/* unsigned short * has binding name 'PointerTounsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_PointerTounsignedShort
#define SOAP_TYPE_PointerTounsignedShort (426)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (425)
#endif

/* ns1__ValueType * has binding name 'PointerTons1__ValueType' for type 'ns1:ValueType' */
#ifndef SOAP_TYPE_PointerTons1__ValueType
#define SOAP_TYPE_PointerTons1__ValueType (424)
#endif

/* ns1__ConfigElementCCTIUType ** has binding name 'PointerToPointerTons1__ConfigElementCCTIUType' for type 'ns1:ConfigElementCCTIUType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__ConfigElementCCTIUType
#define SOAP_TYPE_PointerToPointerTons1__ConfigElementCCTIUType (423)
#endif

/* ns1__ConfigElementCCTIUType * has binding name 'PointerTons1__ConfigElementCCTIUType' for type 'ns1:ConfigElementCCTIUType' */
#ifndef SOAP_TYPE_PointerTons1__ConfigElementCCTIUType
#define SOAP_TYPE_PointerTons1__ConfigElementCCTIUType (422)
#endif

/* ns1__MTC_USCORETransactionIdType * has binding name 'PointerTons1__MTC_USCORETransactionIdType' for type 'ns1:MTC_TransactionIdType' */
#ifndef SOAP_TYPE_PointerTons1__MTC_USCORETransactionIdType
#define SOAP_TYPE_PointerTons1__MTC_USCORETransactionIdType (421)
#endif

/* ns1__TransactionMTCIdRangeType ** has binding name 'PointerToPointerTons1__TransactionMTCIdRangeType' for type 'ns1:TransactionMTCIdRangeType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__TransactionMTCIdRangeType
#define SOAP_TYPE_PointerToPointerTons1__TransactionMTCIdRangeType (420)
#endif

/* ns1__TransactionMTCIdRangeType * has binding name 'PointerTons1__TransactionMTCIdRangeType' for type 'ns1:TransactionMTCIdRangeType' */
#ifndef SOAP_TYPE_PointerTons1__TransactionMTCIdRangeType
#define SOAP_TYPE_PointerTons1__TransactionMTCIdRangeType (419)
#endif

/* ns1__Parameter ** has binding name 'PointerToPointerTons1__Parameter' for type 'ns1:Parameter' */
#ifndef SOAP_TYPE_PointerToPointerTons1__Parameter
#define SOAP_TYPE_PointerToPointerTons1__Parameter (418)
#endif

/* ns1__Parameter * has binding name 'PointerTons1__Parameter' for type 'ns1:Parameter' */
#ifndef SOAP_TYPE_PointerTons1__Parameter
#define SOAP_TYPE_PointerTons1__Parameter (417)
#endif

/* ns1__ParameterList * has binding name 'PointerTons1__ParameterList' for type 'ns1:ParameterList' */
#ifndef SOAP_TYPE_PointerTons1__ParameterList
#define SOAP_TYPE_PointerTons1__ParameterList (416)
#endif

/* ns1__RecordIdType * has binding name 'PointerTons1__RecordIdType' for type 'ns1:RecordIdType' */
#ifndef SOAP_TYPE_PointerTons1__RecordIdType
#define SOAP_TYPE_PointerTons1__RecordIdType (415)
#endif

/* ns1__RecordRangeIdType ** has binding name 'PointerToPointerTons1__RecordRangeIdType' for type 'ns1:RecordRangeIdType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__RecordRangeIdType
#define SOAP_TYPE_PointerToPointerTons1__RecordRangeIdType (414)
#endif

/* ns1__RecordRangeIdType * has binding name 'PointerTons1__RecordRangeIdType' for type 'ns1:RecordRangeIdType' */
#ifndef SOAP_TYPE_PointerTons1__RecordRangeIdType
#define SOAP_TYPE_PointerTons1__RecordRangeIdType (413)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (412)
#endif

/* ns1__EquipmentReferenceType ** has binding name 'PointerToPointerTons1__EquipmentReferenceType' for type 'ns1:EquipmentReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTons1__EquipmentReferenceType
#define SOAP_TYPE_PointerToPointerTons1__EquipmentReferenceType (411)
#endif

/* ns1__SlaveEquipmentListType * has binding name 'PointerTons1__SlaveEquipmentListType' for type 'ns1:SlaveEquipmentListType' */
#ifndef SOAP_TYPE_PointerTons1__SlaveEquipmentListType
#define SOAP_TYPE_PointerTons1__SlaveEquipmentListType (410)
#endif

/* ns1__EquipmentReferenceType * has binding name 'PointerTons1__EquipmentReferenceType' for type 'ns1:EquipmentReferenceType' */
#ifndef SOAP_TYPE_PointerTons1__EquipmentReferenceType
#define SOAP_TYPE_PointerTons1__EquipmentReferenceType (409)
#endif

/* ns1__SrvConfigurationInfoRequestType * has binding name 'PointerTons1__SrvConfigurationInfoRequestType' for type 'ns1:SrvConfigurationInfoRequestType' */
#ifndef SOAP_TYPE_PointerTons1__SrvConfigurationInfoRequestType
#define SOAP_TYPE_PointerTons1__SrvConfigurationInfoRequestType (408)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (407)
#endif

/* xsd__positiveInteger has binding name 'xsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (33)
#endif

/* xsd__language has binding name 'xsd__language' for type 'xsd:language' */
#ifndef SOAP_TYPE_xsd__language
#define SOAP_TYPE_xsd__language (29)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (27)
#endif

/* xsd__date has binding name 'xsd__date' for type 'xsd:date' */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (17)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (12)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
